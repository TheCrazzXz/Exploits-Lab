# Exploits
## Heap overflow
Similar to the stack buffer overflow, heap overflow is a bug which occurs when the program tries to set data to a buffer exceeding the size of the buffer in the heap
Let's do a heap overflow  
First, let's create a char pointer that we will `malloc` on the heap for a size of `16 bytes`
It will malloc more than `16 bytes`, when we malloc a pointer, it will malloc a heap chunck that the pointer will point to, including some values, for more details about how a chuck works, here is a great video to understand from LiveOverflow : https://www.youtube.com/watch?v=HPDBOhiKaD8

Let's malloc it :
```c
char* ptr1 = malloc(16 * sizeof(char)) //by the way this is the same as doing malloc(16) because a character is 1 byte
```
The heap will look like this
```
...
[CHUNK 1] : 
  - Size : 16 bytes (+ chunk additional data)
  - Content : Nothing (for now)
```
Then let's set this pointer to something like `"AAAABBBB"` :
```c
// we should include the <string.h> library
strcpy(ptr1, "AAAABBBB");
```
The heap :
```
[CHUNK 1] : 
  - Size : 16 bytes (+ chunk additional data)
  - Content : 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 0, 0, 0, 0, 0, 0, 0, 0
```
Then let's malloc another chunck of also `16` where we will set the string `"XXXXXXXX"` :
```c
char* ptr2 = malloc(16 * sizeof(char)); // by the way this is the same as doing malloc(16) because a character is 1 byte
strcpy(ptr2, "XXXXXXXX");
```
The heap :
```
[CHUNK 1] : 
  - Size : 16 bytes (+ chunk additional data)
  - Content : 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 0, 0, 0, 0, 0, 0, 0, 0
[CHUNK 2] : 
  - Size : 16 bytes (+ chunk additional data)
  - Content : 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 0, 0, 0, 0, 0, 0, 0, 0
```
You can observe that the heap is growing in the opposite way than the stack, we have to take care of this for our overflow

We can do the overflow using same things as the stack thus `gets`, `scanf` or even `strcmp`  
Heap overflows are usually caused by `strcmp` but in any case, the same input for those functions is required to overflow, yes, just like the stack  
So let's try to overflow `ptr1` :
```c
char data[64];
```
`data` can come from any location, such as command line arguments or else, for this example, i just set data to a local variable  
To make the overflow, we have to fill the buffer with any data then comes the data that will be overflown to another heap chunck content :
```c
strcpy(data, "AAAAAAAAAAAAAAAA");
strcat(data, "AAAAAAAAAAAAAAAA"); // Some other data which is specific the the heap chunk we are overflowing
strcat(data, "<VALUE TO SET TO THE TARGET CHUNK CONTENT>") // Example : "Pwned!"
```
Then we can add the vulnerable code :
```c
strcpy(ptr1, data); # will overflow
```
But where will it overflow ? With a stack based buffer overflow it overflows at the buffer which is allocated before the one we're overflowing, in the heap, it's the opposite, it will overflow on the chunk that is allocated after the one we're overflowing, so in this case it's `ptr2`  
So here we overwrote the content of the chunk that `ptr2` is pointing to, to the : `<VALUE TO SET TO THE TARGET CHUNK CONTENT>`
  
//TODO: add heap representation here
  
And of course if we overflow more than the size of the buffer in the chunk that `ptr2` is pointing to (so the 16 bytes), it will overflow chunk details and if we overflow more, if there is another chunk after this one, it will also overwrite it, then it's details and so forth  
Thanks for reading
