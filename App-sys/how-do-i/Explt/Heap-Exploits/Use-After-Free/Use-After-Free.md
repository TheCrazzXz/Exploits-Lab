# Exploits
## Heap
### Use-After-Free
Use-after-free is part of vulnerabilities that the heap can be exposed, but what can it means ?... We **use** something **after** it has been **freed**  
So in the heap, there's **something** you can **free** and that you can **use**, of course, pointers ! You can **free** them and even after doing that, you can still use them, because they'll point to the address... Address that've been **freed** ?  
Let's see how the heap will look like after you **free** a pointer (oh and also, a pointer points to what is called a heap chuck)  
Let's create a pointer :
```c
<type> *<pointer> = malloc(<size>);
```
Heap :
```
(TOP ADDRESS=0xff04+<size>) 
[CHUNK]:<size> {address:0xff04}
```
Okay, so we created a chuck which has the size that we've specified, it could be like : `sizeof(int)` or `sizeof(char)*64` or whatever  
So in this example the chunck address is `0xff04` and it's also the top address of the heap (like when the stack pointer points the toppest element in the stack)  
In this example, we allocated 16 characters and we've also set them to `"AAAAAAAA"` :
```c
char *<pointer> = malloc(sizeof(char) * 16);
strcpy(<pointer>, "AAAAAAAA");
```
Heap :
```
(TOP ADDRESS=0xff04+16) 
[CHUNK]:16 bytes {address:0xff04} = "AAAAAAAA" 
```
Now let's try to **free** this pointer :
```c
free(<pointer>);
```
Heap :
```
(TOP ADDRESS=0xff04)
```
You can see that the chunk is gone, but the top address is now it's address, thus when we will malloc another chunk after that, we will malloc it to the top address  
I'mma also set it to `"BBBBBBBB"` :
```c
char *<pointer 2> = malloc(sizeof(char) * 16);
strcpy(<pointer 2>, "BBBBBBBB");
```
Heap :
```
[CHUNK]:16 bytes {address:0xff04} = "BBBBBBBB"
```
Yes, you can see that this chunk also points to `0xff04` which makes sense, because we malloc at the top address of the heap  
Do you remember the first pointer (`<pointer>`), it still also points to `0xff04` so that means that they both points at the same address so you did understand... :
```c
printf("pointer 1 : %s\n", <pointer>);
printf("pointer 2 : %s\n", <pointer 2>);
```
This will give us :
```
pointer 1 : BBBBBBBB
pointer 2 : BBBBBBBB
```
We got control of `<pointer>` without making any direct modifications on it  
Thanks for read !
