# Exploits
## Double Free (with bypass)
### Requirements : How fastbins works (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md)
### Introduction
A double free happens when we, as the name indicates, free a chunk twice
In this article, we'll have a look at what happens when a double free occurs, and how we can use it for exploitation  
First, some mitigations were added against double frees, but we'll see how to to bypass them, especially to tricks  
### Requirements to understand this attack
It's essential to understand how fastbins works
So if you don't know, you can check my article on the subject : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md
### Exploit
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
	char* a = malloc(10);
	char* b = malloc(10);
	char* c = malloc(10);

	printf("a@%p\n", a);
	printf("b@%p\n", b);
	printf("c@%p\n\n", c);

	memcpy(a, "hello!", 16);
	free(a);
	free(b);
	free(a);
```
Here's a double free, as you can see we allocate `a`, `b` and `c`  
Then we free `a`, `b` and... `a` again !  
As you can see we freed `a` two times  
But what's the point, and also here's what happens when we execute the program :
```
a@0x4052a0
b@0x4052c0
c@0x4052e0

free(): double free detected in tcache 2
zsh: abort      ./prog
```
These are the mitigation i was talking about before, it detected the double free...
**OK now BREAKDOWN**  
In theory this is what happens when we do this  
As you may know, when we allocate like `ptr1`, `ptr2`, `ptr3` then when we free them in the same order, our fastbin looks like this :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=... (ptr3), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=... (ptr2), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=... (ptr1), size=0x20, flags=PREV_INUSE)
```
Remember, values are added and deleted as a stack  
Now here, in this program, after the frees it looks like this, after the first free :
```c
free(a);
```
So here's our fastbin :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=... (a), size=0x20, flags=PREV_INUSE)
```
Then :
```c
free(b)
```
Fastbin :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=... (b), size=0x20, flags=PREV_INUSE)
←  Chunk(addr=... (a), size=0x20, flags=PREV_INUSE)
```
And finally :
```c
free(a) // we free a again
```
So here's our fastbin at this point :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=... (a), size=0x20, flags=PREV_INUSE)
←  Chunk(addr=... (b), size=0x20, flags=PREV_INUSE)
←  Chunk(addr=... (a), size=0x20, flags=PREV_INUSE)
```
As you can see, we have in our tcache (which acts like a fastbin) `a` twice, if we had no error message and if we allocated new chunks, in theory :
```c
int main(void)
{
	char* a = malloc(10);
	char* b = malloc(10);
	char* c = malloc(10);

	printf("a@%p\n", a);
	printf("b@%p\n", b);
	printf("c@%p\n\n", c);

	memcpy(a, "hello!", 16);
	free(a);
	free(b);
	free(a);

	// we should get "double free detected in tcache ..." message

	char* d = malloc(10);
	char* e = malloc(10);
	char* f = malloc(10);

	printf("d@%p\n", d);
	printf("e@%p\n", e);
	printf("f@%p\n", f);
}
```
Think about what will happen :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=... (a), size=0x20, flags=PREV_INUSE)
←  Chunk(addr=... (b), size=0x20, flags=PREV_INUSE)
←  Chunk(addr=... (a), size=0x20, flags=PREV_INUSE)
```
So when we malloc `d` :
```c
char* d = malloc(10); // => a
```
It will return the address of `a`, because it's at the top  
When we malloc `e` :
```c
char* e = malloc(10); // => b
```
It returns the address `b`  
So far nothing incredible... BUT can the spot the thing ?  
Now we will malloc `f` :
```
char* f = malloc(10); // => a AGAIN
```
So now for `f`, malloc will return `a` !!! It means that since `d` = `a` and `f` = `a`  
So now `d = f` !! So `d` and `f` have the same ADDRESSES !!  
It means that if we write any data to `d` memory, it will write it to `f` memory and also in the same way  
That awesome !  
But... Remember...
Before even that our allocation take place we have this message and the program aborts :
```
free(): double free detected in tcache 2
zsh: abort      ./prog
```
So it detected our double free... it detected that there are two `a`s in our tcache...  
But this only applies to tcache, and since tcache has been introduced since glibc 2.26, only glibc version >= 2.26 will be affected by this mitigation  
So this code still works in a glibc version < 2.26, because it won't allocate on tcache but directly on fastbins, because tcache doesn't exist in these versions...  
That means that normal fastbins doesn't have this protection... Interesting, we'll see that later
