# Exploits
## Heap Fastbin Attack
## Requirements to undestand : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md (fastbins)
Please before reading this article i NEED you to understand how a fastbin works (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md)  
So if you don't know, take a look  
## Insight
The exploit we're gonna see here is an arbiratry write exploit that so we can write to any address with it without changing anything directly from this address  
Let's have this C code to start :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
    unsigned long* ptr1 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr2 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr3 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f

    printf("ptr1 -> 0x%x => 0x%x\n", ptr1, *ptr1);
    printf("ptr2 -> 0x%x => 0x%x\n", ptr2, *ptr2);
    printf("ptr3 -> 0x%x => 0x%x\n", ptr3, *ptr3);

    memset(ptr1, 'A', 0x20);
    memset(ptr2, 'B', 0x20);
    memset(ptr3, 'C', 0x20);

    printf("Freeing pointers\n");
    free(ptr1);
    free(ptr2);
    free(ptr3);
}
```
So we said (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/The-Heap.md) that here `ptr1`, `ptr2` and `ptr3` are added to a linked list, the fastbin  
After the frees, so it will look like that :
```
Fastbins[idx=0, size=0x10] 
←  Chunk(addr=0x405010, size=0x20, flags=PREV_INUSE)
←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE) => 0x000000 (data not metadata) POINTS TO END OF LINKED LIST
←  Chunk(addr=0x4052d0 (ptr2), size=0x20, flags=PREV_INUSE) => 0x4052a0 (data) POINTS TO PTR1
←  Chunk(addr=0x405300 (ptr3), size=0x20, flags=PREV_INUSE) => 0x0052d0 (data) POINTS TO PTR2
```
We said that if we allocate new pointers as in order `ptr4`, `ptr5` and `ptr6` that have the same size `0x20`, then :
```
`ptr4` took the address of `ptr1`  
`ptr5` took the address that `ptr3` contains  
and `ptr6` took the address that `ptr2` contains  
```
In other terms, the value that contans `ptr2` controls where the next chunk will be allocated  
But who said this address has to be on the heap ? Let's try something crazy, let's allocate a heap chunk in any address, in the stack, so let's change the code :
```c
int main(void)
{
    unsigned long* ptr1 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr2 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
    unsigned long* ptr3 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f

    int changeMe = 98174;

    printf("ptr1 -> 0x%x => 0x%x\n", ptr1, *ptr1);
    printf("ptr2 -> 0x%x => 0x%x\n", ptr2, *ptr2);
    printf("ptr3 -> 0x%x => 0x%x\n", ptr3, *ptr3);

    memset(ptr1, 'A', 0x20);
    memset(ptr2, 'B', 0x20);
    memset(ptr3, 'C', 0x20);

    printf("Freeing pointers\n");
    free(ptr1);
    free(ptr2);
    free(ptr3);
}
```
So i added
