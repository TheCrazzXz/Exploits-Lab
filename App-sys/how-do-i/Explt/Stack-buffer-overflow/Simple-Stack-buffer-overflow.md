# EXPLOITS
## Stack Buffer overflow
## REQUIRED TO UNDERTSTAND : [How does the memory's stack works  ](https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/Memory-stack-explaination.md)

The stack buffer overflow is a vulnerability that we can exploit on a program where we can overwrite data on the stack which is outside an array  
For example, let's say you have two arrays :
```
int main(void)
{
	char arr1[4]
	char arr2[4];
}

```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  
These will be placed on the stack :  
The stack :
```
...

arr2   |  | ADDRESS x-7
arr2+1 |  | ADDRESS x-6
arr2+2 |  | ADDRESS x-5
arr2+3 |  | ADDRESS x-4
arr1   |  | ADDRESS x-3
arr1+1 |  | ADDRESS x-2
arr1+2 |  | ADDRESS x-1
arr1+3 |  | ADDRESS x
...
```
We know we can access elements of arrays such as `arr1[0]`, `arr1[2]` or `arr2[3]`...  
Now you might know that `array/pointer[index]` = `array/pointer+index`  
So here's the thing :  
`arr2[0]` = `arr2+0` = `arr2` = `ADDRESS x-7`  
`arr2[1]` = `arr2+1` = `ADDRESS x-6`
`arr2[2]` = `arr2+2` = `ADDRESS x-5`
`arr2[3]` = `arr2+3` = `ADDRESS x-4`
And now...
`arr2[4]` = `arr2+4` = ... `ADDRESS x-3` !!!  
By accessing `arr2[4]` which is out of bound we actually access `ADDRESS x-3` so we access `arr1` !  
So :
`arr2[4]` = `arr1[0]` = `ADDRESS x-3`  
`arr2[5]` = `arr1[1]` = `ADDRESS x-2`  
`arr2[6]` = `arr1[2]` = `ADDRESS x-1`  
`arr2[7]` = `arr1[3]` = `ADDRESS x`  
And this is what is the buffer overflow  
Let's say we have :
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	char arr1[] = "AAAA"; // allocates 5 bytes ("AAAA\x00")
	char arr2[] = "BBBB";// allocates 5 bytes ("BBBB\x00")
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
	
	arr2[5] = 'X';
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
}
```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  
The stack looks like this before the overflow :
```
...
arr2   |'B' | ADDRESS x-9
arr2+1 |'B' | ADDRESS x-8
arr2+2 |'B' | ADDRESS x-7
arr2+3 |'B' | ADDRESS x-6
arr2+4 |0x00| ADDRESS x-5

arr1   |'A' | ADDRESS x-4
arr1+1 |'A' | ADDRESS x-3
arr1+2 |'A' | ADDRESS x-2
arr1+3 |'B' | ADDRESS x-1
arr1+4 |0x00| ADDRESS x-0
...
```
Strings in C are NULL-Terminated so each array is actually 5 bytes because it allocates 1 more byte which is `0x00`
And it prints :
```
arr1 : AAAA
arr2 : BBBB
```
Now after the overflow :
```
...
arr2   |'B' | ADDRESS x-9
arr2+1 |'B' | ADDRESS x-8
arr2+2 |'B' | ADDRESS x-7
arr2+3 |'B' | ADDRESS x-6
arr2+4 |0x00| ADDRESS x-5

arr1   |'X' | ADDRESS x-4 <= arr2[5]
arr1+1 |'A' | ADDRESS x-3
arr1+2 |'A' | ADDRESS x-2
arr1+3 |'B' | ADDRESS x-1
arr1+4 |0x00| ADDRESS x-0
...
```
So we could change the `arr1[0]` which is `arr2[5]` without even accessing `arr1[0]`  
And this is the main idea of buffer overflow and stack buffer overflows  
In C there are functions that are vulnerable to buffer overflows, such as :

- scanf
- gets
- sprintf
- strcpy
- ...

So let's take the example of `scanf` :
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
	char arr1[] = "AAAA";
	char arr2[] = "BBBB";
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
	
	scanf("%s", arr2);
	
	printf("arr1 : %s\n", arr1);
	printf("arr2 : %s\n", arr2);
}
```
**/!\\ MAKE SURE TO USE `gcc <source.c> -o <executable> -fno-stack-protector` /!\\**  
The way we overflow it is that we enter 5 characters to fill the `arr2` buffer then the other bytes are gonna overflow it and then modify `arr2` :  
So we enter :
```
AAAAAXXXX
```
Now `arr2` is overflown and `arr2` were overwritten with `XXXX` :
```
arr1 : AAAA
arr2 : BBBB
AAAAAXXX
arr1 : XXX
arr2 : AAAAAXXX
```
