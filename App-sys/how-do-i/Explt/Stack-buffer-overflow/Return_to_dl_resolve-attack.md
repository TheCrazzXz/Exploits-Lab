# EXPLOITS
## STACK BUFFER OVERFLOW FOR Return into dlresolve attack (Ret2dl_resolve)
## REQUIRED TO UNDERSTAND : STACK BUFFER OVERFLOW FOR RETURN TO LIBC (ret2libc) and STACK BUFFER OVERFLOW FOR RETURN ORIENTED PROGRAMMING (ROP)
## Bypass protections : NX, ASLR
This is another attack to bypass NX and ASLR with a ret2libc  
In this attack, we will resolve a symbol of our choice (like system) then we can pass arguments to it (like /bin/sh)  
In order to do this, we will have to overwrite 3 structures  
There are two parts of the attack :
1. The preparing part
2. The dlresolve payload
During the preparing part, we will just set-up some addresses using some gadgets to let the real exploit work  
During the dlresolve part, we will overwrite those 3 structures  
These are the structures we will have to overwrite :
- The `SYMTAB` structure instance which is an instance of the `Elf32_Sym` structure :
```c
typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc>=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
```
- The `JMPTAB` structure which is from the segment `.rel.plt`, it's the relocation symbol, there are all the symbol entries stored in it which are instances of the strucutre `Elf32_Rel` :
```c
typedef uint32_t Elf32_Addr;
typedef uint32_t Elf32_Word;
typedef struct
{
  Elf32_Addr    r_offset;               /* Address */
  Elf32_Word    r_info;                 /* Relocation type and symbol index */
} Elf32_Rel;
/* How to extract and insert information held in the r_info field.  */
#define ELF32_R_SYM(val)                ((val) >> 8)
#define ELF32_R_TYPE(val)               ((val) & 0xff)
```
