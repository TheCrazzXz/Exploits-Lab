# Exploits
## Partial address overwrite with PIE
## Bypasses protections : ASLR, PIE (PIE can't be used without ASLR)
Now let's have a look at a technique which can bypass Position Independant Executable on a Little Endian system (most of systems work this way don't worry)  
If you don't know how PIE work i've explained it on this article talking about fork exploitation : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Exploit-fork.md  
To demonstrate how it works, here is a simple program compiled with ASLR and PIE :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void win(void)
{
	printf("You won !\n");
}
void nope()
{
	printf("Oops...\n");
}
void vuln()
{
	void (*func_pointer)(void) = nope;
	char buffer[64];
	printf("win address : %p\n", win);
	printf("function pointer before : %p\n", func_pointer);
	read(STDIN_FILENO, buffer, 256);
	printf("function pointer after : %p\n", func_pointer);
	func_pointer();
}
int main()
{
	vuln();
}
It's on 64 bits
```
To compile :
```
gcc <source code file>.c -o <executable> -fno-stack-protector -pie -fPIE -m64
```
Make sure to enable full ASLR :
```
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
So the goal is to jump to `win` whose address is randomized with PIE  
You can see that there's a function pointer to overwrite (we will rather overwrite the return pointer later but now i used a function pointer just to get how it works)  
I've also printed the addresses for now just to see how `PIE` behaves exactly  
So let's run the program :
```
win address : 0x55c24355b189
function pointer before : 0x55c24355b1a0
(input)
function pointer after : 0x55c24355b1a0
Oops...
```
We can see that it prints the `win` function address and the function pointer before and after the input which, is vulnerable to a buffer overflow, you can also see that i used `read`, i will explain why later  
So here the function pointer was pointing at `nope` so it printed this lose message  
Let's first look at the address of `win` and of the `func_pointer` :
```
Function pointer : 0x55c24355b1a0
Win address      : 0x55c24355b189
```
Did you see that ? They're almost the same ! Actually, only **ONE** byte differs, in other words, if we overwrite only the last byte of the address with the last byte of `win` then we win !  
So let's change the source code to remove leaks :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void win(void)
{
	printf("You won !\n");
}
void nope()
{
	printf("Oops...\n");
}
void vuln()
{
	void (*func_pointer)(void) = nope;
	char buffer[64];
	read(STDIN_FILENO, buffer, 256);
	func_pointer();
}
int main()
{
	vuln();
}
```
We can recompile by the same way as brefore
