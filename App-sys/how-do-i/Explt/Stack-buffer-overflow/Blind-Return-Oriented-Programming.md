# Exploits : Blind Return Oriented Programming
## Requires knowledge : Return Oriented Programming 
## Introduction
64 BITS
What is Blind Return Oriented Programming ?  
As you may know before getting there, there is something called Return Oriented Programming usually called `ROP`, this technique was an exploitation technique that is usually used to defeat every `NX` and `ASLR` things by never jumping to somewhere else than the `.text` segement, we had a look at what are gadgets and how to use them tto create a program inside our program that we could use to exploit it  
Now the thing is that, in normal ROP, we knew the binary, like we could debug it, take some addresses from it as we could read it...
Now imagine you want to attack a binary but completely blindly, you don't know anything about it, no compiled code, no source code, usually the main scenario is that it's a server running on TCP (but doesn't have to) where the program which is unknown by the attacker, now in this case, how can you exploit it ? How can you make any ROP, how can you get any gadget from it if you can't even read the binary ?  
Well, you probably already know what i'm gonna say, this is where Blind Return Oriented Programming often abreviated in Blind ROP on BROP comes to play  
With this technique, we can exploit the binary without even knowing it
## Conditions of the attack
In the case we want to exploit the binary, there are a few conditions, first, a `stack based buffer overflow`, logical (actually there are other vulnerabilities that are not this that can lead to this attack)  
Also, the binary has to respawn after crash, as we will try to make it crash and will reuse it many times  
If the program uses `PIE` or/and `Stack Canary`, it has to respawn after crash with the same memory as a looped fork does (i explain in this article : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Exploit-fork.md  

## General insight of the attack
If someone asked me to give a really abstract explaination of what is BROP, i would say this :
This is a 2 or 3 main steps attack :
* Step 1 (if the program uses `SSP` or/and `PIE`) : Stack Canary : Finding the stack canary and the RIP backup
* Step 2 : Finding gadgets with techniques and eventually find a write to our socket primitive : Basically, there is no direct way to leak data as we want to leak the whole binary at the end, so with some techniques and especially a crutial knowledge : Does the program crash when i do this or not we can get 3 required gadgets and the address of write function in PLT, the 3 gadgets are used to pass write argument
* Step 3 : Binary Leak : Once we have found our write and our gadgets so we can call it, we have an arbitrary read of any address, so we send its connect via our socket  

Once we have the binary, we are completely done, now we can exploit as a normal binary that we know
## Exploitation explaination
### Step 1 : Stack Reading
I won't cover the stack reading here (maybe later in the article)
### Step 2 : Finding gadgets and write

So we're looking for a way to control `RDI`, `RSI`, `RDX` and we want to find `write`  

Once we have them we can just :
* RDI : Buffer to write
* RSI : Size to write
* RDX : SOCKFD for the socket
And then call write  
Once we have them we can start leaking the binary  
**Finding Gadgets**  
For Blind ROP there are some gadgets that are used for the attack :
* Stop gadgets : When we jump to them, the program doesn't crash and is in an infinite loop  
* Trap gadgets : When we jump to them, the program crashes, for example a null ptr = 0 is a trap gadget because when we jump to it we crash  

Now we want to scan binary for gadgets
We're in a loop and at each iteration we overwrite RIP backup with an address, the address starts at, let's say the program base, which is usually `0x400000` in 64 bits binary, if it has PIE and you do stack reading you can find it, now at each iteration we test the next address, so we increment by 1
We call PROBE the address we're testing  

What i mean by probe is that we are testing an address PROBE and we want to understand its behaviour  

Now imagine the following payload :
```
BUFFER | RBP backup |  RIP backup
...    | 8 bytes    |  PROBE       
```
```
After the RIP backup we add this :  
| TRAP GADGET | TRAP GADGET |
| 8 bytes     | 8 bytes     |
```
Now imagine that the PROBE gadget is a :
```asm
pop <register>
ret
```
It will pop our first TRAP GADGET to the register  
Then it's gonna return the second TRAP GADGET  
Which will cause a crash because we're returning into a trap gadget  

Now imagine instead of our two trap gadgets we have this :
```
| STOP GADGET | STOP GADGET |
| 8 bytes     | 8 bytes     |
```
Imagine it's the same PROBE gadget  
So now it will pop the address of the STOP GADGET into the register  
Then because of the ret it's gonna return to the second STOP gadget  
And now it's not crashing anymore  
Now that the same behaviour is observed if instead of our two stop gadgets we have :
```
| TRAP GADGET | STOP GADGET |
| 8 bytes     | 8 bytes     |
```
In the case it's a :
```
pop <register>
ret
```
So it pops TRAP GADGET address into register  
And ret returns to the STOP GADGET  
And so the program doesn't crash neither  
Now what if we have the same disposition of our payload so :
`buffer THEN RBP backup THEN PROBE THEN TRAP GADGET THEN STOP GADGET`  
What if probe doesn't contain any pop (except then ret which pops rip)  
So for example :
```
xor eax, ebx
ret
```
Or even just :
```
ret
```
Since TRAP GADGET address in not popped before the ret  
It will return to the TRAP GADGET address and... Crash  
We can now identify certain types of gadgets  
**The BROP gadget**  
The BROP gadget is a specific gadget which consists of these instructions :  
```
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
ret
```
This gadget might tell you something if you have ever done some ret2csu  
