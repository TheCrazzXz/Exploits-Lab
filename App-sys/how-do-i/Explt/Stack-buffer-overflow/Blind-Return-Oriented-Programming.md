# Exploits : Blind Return Oriented Programming
## Requires knowledge : Return Oriented Programming 
## Introduction
64 BITS
What is Blind Return Oriented Programming ?  
As you may know before getting there, there is something called Return Oriented Programming usually called `ROP`, this technique was an exploitation technique that is usually used to defeat every `NX` and `ASLR` things by never jumping to somewhere else than the `.text` segement, we had a look at what are gadgets and how to use them tto create a program inside our program that we could use to exploit it  
Now the thing is that, in normal ROP, we knew the binary, like we could debug it, take some addresses from it as we could read it...
Now imagine you want to attack a binary but completely blindly, you don't know anything about it, no compiled code, no source code, usually the main scenario is that it's a server running on TCP (but doesn't have to) where the program which is unknown by the attacker, now in this case, how can you exploit it ? How can you make any ROP, how can you get any gadget from it if you can't even read the binary ?  
Well, you probably already know what i'm gonna say, this is where Blind Return Oriented Programming often abreviated in Blind ROP on BROP comes to play  
With this technique, we can exploit the binary without even knowing it
## Conditions of the attack
In the case we want to exploit the binary, there are a few conditions, first, a `stack based buffer overflow`, logical (actually there are other vulnerabilities that are not this that can lead to this attack)  
Also, the binary has to respawn after crash, as we will try to make it crash and will reuse it many times  
If the program uses `PIE` or/and `Stack Canary`, it has to respawn after crash with the same memory as a looped fork does (i explain in this article : Exploit-fork.md

## General insight of the attack
If someone asked me to give a really abstract explaination of what is BROP, i would say this :
This is a 2 or 3 main steps attack :
* Step 1 (if the program uses `SSP` or/and `PIE`) : Stack Canary : Finding the stack canary and the RIP backup
* Step 2 : Finding gadgets with techniques and eventually find a write to our socket primitive : Basically, there is no direct way to leak data as we want to leak the whole binary at the end, so with some techniques and especially a crutial knowledge : Does the program crash when i do this or not we can get 3 required gadgets and the address of write function in PLT, the 3 gadgets are used to pass write argument
* Step 3 : Binary Leak : Once we have found our write and our gadgets so we can call it, we have an arbitrary read of any address, so we send its connect via our socket  

Once we have the binary, we are completely done, now we can exploit as a normal binary that we know
## Exploitation explaination
### Step 1 : Stack Reading
I won't cover the stack reading here (maybe later in the article)
### Step 2 : Finding gadgets and write

So we're looking for a way to control `RDI`, `RSI`, `RDX` and we want to find `write`  

Once we have them we can just :
* RDI : SOCKFD for the socket
* RSI : Buffer to write
* RDX : Length to write
And then call write  

Once we have them we can start leaking the binary  

**Finding Gadgets**  

For Blind ROP there are some gadgets that are used for the attack :

- Stop gadgets : When we jump to them, the program doesn't crash and is in an infinite loop
- Trap gadgets : When we jump to them, the program crashes, for example a null ptr = 0 is a trap gadget because when we jump to it we crash  

Now we want to scan binary for gadgets
We're in a loop and at each iteration we overwrite RIP backup with an address, the address starts at, let's say the program base, which is usually `0x400000` in 64 bits binary, if it has PIE and you do stack reading you can find it, now at each iteration we test the next address, so we increment by 1
We call PROBE the address we're testing  

What i mean by probe is that we are testing an address PROBE and we want to understand its behaviour  

Now imagine the following payload :
```
BUFFER | RBP backup |  RIP backup
...    | 8 bytes    |  PROBE       
```
```
After the RIP backup we add this :  
| TRAP GADGET | TRAP GADGET |
| 8 bytes     | 8 bytes     |
```
Now imagine that the PROBE gadget is a :
```asm
pop <register>
ret
```
It will pop our first TRAP GADGET to the register  
Then it's gonna return the second TRAP GADGET  
Which will cause a crash because we're returning into a trap gadget  

Now imagine instead of our two trap gadgets we have this :
```
| STOP GADGET | STOP GADGET |
| 8 bytes     | 8 bytes     |
```
Imagine it's the same PROBE gadget  
So now it will pop the address of the STOP GADGET into the register  
Then because of the ret it's gonna return to the second STOP gadget  
And now it's not crashing anymore  
Now that the same behaviour is observed if instead of our two stop gadgets we have :
```
| TRAP GADGET | STOP GADGET |
| 8 bytes     | 8 bytes     |
```
In the case it's a :
```
pop <register>
ret
```
So it pops TRAP GADGET address into register  
And ret returns to the STOP GADGET  
And so the program doesn't crash neither  
Now what if we have the same disposition of our payload so :
`buffer THEN RBP backup THEN PROBE THEN TRAP GADGET THEN STOP GADGET`  
What if probe doesn't contain any pop (except then ret which pops rip)  
So for example :
```
xor eax, ebx
ret
```
Or even just :
```
ret
```
Since TRAP GADGET address in not popped before the ret  
It will return to the TRAP GADGET address and... Crash  
We can now identify certain types of gadgets  
**The BROP gadget**  
The BROP gadget is a specific gadget which consists of these instructions :  
```
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
ret
```
This gadget might tell you something if you have ever done some ret2csu  
So this gadget has 6 pops in it  
Usually there are no such gadgets except this one that have 6 pops in it  
Therefore it makes it easier to identify  
But this gadget doesn't contain any `pop rdi`, `pop rsi` or `pop rdx` reference  
BUT we know that this gadget is part of a function called `__libcsu_init` and since we know it's code  
We know that BROP GADGET+7 is :
```
pop rsi
pop r15
ret
```
And that BROP GADGET+9 is :
```
pop rdi
ret
```
So knowing its address, we can find a `pop rsi` and a `pop rdi`  
Also `__libcsu_init` i normally present in any ELF binary  
**Identify gadgets**
* If our program is not crashing with `PROBE + STOP GADGET + TRAP GADGET` Then it's a `ret` or `something not pop ; ret` gadget  
* If our program is not crashing with `PROBE + TRAP GADGET + STOP GADGET + TRAP GADGET` Then it's a `pop <register> ; ret` gadget
* If our program is not crashing with `PROBE + 6 TRAP GADGETS + STOP GADGET + 6 TRAP GADGETS` and is crashing with `13 TRAP GADGETS` (so it will ret into the 7th one) then it's a BROP gadget  

For the BROP gadget, for the `PROBE + 6 TRAP GADGETS + STOP GADGET + 6 TRAP GADGETS`  
It's because it will pop exactly 6 times then ret to our stop gadget so it doesn't crash  
However the STOP Gadget also has this behaviour, it won't crash with the previous payload  
Therefore also check if `13 TRAP GADGETS` makes it crash, because it will pop 6 `TRAP GADGETS` then return into the 7th trap gadget so it crashes  
Now that we have our BROP gadget we know the address of our `pop rdi` and our `pop rsi`  
So you may be asking : What about a `pop rdx` or any way to control it ?  
It's a weird answer but we'll use `strcmp`, why ? Because when we call it with two arguments, it sets `rdx` to the string getting compared, so it gives a non zero value for the `size` and that's what we want  

**Finding PLT base**

Our goal is to find `strcmp` which has to be in PLT  
The procedure linkage table contains multiple entries where we can jump to jump to a libc function via it's address stored in Global Offset Table GOT  
The procedure linkage table PLT contains multiple chained PLT entries  
A PLT entry is 3 instructions :
```asm
jmp [GOT_ADDR]
<instruction 2>
<instruction 3>
```
A PLT entry size is 16 bytes  
So to find the PLT address, so the address of the first PLT entry, we need to know this pattern :  
```
ENTRY 1 (16 bytes)  
ENTRY 2 (16 bytes)
ENTRY 3 (16 bytes)
ENTRY 4 (16 bytes)
```
Now to find it it's simple, we know that each `jmp [GOT ADDR]` should not make the server crash  
Therefore we can test an address, test like :
* We'll see if we crash for the address, if we don't we continue if we do we test the next address
* We'll see if we crash for the `address+1*16` so in the next entry of plt, if it's the plt we will have another jmp to got addr here so it won't crash, if we crash we know it's not PLT and we test next address, if we don't we continue
* Now we simply test like 2 other times (for `address+2*16` and `address+3*16`, if all our tests for our 4 address doesn't make the server crash then we know it's the PLT
And so we know the address of the PLT base  

**Finding strcmp in PLT**  

Now that we know where is the PLT, we can start searching for strcmp  
So it's simple, we iterate like 10 times, for each plt entry (actually we don't know how many plt entries there are)  
Starting from the plt entry 0, which is simply the address of plt, we'll jump 4 times to the `jmp [GOT ADDRESS]` with different parameters, then for the next entry we test `PLT BASE+ITERATION*16`  
As I said, we call the PLT entry 4 times :
* We call it with `arg1=valid ptr;arg2=valid ptr;STOP GADGET;TRAP GADGET`, so it runs with arg1 (RDI) and arg2 (RSI) then returns to STOP GADGET, so if it doesn't crash, then we move to the next test, otherwise we test the next entry
* We call it with `arg1=invalid ptr;arg2=valid ptr;STOP GADGET;TRAP GADGET`, since arg1 is an invalid ptr then if it's strcmp it should crash, if it crashes we move to the next check, otherwise we test the next entry
* We call it with `arg1=valid ptr;arg2=invalid ptr;STOP GADGET;TRAP GADGET`, since arg2 is an invalid ptr then if it's strcmp it should crash, if it crashes we move to the next check, otherwise we test the next entry
* We call it with `arg1=invalid ptr;arg2=invalid ptr;STOP GADGET;TRAP GADGET`, since arg1 and arg2 are invalid ptrs then if it's strcmp it should crash, if it crashes then we know it's `strcmp`, otherwise we test the next entry  

And that's how we can find `strcmp`
