# Exploits
## Stack buffer overflow : Exploit forked programs (bruteforce and ret2plt) in x64 (No canary)
## Required to understand : Return to plt and Stack protections
## Bypasses protections : NX, ASLR and PIE
Is there really a way to bypass Position Independant Executable ? Well, kind of, if the program uses `fork` then definitively  
Before seeing the exploit itself, we have to understand how does PIE really work, let's write the program that will be exploited :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void vuln(){
    char buffer[64];
    printf("Enter a string : ");
    fflush(stdout);
    read(STDIN_FILENO, buffer, 500);
    printf("Ended !\n");
    fflush(stdout);
}

int main()
{
    while(1) {
        if (fork() == 0) {
            vuln();
            printf("Program finished !\n");
            fflush(stdout);
            exit(0);
        } else {
            wait(NULL);
        }
    }
    return 0;
}
```
I will explain how `fork` works later, but first, there's something we've to overcome, let's enable (full) `ASLR` :
```sh
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
Now let's compile the program enabling `NX and PIE` in 64 bits :
```sh
gcc <source code file>.c -o <executable> -fno-stack-protector -z noexecstack -pie -fpie -m64
```
I disabled stack protector but in this condition, it can be bypassed but we'll see that later  
So how does `PIE` works ? Well it's a good question, let's disasseble the program using `objdump` :
```
objdump -d <executable>
```
With `PIE`
```nasm
0000000000001000 <_init>:
    1000:	48 83 ec 08          	sub    $0x8,%rsp
    1004:	48 8b 05 dd 2f 00 00 	mov    0x2fdd(%rip),%rax        # 3fe8 <__gmon_start__>
    100b:	48 85 c0             	test   %rax,%rax
    100e:	74 02                	je     1012 <_init+0x12>
    1010:	ff d0                	callq  *%rax
    1012:	48 83 c4 08          	add    $0x8,%rsp
    1016:	c3                   	retq   
```
Without `PIE` :
```nasm
0000000000401000 <_init>:
  401000:	48 83 ec 08          	sub    $0x8,%rsp
  401004:	48 8b 05 ed 2f 00 00 	mov    0x2fed(%rip),%rax        # 403ff8 <__gmon_start__>
  40100b:	48 85 c0             	test   %rax,%rax
  40100e:	74 02                	je     401012 <_init+0x12>
  401010:	ff d0                	callq  *%rax
  401012:	48 83 c4 08          	add    $0x8,%rsp
  401016:	c3                   	retq   
```
With `PIE` :
```nasm
00000000000010b0 <_start>:
    10b0:	31 ed                	xor    %ebp,%ebp
    10b2:	49 89 d1             	mov    %rdx,%r9
    10b5:	5e                   	pop    %rsi
    10b6:	48 89 e2             	mov    %rsp,%rdx
    10b9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    10bd:	50                   	push   %rax
    10be:	54                   	push   %rsp
    10bf:	4c 8d 05 da 01 00 00 	lea    0x1da(%rip),%r8        # 12a0 <__libc_csu_fini>
    10c6:	48 8d 0d 73 01 00 00 	lea    0x173(%rip),%rcx        # 1240 <__libc_csu_init>
    10cd:	48 8d 3d 1d 01 00 00 	lea    0x11d(%rip),%rdi        # 11f1 <main>
    10d4:	ff 15 06 2f 00 00    	callq  *0x2f06(%rip)        # 3fe0 <__libc_start_main@GLIBC_2.2.5>
    10da:	f4                   	hlt    
    10db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
```
Without `PIE` :
```nasm
00000000004010a0 <_start>:
  4010a0:	31 ed                	xor    %ebp,%ebp
  4010a2:	49 89 d1             	mov    %rdx,%r9
  4010a5:	5e                   	pop    %rsi
  4010a6:	48 89 e2             	mov    %rsp,%rdx
  4010a9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4010ad:	50                   	push   %rax
  4010ae:	54                   	push   %rsp
  4010af:	49 c7 c0 90 12 40 00 	mov    $0x401290,%r8
  4010b6:	48 c7 c1 30 12 40 00 	mov    $0x401230,%rcx
  4010bd:	48 c7 c7 de 11 40 00 	mov    $0x4011de,%rdi
  4010c4:	ff 15 26 2f 00 00    	callq  *0x2f26(%rip)        # 403ff0 <__libc_start_main@GLIBC_2.2.5>
  4010ca:	f4                   	hlt    
  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
```
It's the same structure for each function  
Well, what the did happen to our program ? Are `00000000000010b0` (`_start`) and `0000000000001000` (`_init`) real addresses ? Well, no see them more like offsets, actually what `PIE` will do is that it will apply to these addresses a random address when the program is executed  
So this offset is called the `program base` and it's random at each execution  
So if the program base is for example `0x506f` then the real addresses would be offseted with this address, so the address will be : `0x506f` + `0x10b0` which gives `0x611f` and it will be the `real function address`  
Damn, then how could we execute functions or jump to gadgets or anything that refers to the code (`.text`) segment if it's address is random ? (Well, not fully random but you got it)  
Well do you remember when i was talking about `fork` ? It's gonna help us a lot against this mitigation, because fork7 is a function that will copy the entire memory of the process including all segments, it will actually clone the image of the process into a sub process  
What does it means ? Well all memory is copied, including this program base, so in this case it runs the program in an infinite loop so at each iteration of the loop, the sub-process will have **the same** program base, and then we can process some brute force stuff  
You're probably asking yourself about what we're gonna brute force ? I talk about the instruction pointer which will be the same at each fork, but how can we brute force the instruction pointer and how can that be useful ?  
It's actualy really simple, let's have a reprentation of the stack at this moment :
**Stack** :
```
---------------------------------------
EIP backup | 8 bytes => 0x 55 65 5c 3e 12 2a 1f 08 
EBP backup | 8 bytes
buffer     | 64 bytes
---------------------------------------
```
Now let's see a case where there's a buffer overflow, where we will overwrite full `EBP` backup but only the first byte of `EIP` so the payload will look like this :
```
|A*64       |B*8           |C*1           |
|buffer (64)|ebp backup (8)|eip backup (8)|
```
The stack will now look like this :
```
---------------------------------------
EIP backup | 8 bytes => 0x 55 65 5c 3e 12 2a 1f 43 ('C')
EBP backup | 8 bytes => B*8
buffer     | 64 bytes => A*8
---------------------------------------
```
We overwrote the last byte of `EIP` (not the first one because of little-endian that why we have to reverse our bytes)  
Now, unless the address `0x 55 65 5c 3e 12 2a 1f 43` exist, the program will crash and will give a segmentation fault, but what if we try each value from `0` to `ff` (`255`) ?  
Well since it's one byte, at a moment, unless it's something else that caused the crash, it will be correct byte (that was in the original address that hasn't been overwrote)  
So in this case it's `08`, then since it's not crashing, we know that the byte that we've tested is correct, now that we have this first byte we can move into the second one keeping all the bytes before and again and so forth  
So let's try to find the second byte, keeping the first byte before, so the payload will look like this :
```
|A*64       |B*8           |0x08 + (?)    |
|buffer (64)|ebp backup (8)|eip backup (8)|
```
Since `?` is the unknown byte that we have to brute force, so when it arrives to `1f` (`31`), it will not crash and then we know that it's the good byte and we can move the next until the end of the address  
So the final (`8th`) payload will be :
```
|A*64       |B*8           |0x08 1f 2a 12 3e 5c 65 55|
|buffer (64)|ebp backup (8)|eip backup (8)           |
```
And `0x55655c3e122a1f08 ` is the address of `RIP`  
Awesome ! But now how can we find the program base from `RIP`, well we will have to do a calculation : `base address = RIP - (RIP & 0xfff) - _init functon address`  
So we substract `RIP` `RIP` bitwise and with `0xfff` then we substract from it the `_init` function address, i'm talking about it's offset, it's generally `0x1000` but we can check using either gdb or objdump :  
```
gdb <executable>
x _init
```
For me it was indeed `0x1000`  
So now with this calculation we have the program base address and we can then find the address of any function in `.text` simply by getting it's offset (for example `0x10b0`) + the program base address  
So we've defeated `PIE` using a byte per byte brute force, yes it's similar to the brute force when you're doing a blind SQL injection with the true / false operator but it's not really the same  
