# Exploits
## Blind Stack Buffer Overflow - Via data leakage (not format strings)
This is an example of what you can do with information leakage while exploiting a stack buffer overflow

This is not Blind Return Oriented Programming but this is an example of how you can exploit a Blind Stack Buffer Overflow  
A Blind Exploit happens when the attacker doesn't have any information neither about the binary he's exploiting nor its source code  
It's usually happening through sockets, so in an online connection  
So here's the source code of the target : https://github.com/TheCrazzXz/Exploits-Lab/tree/main/App-sys/windows_based/Blind%20Stack%20Buffer%20Overflow%20-%20Via%20Leakage  
`main.c` :
```c
#include <stdio.h>
#include <stdlib.h>
#include "SocketServer.h"

#pragma comment(lib,"ws2_32.lib") //Winsock Library

unsigned long recv_size;

void client_function()
{
	char buffer[1024];
	memset(buffer, 0, 1024); // Zero memory the bufer
	if (recv_size = recv(new_socket, buffer, 1200, 0) == SOCKET_ERROR)
	{
		puts("Recv failed");
		exit(1);
	}
	if(send(new_socket, buffer, strlen(buffer), 0) < 0)
	{
		puts("Send failed");
		exit(1);
	}
}

int main(void)
{
	initializeListeningServer(7777);
	
	while(1)
	{
		acceptConnection();
		
		client_function();

		closesocket(new_socket);
	}

	Disconnect();
}
```
`SocketServer.h` :
```c
#include <io.h>
#include <stdio.h>
#include <winsock2.h>

#pragma once

#ifndef __SOCKET_SERVER__
#define __SOCKET_SERVER__

WSADATA wsa;
SOCKET s , new_socket;
struct sockaddr_in server , client;
int c;

int initializeListeningServer(int port)
{	
	printf("\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2,2),&wsa) != 0)
	{
		printf("Failed. Error Code : %d",WSAGetLastError());
		exit(1);
	}
	
	printf("Initialised.\n");
	
	//Create a socket
	if((s = socket(AF_INET , SOCK_STREAM , 0 )) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d" , WSAGetLastError());
		exit(1);
	}

	printf("Socket created.\n");
	
	//Prepare the sockaddr_in structure
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons( port );
	
	//Bind
	if( bind(s ,(struct sockaddr *)&server , sizeof(server)) == SOCKET_ERROR)
	{
		printf("Bind failed with error code : %d" , WSAGetLastError());
		exit(1);
	}
	
	puts("Bind done");

	//Listen to incoming connections
	listen(s , 3);
	
	//Accept and incoming connection
	puts("Waiting for incoming connections...");
	
}
void acceptConnection()
{
	c = sizeof(struct sockaddr_in);
	new_socket = accept(s , (struct sockaddr *)&client, &c);
	if (new_socket == INVALID_SOCKET)
	{
		printf("accept failed with error code : %d" , WSAGetLastError());
		exit(1);
	}
	
	puts("Connection accepted");
}
void Disconnect()
{
	printf("Disconnecting...\n");
	closesocket(new_socket);
	closesocket(s);
	WSACleanup();
	printf("Disconnected\n");
}

#endif
```
As you can see this uses windows functions so i compiled it in windows, but the attack is pretty much the same in Linux if you know about stack buffer overflows  
As you can see there's this call to `initializeListeningServer(7777)` which will simply `initialize` a `Listening` `Server` on port `7777` !  
Then there's a loop which accepts a client and then calls `client_function` and then it closes the socket, it can accept multiple clients, once its done with one, another one can connect, then another one...  
I compiled it with :
```
gcc <source file>.c -o <executable> -lws2_32
(you can also add -fno-stack-protector)
``` 
If you compile a linux version on Linux, make sure to disable to stack protector, NX and ASLR :
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
gcc <source file.c> -o <executable> -fno-stack-protector -z execstack
```
Now we start it and we have our program listening on port 7777 but it could be listening on any port  
So we can use netcat to connect to it :
```
nc <server address> <port (example : 7777)>
```
Netcat is a simple program that redirects stdin to a socket, which is in this case the one we use to connect to the server  
Let's enter `I hate fµKers` for example :
It responds with :
```
I hate fµKers
```
So basically it sends the string we entred  
Now you know what's happening here, there's a stack buffer overflow !  
If we enter more than 1024 we overflow the buffer and so we can overwrite data after the buffer on te stack !  
If you take a look at `client_function` you can read the following :
```c
void client_function()
{
	char buffer[1024];
	memset(buffer, 0, 1024); // Zero memory the bufer
	if (recv_size = recv(new_socket, buffer, 1200, 0) == SOCKET_ERROR)
	{
		puts("Recv failed");
		exit(1);
	}
	if(send(new_socket, buffer, strlen(buffer), 0) < 0)
	{
		puts("Send failed");
		exit(1);
	}
}
```
So we allocate a buffer of 1024 bytes on the stack  
Then we set all these 1024 bytes to 0  
Then we receive data, until 1200 bytes, exceeding the size of the buffer, so here is our overflow  
Then we send back the data, and we send `strlen(buffer)` bytes  
`strlen` is a function in GLIBC which takes a pointer and simply increments the address at each iteration, and if at a certain address there's a NULL-Byte (0) then the function returns the number of iterations it took before the NULL-Byte (0), and it can be used to find the length of a string because a string in C is NULL-Terminated, so it's followed by a NULL-Byte after the characters  
For example : Let's say we have a buffer of 62 characters, let's say we do an strcpy :
```c
strcpy(buffer, "Hello");
```
What you have to know is that when you type a string in c with "<string>" is that it allocates it on the buffer it's asigned to (in this case .data then it's copied to the buffer with the strcpy) and the buffer size is the length of the characters + 1 so + 1 to put a NULL Byte Terminator at the end, to terminate the string  
So here is the "Hello" which is allocated in .data in memory :
```
'H', 'e', 'l', 'l', 'o', 0x00 (Null terminator)
```
When we recv, our buffer is 1024 characters, and since our buffer is full of 0's (NULL bytes), when we receive to the buffer, the data we receive doesn't necessarly have to have to a null byte to it, because the buffer is already full of null bytes, so if we receive "I hate fµKers"` we get :
Before recv :
```
Buffer : 0x00, 0x00, 0x00, 0x00 ... (1024)
```
After recv :
```
Buffer : 'I', ' ', 'h', 'a', 't', 'e', ' ', 'f', 'µ', 'K', 'e', 'r', 's', 0x00, 0x00, 0x00, 0x00 (null bytes until the end)
```
That's why it's null terminated  
Then we we send, it sends all data before the null byte because of the strlen, so it sends exactly :
```
'I', ' ', 'h', 'a', 't', 'e', ' ', 'f', 'µ', 'K', 'e', 'r', 's'
```
So `strlen` returned all data size before the first null byte in the buffer  

Now there's a stack buffer overflow  
