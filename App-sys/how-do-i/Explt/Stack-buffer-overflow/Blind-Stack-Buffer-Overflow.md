# Exploits
## Blind Stack Buffer Overflow - Via data leakage (not format strings)
This is an example of what you can do with information leakage while exploiting a stack buffer overflow

This is not Blind Return Oriented Programming but this is an example of how you can exploit a Blind Stack Buffer Overflow  
A Blind Exploit happens when the attacker doesn't have any information neither about the binary he's exploiting nor its source code  
It's usually happening through sockets, so in an online connection  
So here's the source code of the target : https://github.com/TheCrazzXz/Exploits-Lab/tree/main/App-sys/windows_based/Blind%20Stack%20Buffer%20Overflow%20-%20Via%20Leakage  
`main.c` :
```c
#include <stdio.h>
#include <stdlib.h>
#include "SocketServer.h"

#pragma comment(lib,"ws2_32.lib") //Winsock Library

unsigned long recv_size;

void client_function()
{
	char buffer[1024];
	memset(buffer, 0, 1024); // Zero memory the bufer
	if (recv_size = recv(new_socket, buffer, 1200, 0) == SOCKET_ERROR)
	{
		puts("Recv failed");
		exit(1);
	}
	if(send(new_socket, buffer, strlen(buffer), 0) < 0)
	{
		puts("Send failed");
		exit(1);
	}
}

int main(void)
{
	initializeListeningServer(7777);
	
	while(1)
	{
		acceptConnection();
		
		client_function();

		closesocket(new_socket);
	}

	Disconnect();
}
```
`SocketServer.h` :
```c
#include <io.h>
#include <stdio.h>
#include <winsock2.h>

#pragma once

#ifndef __SOCKET_SERVER__
#define __SOCKET_SERVER__

WSADATA wsa;
SOCKET s , new_socket;
struct sockaddr_in server , client;
int c;

int initializeListeningServer(int port)
{	
	printf("\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2,2),&wsa) != 0)
	{
		printf("Failed. Error Code : %d",WSAGetLastError());
		exit(1);
	}
	
	printf("Initialised.\n");
	
	//Create a socket
	if((s = socket(AF_INET , SOCK_STREAM , 0 )) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d" , WSAGetLastError());
		exit(1);
	}

	printf("Socket created.\n");
	
	//Prepare the sockaddr_in structure
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons( port );
	
	//Bind
	if( bind(s ,(struct sockaddr *)&server , sizeof(server)) == SOCKET_ERROR)
	{
		printf("Bind failed with error code : %d" , WSAGetLastError());
		exit(1);
	}
	
	puts("Bind done");

	//Listen to incoming connections
	listen(s , 3);
	
	//Accept and incoming connection
	puts("Waiting for incoming connections...");
	
}
void acceptConnection()
{
	c = sizeof(struct sockaddr_in);
	new_socket = accept(s , (struct sockaddr *)&client, &c);
	if (new_socket == INVALID_SOCKET)
	{
		printf("accept failed with error code : %d" , WSAGetLastError());
		exit(1);
	}
	
	puts("Connection accepted");
}
void Disconnect()
{
	printf("Disconnecting...\n");
	closesocket(new_socket);
	closesocket(s);
	WSACleanup();
	printf("Disconnected\n");
}

#endif
```
