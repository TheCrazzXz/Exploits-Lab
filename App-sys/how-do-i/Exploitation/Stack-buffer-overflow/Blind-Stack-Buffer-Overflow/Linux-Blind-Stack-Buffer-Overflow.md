# Exploitation
## Blind stack buffer in Linux (x86 = 32 bits)

### Insight
In this article, we're gonna see an example about how can we exploit a server-program (written in C) without having any information about it  
We can't access it's memory in debug using GDB because it's a remote program, but we assume we know the source code  
In this example, we can still leak data (no format strings) using a trick with `printf` and `strlen` and that's how we can still exploit it  
During exploitation, and to use it in general, we will connect to it via sockets (because it's a server) so we can send and receive data from it  
Our goal is to execute a shellcode on it, but not a normal shellcode like an `x86 /bin/sh execve shellcode`, it could work, the shellcode could be executed but remember it's a server and so this shellcode will be executed on the machine, on its STDIN and STDOUT streams, and we can't access them because we can only send/receive data from sockets  
What we're gonna use is a reverse shell shellcode, but before executing it on it we will have to bind the server that we're gonna use to communicate with this shell using netcat (`apt install netcat`) or any other thing (we can bind the server on python) but we just want a server that can send and receive data  
This is a link to someone who is named rastating who wrote a shellcode to do so : https://rastating.github.io/creating-a-reverse-tcp-shellcode/  
So we can just use it !  

## Target Server-Program
Here is the target server-program to exploit :
`main.c` :
```c
#include <netinet/in.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#define PORT 8080

int server_fd, new_socket, valread;
struct sockaddr_in address;
int opt = 1;
int addrlen = sizeof(address);

void handle_client()
{
    char buffer[1024];
    memset(buffer, 0, 1024); // Zero memory the bufer

    valread = read(new_socket, buffer, 2048);
    send(new_socket, buffer, strlen(buffer), 0);
    printf("strlen(buffer) : %d\n", strlen(buffer));
    printf("Sent message\n");
}

int main(int argc, char const* argv[])
{
    //printf("new_socket : %p\n", &new_socket);


    // Creating socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }
  
    // Forcefully attaching socket to the port 8080
    if (setsockopt(server_fd, SOL_SOCKET,
                   SO_REUSEADDR | SO_REUSEPORT, &opt,
                   sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
  
    // Forcefully attaching socket to the port 8080
    if (bind(server_fd, (struct sockaddr*)&address,
             sizeof(address))
        < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
    while(1)
    {  
        if (listen(server_fd, 3) < 0) {
            perror("listen");
            exit(EXIT_FAILURE);
        }
        if ((new_socket
             = accept(server_fd, (struct sockaddr*)&address,
                      (socklen_t*)&addrlen))
            < 0) {
            perror("accept");
            exit(EXIT_FAILURE);
        }

        handle_client();
        
      
        // closing the connected socket
        close(new_socket);    
    }
    // closing the listening socket
    shutdown(server_fd, SHUT_RDWR);
}
```
Here, as you can notice it's pretty easy, it's creating a socket and then it binds this socket to localhost, then in an infinite loop, it listens for new connections and accepts them, for each connection it calls this function, `handle_client()` where it first declares a 1024 bytes buffer, then it zero memory it (i will explain this)
