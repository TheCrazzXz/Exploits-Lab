# Exploits : Malloc size overflow
Notice : This vulnerability is not HEAP related
## Insight
Do you know what happens when we enter a huge size for malloc ?  
```c
char* ptr = malloc(999999999999999999999999);
```
Then `malloc` will return a `NULL` = `0` pointer  
Now imagine we use this pointer after the malloc  
We're agreed to say that if we dereference it it will crash as NULL is an invalid address  
But since the pointer is `0`  
If we do :  
```c
ptr[idx];
```
We access `ptr+idx` (if it's a char ptr)  
Therefore `idx` could be a real address and it will simply access it because it will add 0 to it  
```c
char variable = 60;
printf("variable at %p\n", &variable);
```
Now for exemple let's say that the address of this variable is like :
```
variable at 0x5577b48b58
```
Then if we do :
```c
ptr[0x5577b48b58]
```
We actually access this variable as it will access `ptr+0x5577b48b58`=`0+0x5577b48b58`=`0x5577b48b58`    
Notice that if the pointer is of a type `x` then you'll have to access `ptr[<address>/sizeof(x)]`   
So for example `sizeof(unsigned long)` in 64 bites is 8 bytes
