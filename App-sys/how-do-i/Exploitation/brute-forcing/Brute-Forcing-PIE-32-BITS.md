# Exploitation
## Brute forcing PIE In 32 bits
### Insight
For now everything we did was quite good, but most of the time every ROP we performed and else except partial address overwrite was based on the fact that PIE is always enabled.  
Let me tell you right now, in modern systems, PIE is almost omnipresent, and we have to find a way to go against it.  
We've already covered Partial Address Overwrite, and it works, but it has huge limitations :
- First if we're doing it from a buffer overflow which is coming from libc functions like `gets`, `scanf`, `strcpy` it may not work, unless there's a null byte after the bytes we overwrite in memory, because this functions would set null byte to the byte after our input.  
- Also, this works when we're doing a single address overwrite, but what if we're doing a Return Oriented Programming, we'll have to do this for every gadget, but the offset between these gadgets might be huge, so doing partial address overwrite won't work.  

We also saw a particular exploit when fork is used in a loop, and it works great, it can also defeat Stack Smashing Protection, but again, it is really a special case, not every program uses fork.  

So for this whole article, we'll be exploiting a 32 bits program, and in this article we won't see a magical technique on how to bypass PIE because the two techniques aforementionned are the only ones i know. But in the other hand, we'll take a look at what it takes to brute-force PIE randomness, what we'll apply in this article is extremely reasonnable, the brute force should be really quick and should take at most like 1 minute or really less, after like 16000 executions of the program, we should guess the correct thing at least one time.  

So, how do you really do ? Well first know that it's in 32 bits, it's not that it won't work in 64 bits but it's hugely easier in 32 bits, since there's less nibbles (4 bits) we'll have to guess.  

First let's see how **EXACTLY** PIE works, but let's first see in an abstract way.  
### PIE (abstract)
PIE, for Position Independant Executable, or somethimes called PIC, for Position Independant Code, is a protection that will, in addition to ASLR, will randomize code addresses.  
Oh sorry, did i say "randomize code addresses ?", well it's not completely false, but it's not exactly that, but first let's take a look at how your program is loaded when it's executed :  
(in gdb : break main; run; info proc mappings)  
```
Mapped address spaces:

        Start Addr   End Addr       Size     Offset  Perms   objfile
        0x56555000 0x56556000     0x1000        0x0  r--p   .../prog
        0x56556000 0x56557000     0x1000     0x1000  r-xp   .../prog
        0x56557000 0x56558000     0x1000     0x2000  r--p   .../prog
        0x56558000 0x56559000     0x1000     0x2000  r--p   .../prog
        0x56559000 0x5655a000     0x1000     0x3000  rw-p   .../prog
        0xf7d70000 0xf7d90000    0x20000        0x0  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7d90000 0xf7f12000   0x182000    0x20000  r-xp   /usr/lib/i386-linux-gnu/libc.so.6
        ...
```
These are some sections of the program `prog`, if you execute this command on gdb you'll find a lot more below, but in the process virtual memory (at least on linux and probably windows) the program is always the first loaded address, i mean that it always has the lowest address, when i say the program, i mean sections like `.text`, `.got`, `.plt`, `.data` and `.bss` but other segments like the heap and the stack are not completely part of the program since the loaded libc can use these segments, they're not really part of binary (ELF) itself, but part of the loaded process virtual memory, and they're loaded at higher addresses with no visible link with the loaded program address, for example, here the stack was loaded at `0xfffdd000` which doesn't look like it has anything to do with `0x56555000`, the offset between the binary (ELF) segments(here from 0x56555000 to 0x5655a000) and the stack (at 0xfffdd000) is not always constant, mostly with ASLR, you see, the program itself is randomized with PIE and the stack and heap are randomized with ASLR, that's why we could always do a ROP with ASLR enabled but with PIE disabled.  

So let's concentrate with PIE, how does it work ? Well the very first address you see (`0x56555000`), is called the program base and defines where the program is loaded and this will change with PIE, and every address of the binary after it will follow it so for example, do you see the address 0x56556000, it's actually the PROGRAM BASE + offset, which is 0x1000 here, so 0x56555000 + 0x1000 which is indeeed 0x56556000, and if the program base was like 0xdeadbeef, then this address would be 0xdeadbeef + offset = 0xdeadbeef + 0x1000 = 0xdeadceef.  
So basically, every address part of the ELF (executable linux file) is : `PRGRAM BASE + offset` the only difference between PIE and NO PIE is that in PIE the PROGRAM BASE changes at each execution and in NO PIE it's always constant.  
Exit gdb and run it again with the program.  
In gdb do : `set disable-randomization off` to enable ASLR or/and PIE if they should be enabled without gdb
Let's say we have PIE enabled for this program, let's run x main to see where main would be loaded in it :  
```
(gdb) x main
```
```
0x1200 <main>:  0x04244c8d
```
I know what you think, this is not the address of main, but a philosophical question now, what do you exactly mean by the address of main ? It would have been the case if the address of main would always be the same at every execution, but that's just not the case since PIE is enabled. So what you see here is the offset, from the start of the program, which might be different for each function of the program, the offset to the program base when the program base is loaded is always the same but the program base is always dfferent, so the address of each function is always different from execution to execution.
If we launch the program with `(gdb) run` :
the real address of main is : `(gdb x main` : `0x565bd200`  
And if we do `info proc mappings` :
```
Mapped address spaces:

        Start Addr   End Addr       Size     Offset  Perms   objfile
        0x565bc000 0x565bd000     0x1000        0x0  r--p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565bd000 0x565be000     0x1000     0x1000  r-xp   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565be000 0x565bf000     0x1000     0x2000  r--p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565bf000 0x565c0000     0x1000     0x2000  r--p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565c0000 0x565c1000     0x1000     0x3000  rw-p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x566ce000 0x566f0000    0x22000        0x0  rw-p   [heap]
        0xf7ce2000 0xf7d02000    0x20000        0x0  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7d02000 0xf7e84000   0x182000    0x20000  r-xp   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7e84000 0xf7f09000    0x85000   0x1a2000  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7f09000 0xf7f0a000     0x1000   0x227000  ---p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7f0a000 0xf7f0c000     0x2000   0x227000  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7f0c000 0xf7f0d000     0x1000   0x229000  rw-p   /usr/lib/i386-linux-gnu/libc.so.6
```
The program is loaded at `0x565bc000` and if we do : `0x565bc000` (program base) + `0x1200` (main offset), we get `0x565bd200`, which is indeed the address of main
