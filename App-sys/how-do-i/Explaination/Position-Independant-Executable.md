# Explaintation
## Position Independant Executable
### PIE (abstract)
PIE, for Position Independant Executable, or somethimes called PIC, for Position Independant Code, is a protection that will, in addition to ASLR, will randomize code addresses.  
Oh sorry, did i say "randomize code addresses ?", well it's not completely false, but it's not exactly that, but first let's take a look at how your program is loaded when it's executed :  
(in gdb : break main; run; info proc mappings)  
```
Mapped address spaces:

        Start Addr   End Addr       Size     Offset  Perms   objfile
        0x56555000 0x56556000     0x1000        0x0  r--p   .../prog
        0x56556000 0x56557000     0x1000     0x1000  r-xp   .../prog
        0x56557000 0x56558000     0x1000     0x2000  r--p   .../prog
        0x56558000 0x56559000     0x1000     0x2000  r--p   .../prog
        0x56559000 0x5655a000     0x1000     0x3000  rw-p   .../prog
        0xf7d70000 0xf7d90000    0x20000        0x0  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7d90000 0xf7f12000   0x182000    0x20000  r-xp   /usr/lib/i386-linux-gnu/libc.so.6
        ...
```
These are some sections of the program `prog`, if you execute this command on gdb you'll find a lot more below, but in the process virtual memory (at least on linux and probably windows) the program is always the first loaded address, i mean that it always has the lowest address, when i say the program, i mean sections like `.text`, `.got`, `.plt`, `.data` and `.bss` but other segments like the heap and the stack are not completely part of the program since the loaded libc can use these segments, they're not really part of binary (ELF) itself, but part of the loaded process virtual memory, and they're loaded at higher addresses with no visible link with the loaded program address, for example, here the stack was loaded at `0xfffdd000` which doesn't look like it has anything to do with `0x56555000`, the offset between the binary (ELF) segments(here from 0x56555000 to 0x5655a000) and the stack (at 0xfffdd000) is not always constant, mostly with ASLR, you see, the program itself is randomized with PIE and the stack and heap are randomized with ASLR, that's why we could always do a ROP with ASLR enabled but with PIE disabled.  

So let's concentrate with PIE, how does it work ? Well the very first address you see (`0x56555000`), is called the program base and defines where the program is loaded and this will change with PIE, and every address of the binary after it will follow it so for example, do you see the address 0x56556000, it's actually the PROGRAM BASE + offset, which is 0x1000 here, so 0x56555000 + 0x1000 which is indeeed 0x56556000, and if the program base was like 0xdeadbeef, then this address would be 0xdeadbeef + offset = 0xdeadbeef + 0x1000 = 0xdeadceef.  
So basically, every address part of the ELF (executable linux file) is : `PRGRAM BASE + offset` the only difference between PIE and NO PIE is that in PIE the PROGRAM BASE changes at each execution and in NO PIE it's always constant.  
Exit gdb and run it again with the program.  
In gdb do : `set disable-randomization off` to enable ASLR or/and PIE if they should be enabled without gdb
Let's say we have PIE enabled for this program, let's run x main to see where main would be loaded in it :  
```
(gdb) x main
```
```
0x1200 <main>:  0x04244c8d
```
I know what you think, this is not the address of main, but a philosophical question now, what do you exactly mean by the address of main ? It would have been the case if the address of main would always be the same at every execution, but that's just not the case since PIE is enabled. So what you see here is the offset, from the start of the program, which might be different for each function of the program, the offset to the program base when the program base is loaded is always the same but the program base is always dfferent, so the address of each function is always different from execution to execution.
If we launch the program with `(gdb) run` :
the real address of main is : `(gdb x main` : `0x565bd200`  
And if we do `info proc mappings` :
```
Mapped address spaces:

        Start Addr   End Addr       Size     Offset  Perms   objfile
        0x565bc000 0x565bd000     0x1000        0x0  r--p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565bd000 0x565be000     0x1000     0x1000  r-xp   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565be000 0x565bf000     0x1000     0x2000  r--p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565bf000 0x565c0000     0x1000     0x2000  r--p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x565c0000 0x565c1000     0x1000     0x3000  rw-p   /home/user/Lab/buffer-overflow/32_bit_brute_force_aslr/prog
        0x566ce000 0x566f0000    0x22000        0x0  rw-p   [heap]
        0xf7ce2000 0xf7d02000    0x20000        0x0  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7d02000 0xf7e84000   0x182000    0x20000  r-xp   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7e84000 0xf7f09000    0x85000   0x1a2000  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7f09000 0xf7f0a000     0x1000   0x227000  ---p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7f0a000 0xf7f0c000     0x2000   0x227000  r--p   /usr/lib/i386-linux-gnu/libc.so.6
        0xf7f0c000 0xf7f0d000     0x1000   0x229000  rw-p   /usr/lib/i386-linux-gnu/libc.so.6
```
The program is loaded at `0x565bc000` and if we do : `0x565bc000` (program base) + `0x1200` (main offset), we get `0x565bd200`, which is indeed the address of main
### Program base in 32 BITS
The program base is not fully random as well ! Only three nibbles differ (a nibble is from 0 to 15 (4 bits)), so only 12 bits differ, and 2**12 = 4096, so bascially what is randomly generated is from 0 to 4095.  
In 32 bits, the program base is this pattern : 0x56XXX000
The `0x56` at the beggining may differ in different systems but you can adapt this just by testing, seeing what it is for your system  
So the `XXX` here are random nibble at each execution and since a nibble is 4 bits, the number of combines for 4 bits is 16 (from 0 to 15) the the number of combines we can get for it is 16**3 = 4096  
And the algorithm for generation is this one :
```c
/* the function randint(min, max) will generate a random 16 bits integer between min and max*/
uint16_t three_random_nibbles = randint(0, 4095); // minus one for the 
program_base = 0x56000000 | (three_random_nibbles << (3 * 4)); 
```
The : `(three_random_nibbles << (3 * 4)` will shift our XXX's from 0xXXX three nibbles to the left (=3 * 4 = 12 bits to the left) : So they would become : `0xXXX000` then the bitwise OR (`|`) will basically copy these XXX's nibble's to [0x56 HERE->000<-HERE 000] because OR will combine bits, if we OR a null byte with another byte, then results only this byte (fun fact : that's why when you're doing an adddition in binary, you use the OR operation)   
So these three nibbles are the only things that differ at each execution, at least in 32 bits

### Program base in 64 BITS
It's exactly the same process as in 64 bits but there are more nibbles, there are 7 nibbles, so the number of possible comines is way more : 16**7 = 268 435 456, that's hundred of millions compared to 4096 !  
So the program base follows this pattern : 0x55XXXXXXX000`, the 0x55 might differ in other systems, you could just grab it if you want to get it.  
The algorithm is the same but with 7 nibbles :
```c
/* the function randint(min, max) will generate a random 64 bits integer between min and max*/
uint64_t seven_random_nibbles = randint(0, 268435456 - 1); // minus one for the 0
program_base = 0x550000000000 | (seven_random_nibbles << (7 * 4)); 
```
So it will copy these nibbles : `[0x55 HERE->0000000<-HERE 000]`

### Bonus : randint macro-function :
```c
#define randint(min, max) (((rand() % (max + 1 - min)) + min))
/* don't forget to do srand(time(NULL)) at the start of the program to use a random seed */
```

### ASLR (abstract)
Same kind of process happens for ASLR

### End
Thanks for reading
