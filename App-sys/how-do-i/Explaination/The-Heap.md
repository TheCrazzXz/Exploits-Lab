
In this article i won't explain what is the heap, but i'll give some resources so then you can understand
# Resources
Chunks and frees (ESSENTIAL) :
Liveoverflow :
https://www.youtube.com/watch?v=HPDBOhiKaD8  
https://www.youtube.com/watch?v=TfJrU95q1J4
# Fast bins
Source  : https://guyinatuxedo.github.io/25-heap/index.html (i want to go deeper in details)
## Binning
So when malloc frees a chunk,  
it will typically insert it into one of the **bin lists** (assuming it can't do something like consolidate it with the top chunk).   
then with a later allocation, it will check the **bins** to see if there are any **freed chunks** that it could allocate to serve the request.  
The purpose of this is so it can **reuse** previous **freed chunks**, for performance improvements.  
**Taken From Nightmare website**

Now from these bins, there are many types of them, depending on the size of the freed data  
First there are **fast bins**, a fast bin is a **linked list**  
But what is a linked list ?  
A linked list is a list where every element points to the next one until the end of the list (the last one points to 0, it significates that it's the end of the list)  
So here, there are 7 fastbins, so 7 linked list, but why 7 ? First they are referenced by their index, so the first one is index 0, seond is index 1 and the 7th one is index 6  
So still, why seven ? Well that's because each one is made for a certain range of size for a chunk :
Fastbins[idx=0, size=0x10]
Fastbins[idx=1, size=0x20]
Fastbins[idx=2, size=0x30]
Fastbins[idx=3, size=0x40]
Fastbins[idx=4, size=0x50]
Fastbins[idx=5, size=0x60]
Fastbins[idx=6, size=0x70]
A chunk of size `0x20-0x2f` would fit into idx 0,
a chunk of size `0x30-0x3f` would fit into idx 1, **Taken From Nightmare website**
a chunk of size `0x40-0x4f` would fit into idx 2 and so forth...
For example, if we free a chunk of size '0x39' it will be added to the index 1, since it's size is between `0x30-0x3f`  
Now how does the link works exactly ?  
Let's make a C program to see that :
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
    char* ptr1 = malloc(0x20); 
    char* ptr2 = malloc(0x20); 
    char* ptr3 = malloc(0x20); 

    printf("ptr1 -> 0x%x\n", ptr1);
    printf("ptr2 -> 0x%x\n", ptr2);
    printf("ptr3 -> 0x%x\n", ptr3);

    memset(ptr1, 'A', 0x20);
    memset(ptr2, 'B', 0x20);
    memset(ptr3, 'C', 0x20);

    printf("Freeing pointers\n");
    free(ptr3); // Linked list idx 1 => 0x20-0x2f
    free(ptr2); // Linked list idx 1 => 0x20-0x2f
    free(ptr1); // Linked list idx 1 => 0x20-0x2f
    // We realloc 3 new pointers
    char* ptr4 = malloc(0x20);
    char* ptr5 = malloc(0x20);
    char* ptr6 = malloc(0x20);
    
    printf("ptr4 -> 0x%x\n", ptr4);
    printf("ptr5 -> 0x%x\n", ptr5);
    printf("ptr6 -> 0x%x\n", ptr6);
}
```
ASLR disabled, it's in 64 bits

Now let's run this :  
```
└─# ./prog
ptr1 -> 0x4052a0
ptr2 -> 0x4052d0
ptr3 -> 0x405300
Freeing pointers
ptr4 -> 0x4052a0
ptr5 -> 0x4052d0
ptr6 -> 0x405300
```

As you can see the 3 new pointers are allocated in the same space ! Remember here we're not trying to exploit anything we're just trying to understand (important)  
So this can be used in a use-after-free attack but it's not the point here at all  
So let's open this bad boy in gdb :  
```
gdb ./<executable>
disass main
```
```
Dump of assembler code for function main:
   0x0000000000401162 <+0>:	push   rbp
   0x0000000000401163 <+1>:	mov    rbp,rsp
   0x0000000000401166 <+4>:	sub    rsp,0x30
   0x000000000040116a <+8>:	mov    edi,0x20
   0x000000000040116f <+13>:	call   0x401070 <malloc@plt>
   0x0000000000401174 <+18>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401178 <+22>:	mov    edi,0x20
   0x000000000040117d <+27>:	call   0x401070 <malloc@plt>
   0x0000000000401182 <+32>:	mov    QWORD PTR [rbp-0x10],rax
   0x0000000000401186 <+36>:	mov    edi,0x20
   0x000000000040118b <+41>:	call   0x401070 <malloc@plt>
   0x0000000000401190 <+46>:	mov    QWORD PTR [rbp-0x18],rax
   0x0000000000401194 <+50>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000401198 <+54>:	mov    rsi,rax
   0x000000000040119b <+57>:	lea    rdi,[rip+0xe62]        # 0x402004
   0x00000000004011a2 <+64>:	mov    eax,0x0
   0x00000000004011a7 <+69>:	call   0x401050 <printf@plt>
   0x00000000004011ac <+74>:	mov    rax,QWORD PTR [rbp-0x10]
   0x00000000004011b0 <+78>:	mov    rsi,rax
   0x00000000004011b3 <+81>:	lea    rdi,[rip+0xe58]        # 0x402012
   0x00000000004011ba <+88>:	mov    eax,0x0
   0x00000000004011bf <+93>:	call   0x401050 <printf@plt>
   0x00000000004011c4 <+98>:	mov    rax,QWORD PTR [rbp-0x18]
   0x00000000004011c8 <+102>:	mov    rsi,rax
   0x00000000004011cb <+105>:	lea    rdi,[rip+0xe4e]        # 0x402020
   0x00000000004011d2 <+112>:	mov    eax,0x0
   0x00000000004011d7 <+117>:	call   0x401050 <printf@plt>
   0x00000000004011dc <+122>:	mov    rax,QWORD PTR [rbp-0x8]
   0x00000000004011e0 <+126>:	mov    edx,0x20
   0x00000000004011e5 <+131>:	mov    esi,0x41
   0x00000000004011ea <+136>:	mov    rdi,rax
   0x00000000004011ed <+139>:	call   0x401060 <memset@plt>
   0x00000000004011f2 <+144>:	mov    rax,QWORD PTR [rbp-0x10]
   0x00000000004011f6 <+148>:	mov    edx,0x20
   0x00000000004011fb <+153>:	mov    esi,0x42
   0x0000000000401200 <+158>:	mov    rdi,rax
   0x0000000000401203 <+161>:	call   0x401060 <memset@plt>
   0x0000000000401208 <+166>:	mov    rax,QWORD PTR [rbp-0x18]
   0x000000000040120c <+170>:	mov    edx,0x20
   0x0000000000401211 <+175>:	mov    esi,0x43
   0x0000000000401216 <+180>:	mov    rdi,rax
   0x0000000000401219 <+183>:	call   0x401060 <memset@plt>
   0x000000000040121e <+188>:	lea    rdi,[rip+0xe09]        # 0x40202e
   0x0000000000401225 <+195>:	call   0x401040 <puts@plt>
   0x000000000040122a <+200>:	mov    rax,QWORD PTR [rbp-0x18]
   0x000000000040122e <+204>:	mov    rdi,rax
   0x0000000000401231 <+207>:	call   0x401030 <free@plt>
   0x0000000000401236 <+212>:	mov    rax,QWORD PTR [rbp-0x10]
   0x000000000040123a <+216>:	mov    rdi,rax
   0x000000000040123d <+219>:	call   0x401030 <free@plt>
   0x0000000000401242 <+224>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000401246 <+228>:	mov    rdi,rax
   0x0000000000401249 <+231>:	call   0x401030 <free@plt>
   0x000000000040124e <+236>:	mov    edi,0x20
   0x0000000000401253 <+241>:	call   0x401070 <malloc@plt>
   0x0000000000401258 <+246>:	mov    QWORD PTR [rbp-0x20],rax
   0x000000000040125c <+250>:	mov    edi,0x20
   0x0000000000401261 <+255>:	call   0x401070 <malloc@plt>
   0x0000000000401266 <+260>:	mov    QWORD PTR [rbp-0x28],rax
   0x000000000040126a <+264>:	mov    edi,0x20
   0x000000000040126f <+269>:	call   0x401070 <malloc@plt>
   0x0000000000401274 <+274>:	mov    QWORD PTR [rbp-0x30],rax
   0x0000000000401278 <+278>:	mov    rax,QWORD PTR [rbp-0x20]
   0x000000000040127c <+282>:	mov    rsi,rax
   0x000000000040127f <+285>:	lea    rdi,[rip+0xdb9]        # 0x40203f
   0x0000000000401286 <+292>:	mov    eax,0x0
   0x000000000040128b <+297>:	call   0x401050 <printf@plt>
   0x0000000000401290 <+302>:	mov    rax,QWORD PTR [rbp-0x28]
   0x0000000000401294 <+306>:	mov    rsi,rax
   0x0000000000401297 <+309>:	lea    rdi,[rip+0xdaf]        # 0x40204d
   0x000000000040129e <+316>:	mov    eax,0x0
   0x00000000004012a3 <+321>:	call   0x401050 <printf@plt>
   0x00000000004012a8 <+326>:	mov    rax,QWORD PTR [rbp-0x30]
   0x00000000004012ac <+330>:	mov    rsi,rax
   0x00000000004012af <+333>:	lea    rdi,[rip+0xda5]        # 0x40205b
   0x00000000004012b6 <+340>:	mov    eax,0x0
   0x00000000004012bb <+345>:	call   0x401050 <printf@plt>
   0x00000000004012c0 <+350>:	mov    eax,0x0
   0x00000000004012c5 <+355>:	leave  
   0x00000000004012c6 <+356>:	ret    
End of assembler dump.
```
Here is our main function, our goal for now is to understand exactly what happened just after the 3 frees, so :
```
b *0x000000000040124e
```
So we break at the address just after the 3 frees `mov edi, 0x20`  
Now let's run :
```
run
```
It printed this :
```
ptr1 -> 0x4052a0
ptr2 -> 0x4052d0
ptr3 -> 0x405300
Freeing pointers
```
Of course the addresses may differ for you
And it reached our breakpoint  
Our goal is to take a look at our 3 chunks, so now let's just see the memory from our first pointer `ptr1 -> 0x4052a0` but - 0x10 because we want to see it's metadata as well  
So :
```
x/50gx 0x4052a0-0x10
```
Now let's take a deeep look :
```
0x405290:	0x0000000000000000	0x0000000000000031
0x4052a0:	0x00000000004052d0	0x0000000000405010
0x4052b0:	0x4141414141414141	0x4141414141414141
0x4052c0:	0x0000000000000000	0x0000000000000031
0x4052d0:	0x0000000000405300	0x0000000000405010
0x4052e0:	0x4242424242424242	0x4242424242424242
0x4052f0:	0x0000000000000000	0x0000000000000031
0x405300:	0x0000000000000000	0x0000000000405010
0x405310:	0x4343434343434343	0x4343434343434343
```
Here is the overall chunk 1 (for ptr1) :
```
0x405290:	0x0000000000000000	0x0000000000000031
0x4052a0:	0x00000000004052d0	0x0000000000405010
0x4052b0:	0x4141414141414141	0x4141414141414141
```
Here is the overall chunk 2 (for ptr2) :
```
0x4052c0:	0x0000000000000000	0x0000000000000031
0x4052d0:	0x0000000000405300	0x0000000000405010
0x4052e0:	0x4242424242424242	0x4242424242424242
```
Here is the overall chunk 3 (for ptr3) :
```
0x4052f0:	0x0000000000000000	0x0000000000000031
0x405300:	0x0000000000000000	0x0000000000405010
0x405310:	0x4343434343434343	0x4343434343434343
```
So you may have thought so far, where is the linked list ? So here is it !  
Can you see that ? 
First look how `ptr1` (`0x4052a0`) points to `0x00000000004052d0` (in unsigned long)
               `ptr2` (`0x4052d0`) points to `0x0000000000405300` (in unsigned long)
           and `ptr3` (`0x405300`) points to `0x0000000000000000` (in unsigned long)
That's exactly the structure of our linked list that we talk about since the beginning !  
So here is the linked list :  
```
`ptr1` points to `ptr2` (0x4052d0)
`ptr2 points to `ptr3` (0x405300)
`ptr3` points to `0x0000000000000000` (end of linked list)
```
