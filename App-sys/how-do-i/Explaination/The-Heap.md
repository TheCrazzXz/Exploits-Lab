
In this article i won't explain what is the heap, but i'll give some resources so then you can understand
# Resources
Chunks and frees (ESSENTIAL) :
Liveoverflow :
https://www.youtube.com/watch?v=HPDBOhiKaD8  
https://www.youtube.com/watch?v=TfJrU95q1J4
# Fast bins
## Insight and introduction
Source  : https://guyinatuxedo.github.io/25-heap/index.html (i want to go deeper in details)

So when malloc frees a chunk,  
it will typically insert it into one of the **bin lists** (assuming it can't do something like consolidate it with the top chunk).   
then with a later allocation, it will check the **bins** to see if there are any **freed chunks** that it could allocate to serve the request.  
The purpose of this is so it can **reuse** previous **freed chunks**, for performance improvements.  
**Taken From Nightmare website**

Now from these bins, there are many types of them, depending on the size of the freed data  
First there are **fast bins**, a fast bin is a **linked list**  
But what is a linked list ?  
A linked list is a list where every element points to the next one until the end of the list (the last one points to 0, it significates that it's the end of the list)  
So here, there are 7 fastbins, so 7 linked list, but why 7 ? First they are referenced by their index, so the first one is index 0, seond is index 1 and the 7th one is index 6  
So still, why seven ? Well that's because each one is made for a certain range of size for a chunk :
```
Fastbins[idx=0, size=0x10]
Fastbins[idx=1, size=0x20]
Fastbins[idx=2, size=0x30]
Fastbins[idx=3, size=0x40]
Fastbins[idx=4, size=0x50]
Fastbins[idx=5, size=0x60]
Fastbins[idx=6, size=0x70]
```
- A chunk of size `0x20-0x2f` would fit into idx 0,
- a chunk of size `0x30-0x3f` would fit into idx 1, **Taken From Nightmare website**
- a chunk of size `0x40-0x4f` would fit into idx 2 and so forth...
For example, if we free a chunk of size '0x39' it will be added to the index 1, since it's size is between `0x30-0x3f`  
## Concept / How it works
Here's how these fastbins actually works :
If we allocate some data, let's say we malloc in order `ptr1`, `ptr2` and `ptr3` :
```c
char* ptr1 = malloc(10);
char* ptr2 = malloc(10);
char* ptr3 = malloc(10);

printf("a@%p\n", ptr1);
printf("b@%p\n", ptr2);
printf("c@%p\n\n", ptr3);
```
Now we have 3 chunks that are allocated that have the same size  
Now we free all of them in order :
```c
free(ptr1);
free(ptr2);
free(ptr3);
```
As we saw just before, since they have the same size `10`, they will all be put on the same fastbin  
So first the `ptr1` will be added to the linked list :
```
Tcachebins[idx=0, size=0x20, count=1]
    ←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE)
```
Yes it's `tcache` and not `fastbin` but it works the same, we'll see tcache later

Now think of this linked list like a stack, the next freed chunk (`ptr2`) will be added bellow the `ptr1` chunk :
```
Tcachebins[idx=0, size=0x20, count=2]
←  Chunk(addr=0x4052c0 (ptr2), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE)
```
And `ptr3` is freed afterwards :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=0x4052e0 (ptr3), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4052c0 (ptr2), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE)
```
Also i got these infos from fastbins via gdb gef extension (`heap bins` command)  
Now as you can see the 1st freed chunk is added then all other new freed ones are added just bellow the previous one, just like a stack, the `push` operation !  
Now after these frees, let's allocate 3 new pointers `ptr4`, `ptr5` and `ptr6` of the same size range for the fastbin (0x20) :
```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	char* ptr1 = malloc(10);
	char* ptr2 = malloc(10);
	char* ptr3 = malloc(10);

	printf("ptr1@%p\n", ptr1);
	printf("ptr2@%p\n", ptr2);
	printf("ptr3@%p\n\n", ptr3);

	free(ptr1);
	free(ptr2);
	free(ptr3);

    printf("Freed chunks\n");

	char* ptr4 = malloc(10);
	char* ptr5 = malloc(10);
	char* ptr6 = malloc(10);

	printf("ptr4@%p\n", ptr4);
	printf("ptr5@%p\n", ptr5);
	printf("ptr6@%p\n\n", ptr6);	
}
```
It shitted this :
```
ptr1@0x4052a0
ptr2@0x4052c0
ptr3@0x4052e0

Freed chunks
ptr4@0x4052e0
ptr5@0x4052c0
ptr6@0x4052a0
```
Didn't you notice something ? Yes `ptr4` = `ptr3` ; `ptr5` = `ptr2` and `ptr6` = `ptr1`  
And there's an explaination for that !
Remember, this is the linked list before the new allocations :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=0x4052e0 (ptr3), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4052c0 (ptr2), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE)
```
Actually, exactely like a pop, when we allocated `ptr4`, malloc returned the address in the top of the linked list, so `ptr3` :
```c
char* ptr4 = malloc(10) // => ptr3;
```
Then just like a `pop` operation, it deleted the element at the top of our list :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=0x4052c0 (ptr2), size=0x20, flags=PREV_INUSE) 
←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE)
```
So now the element at the top is `ptr2`, and guess what will happen when we'll allocate `ptr4`...  
```c
char* ptr5 = malloc(10) // => ptr2;
```
Since `ptr2` is at the top  
Now it looks like this :
```
Tcachebins[idx=0, size=0x20, count=3]
←  Chunk(addr=0x4052a0 (ptr1), size=0x20, flags=PREV_INUSE)
```
You got the idea :
```c
char* ptr6 = malloc(10) // => ptr1;
```
That's it, if we generalise, we can say that :
- If we malloc in order `a`, `b`, `c`, ... with the same size range
- Then if we free them in order `a`, `b`, `c`, ... they will be added in the linked list such as :
```
...
c
b
a
```
- Then if we allocate `d`, `e`, `f` ... of the same size range as `a`, `b`, `c` ... :
- Then `d` = `c` (we pop `c`)
- `e` = `b` (we pop `b`)
- `c` = `a` (we pop `a`)
- etc...
- And now our list is empty again
## Deep look
Now let's see how exactly fastbins linked list actually works  
So here we'll analyse it's behaviour using gdb :
So we will compile this program with the `g` arguemnt : `gcc -g main.c -o ...`  
Let's open it with gdb and `list main,+99` (I use gdb gef extensiob)
```
gef➤  list main,+99
6	{
7	    unsigned long* ptr1 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
8	    unsigned long* ptr2 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
9	    unsigned long* ptr3 = malloc(0x20); // Linked list idx 1 => 0x20-0x2f
10	
11	    printf("ptr1 -> 0x%x => 0x%x\n", ptr1, *ptr1);
12	    printf("ptr2 -> 0x%x => 0x%x\n", ptr2, *ptr2);
13	    printf("ptr3 -> 0x%x => 0x%x\n", ptr3, *ptr3);
14	
15	    memset(ptr1, 'A', 0x20);
16	    memset(ptr2, 'B', 0x20);
17	    memset(ptr3, 'C', 0x20);
18	
19	    printf("Freeing pointers\n");
20	    free(ptr1);
21	    free(ptr2);
22	    free(ptr3);
23	
24	    printf("ptr1 -> 0x%x => 0x%lx\n", ptr1, *ptr1);
25	    printf("ptr2 -> 0x%x => 0x%lx\n", ptr2, *ptr2);
26	    printf("ptr3 -> 0x%x => 0x%lx\n", ptr3, *ptr3);
27	
28	    unsigned long* ptr4 = malloc(0x20);
29	    unsigned long* ptr5 = malloc(0x20);
30	    unsigned long* ptr6 = malloc(0x20);
31	
32	    printf("ptr4 -> 0x%x \n", ptr4);
33	    printf("ptr5 -> 0x%x\n", ptr5);
34	    printf("ptr6 -> 0x%x\n", ptr6);
35	}
```
Let's set a breakpoint after each before the first free and after all frees as well :
```
b 20
b 21
b 22
b 24
```
Now let's set a breakpoint before the first and after each allocation :
```
b 28
b 29
b 30
b 32
```
Now we run : `run`
We're just before the first free, let's see our bins : `heap bins` :
```
───────────────────────────────────────────────────────────────────────────────────────────────── Tcachebins for thread 1 ─────────────────────────────────────────────────────────────────────────────────────────────────
All tcachebins are empty
────────────────────────────────────────────────────────────────────────────────────────── Fastbins for arena at 0x7ffff7fa1b80 ──────────────────────────────────────────────────────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
──────────────────────────────────────────────────────────────────────────────────────── Unsorted Bin for arena at 0x7ffff7fa1b80 ────────────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
───────────────────────────────────────────────────────────────────────────────────────── Small Bins for arena at 0x7ffff7fa1b80 ─────────────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
───────────────────────────────────────────────────────────────────────────────────────── Large Bins for arena at 0x7ffff7fa1b80 ─────────────────────────────────────────────────────────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```
Of course we have nothing because we didn't free anything yet  
Now let's free all of our pointers :
```
c
c
c
```
So i hit `c` 3 times  
Now let's see our bins :
```
Tcachebins[idx=1, size=0x30, count=3] ←  Chunk(addr=0x405300 (ptr3), size=0x30, flags=PREV_INUSE)  ←  Chunk(addr=0x4052d0 (ptr2), size=0x30, flags=PREV_INUSE)  ←  Chunk(addr=0x4052a0 (ptr1), size=0x30, flags=PREV_INUSE)
```
Now you may ask, why is this a linked list ? The next allocated chunk will take the address of the top, then next-next will take address of ptr2 and so forth  
Actually yes, but not in the way you probably think  
Actually :  
- the 1st next chunk will take the address of `ptr3`
- the 2nd next chunk will take the address of `*ptr3`
- the 3rd next chunk will take the address of `*ptr2`
And if you ask :
```
print *ptr3
```
```
0x4052d0 (ptr2)
```
```
print *ptr2
```
```
0x4052a0 (ptr1)
```
So :  
- the 1st next chunk will take the address of `ptr3`
- the 2nd next chunk will take the address of `*ptr3` = `ptr2`
- the 3rd next chunk will take the address of `*ptr2` = `ptr1`
That's why it results the same as saying what i said before  
Also `*ptr1` = `NULL = 0` as it represents the end of the linked list  
You may also ask, why the f is that ?  
Well remember it's a linked list, a linked list works like this :
```
*Elem1 = &Elem2 ; *Elem2 = &Elem3 ; *Elem3 = &Elem4 ... 
```
So at each free, it's a pop front that is done : [https://github.com/jasonchampagne/FormationVideo/blob/master/Ressources/C/schema-liste.png]

```
Chunk(addr=0x405300 (p3), size=0x30, flags=PREV_INUSE) ->  Chunk(addr=0x4052d0 (p2), size=0x30, flags=PREV_INUSE)  -> Chunk(addr=0x4052a0 (p1), size=0x30, flags=PREV_INUSE)
```
Where `->` means "points to"  
(`p` = `ptr`)  
Now when we will malloc : 
```
We hit 'c' three times
```
First our fastbin is now empty and then :
```
ptr4 = 0x405300
ptr5 = *ptr3 = *0x405300 = 0x4052d0
ptr6 = *ptr2 = *0x4052d0 = 0x4052a0
```
And that's it ! Thanks for reading  
