# Explaination
## The Memory Stack
The memory stack is a region in Memory where data can be stored and used, the C language uses the stack to store some values, but not necesseraly ALL values, numbers, char arrays, pointers that you initilaize in a function are stored on the stack, in fact here are some examples :
```c

int uninitialized_num; // Stored on .bss (4 bytes)
unsigned int initialized_num = 42 // Stored on .data (4 bytes)

int main(void)
{
	char c; // Stored in the stack (1 byte)
	int number = 50; // Stored on the stack (4 bytes)
	char buffer[256]; // Stored on the stack (4 bytes)
	char* data = "Hello"; // The pointer to the "Hello" string (4 bytes) is stored on the stack while the "Hello" string is placed in .data section
}
```
Now how is this stack organised, first thing you have to know the program uses 2 pointers which are 2 registers, `SP (16 bits)/ESP (32 bits)/RSP (64 bits)` : The Stack pointer and `BP (16 bits)/EBP (32 bits)/RBP (64 bits)` : The Base pointer  
Let's say you have a stack, it's a pretty simple data structure, let's say you want to put, or as we say to push your first value on an empty stack, it's a stack so each element is pushed on the top of the previous one :
Stack before :
```
(nothing)
```
Let's say we push one byte, `0xef` (we use the instruction `push byte 0xef`)
Stack :
```
STACK POINTER -> ADDRESS 0x100 |0xef| <- BASE POINTER 
```
As you can see the stack pointer and the base pointer together point to the same address, so in this case `0x100` (address 0x100 is an example)  
Now let's say we want to add a 4 bytes unsigned long : `0xdeadc0de` : `push 0xdeadc0de` :
```
ADDRESS 0x0fc |0xde| <- STACK POINTER
ADDRESS 0x0fd |0xad|
ADDRESS 0x0fe |0xc0|
ADDRESS 0x0ff |0xde|

ADDRESS 0x100 |0xef| <- BASE POINTER 
```
As you can see, of couse each byte of our number were added individually, so first the `0xde` byte got pushed then `0xc0`...  
So numbers use the little endian system, so the placement of the bytes of each number is reversed, so last byte of the number is placed first, the second one is placed then... and the first one is placed last  

As you can see the stack pointer was updated to the value on the top of the stack, and actually the top of the stack is 4 bytes lower ! Actually the when you push elements on the stack, they're added on the addresses lower, so here we sub the stack pointer by 4  

Now let's say we want to allocate a string, so let's say : "/bin/sh", first strings in C are NULL-Terminated  
It means that a string in C has to end with a null byte, so we'll allocate : "/bin/sh\x00", so in raw bytes :
```
0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00
'/'   'b'   'i'   'n'   '/'   's'   'h'   NULL
```
Now in assembler we would do :
```asm
push 0x6e69622f ; "/bin"
push 0x0068732f ; "/sh\x00"
```
After doing this the stack looks like this :
```
ADDRESS 0x0f4 |0x00| NULL <- STACK POINTER
ADDRESS 0x0f5 |0x68| 'h'
ADDRESS 0x0f6 |0x73| 's'
ADDRESS 0x0f7 |0x2f| '/'
ADDRESS 0x0f8 |0x6e| 'n'
ADDRESS 0x0f9 |0x69| 'i'
ADDRESS 0x0fa |0x62| 'b'
ADDRESS 0x0fb |0x2f| '/'

ADDRESS 0x0fc |0xde|
ADDRESS 0x0fd |0xad|
ADDRESS 0x0fe |0xc0|
ADDRESS 0x0ff |0xde|

ADDRESS 0x100 |0xef| <- BASE POINTER 
```
And the stack pointer was updated to the element at the top of the stack, so 8 bytes lower   
## Pop
Pop is an instruction that looks for the element at the top of the stack, sets it to a register and "removes this element" by setting the stack pointer to point to the element before it  
`pop <register> `will pop 4 bytes in 32 bits and 8 bytes in 64 bits, so if we do :
```
pop eax
```
So it will pop the 4 bytes at the top of the stack, so they are : `0x0068732f`, so now `eax`=`0x0068732f` and now the stack looks like this :
```
ADDRESS 0x0f8 |0x6e| 'n' <- Stack pointer 
ADDRESS 0x0f9 |0x69| 'i'
ADDRESS 0x0fa |0x62| 'b'
ADDRESS 0x0fb |0x2f| '/'

ADDRESS 0x0fc |0xde|
ADDRESS 0x0fd |0xad|
ADDRESS 0x0fe |0xc0|
ADDRESS 0x0ff |0xde|

ADDRESS 0x100 |0xef| <- BASE POINTER 
```
Somehow we corrupted the string because now there is no more NULL byte... Or maybe yes ?... Maybe all data that we "remove" don't really goes ? How does this "remove" works ?
## The stack theoretical model != Reality in memory
The stack is not growing or shrinking, it's not really extensible memory, actually `push` doesn't really adds now address, the memory is not really extended !  Actually what it does is that it just substracts the stack pointer by 4 bytes and copies the data to the address, so it's memory that we already have !  
Pop doesn't remove data, actually it's not really possible to remove or delete memory because the memory has fixed number or data where we can store bytes, actually pop looks for the value at the top of the stack sets it to the register we supplied and then just increases the stack pointer by 4 so the data is not part of the stack anymore but still exists on the memory
