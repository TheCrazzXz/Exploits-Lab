# Explaination
## The Memory Stack
The memory stack is a region in Memory where data can be stored and used, the C language uses the stack to store some values, but not necesserily ALL values, numbers, char arrays, pointers that you initilaize in a function are stored on the stack, in fact here are some examples :
```c

int uninitialized_num; // Stored on .bss (4 bytes)
unsigned int initialized_num = 42 // Stored on .data (4 bytes)

int main(void)
{
	char c; // Stored in the stack (1 byte)
	int number = 50; // Stored on the stack (4 bytes)
	char buffer[256]; // Stored on the stack (4 bytes)
	char* data = "Hello"; // The pointer to the "Hello" string (4 bytes) is stored on the stack while the "Hello" string is placed in .data section
}
```
Now how is this stack organised, first thing you have to know the program uses 2 pointers which are 2 registers, `SP (16 bits)/ESP (32 bits)/RSP (64 bits)` : The Stack pointer and `BP (16 bits)/EBP (32 bits)/RBP (64 bits)` : The Base pointer  
Let's say you have a stack, it's a pretty simple data structure, let's say you want to put, or as we say to push your first value on an empty stack, it's a stack so each element is pushed on the top of the previous one :
Stack before :
```
(nothing)
```
Let's say we push one byte, `0xef` (we use the instruction `push byte 0xef`)
Stack :
```
STACK POINTER -> ADDRESS 0x100 |0xef| <- BASE POINTER 
```
As you can see the stack pointer and the base pointer together point to the same address, so in this case `0x100` (address 0x100 is an example)  
Now let's say we want to add a 4 bytes unsigned long : `0xdeadc0de` : `push 0xdeadc0de` :
```
ADDRESS 0x0fc |0xde| <- STACK POINTER
ADDRESS 0x0fd |0xad|
ADDRESS 0x0fe |0xc0|
ADDRESS 0x0ff |0xde|

ADDRESS 0x100 |0xef| <- BASE POINTER 
```
As you can see, of couse each byte of our number were added individually, so first the `0xde` byte got pushed then `0xc0`...  
So numbers use the little endian system, so the placement of the bytes of each number is reversed, so last byte of the number is placed first, the second one is placed then... and the first one is placed last  

As you can see the stack pointer was updated to the value on the top of the stack, and actually the top of the stack is 4 bytes lower ! Actually the when you push elements on the stack, they're added on the addresses lower, so here we sub the stack pointer by 4  

Now let's say we want to allocate a string, so let's say : "/bin/sh", first strings in C are NULL-Terminated  
It means that a string in C has to end with a null byte, so we'll allocate : "/bin/sh\x00", so in raw bytes :
```
0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00
'/'   'b'   'i'   'n'   '/'   's'   'h'   NULL
```
Now in assembler we would do :
```asm
push 0x6e69622f ; "/bin"
push 0x0068732f ; "/sh\x00"
```
After doing this the stack looks like this :
```
ADDRESS 0x0f4 |0x00| NULL <- STACK POINTER
ADDRESS 0x0f5 |0x68| 'h'
ADDRESS 0x0f6 |0x73| 's'
ADDRESS 0x0f7 |0x2f| '/'
ADDRESS 0x0f8 |0x6e| 'n'
ADDRESS 0x0f9 |0x69| 'i'
ADDRESS 0x0fa |0x62| 'b'
ADDRESS 0x0fb |0x2f| '/'

ADDRESS 0x0fc |0xde|
ADDRESS 0x0fd |0xad|
ADDRESS 0x0fe |0xc0|
ADDRESS 0x0ff |0xde|

ADDRESS 0x100 |0xef| <- BASE POINTER 
```
And the stack pointer was updated to the element at the top of the stack, so 8 bytes lower   
## Pop
Pop is an instruction that looks for the element at the top of the stack, sets it to a register and "removes this element" by setting the stack pointer to point to the element before it  
`pop <register> `will pop 4 bytes in 32 bits and 8 bytes in 64 bits, so if we do :
```
pop eax
```
So it will pop the 4 bytes at the top of the stack, so they are : `0x0068732f`, so now `eax`=`0x0068732f` and now the stack looks like this :
```
ADDRESS 0x0f8 |0x6e| 'n' <- Stack pointer 
ADDRESS 0x0f9 |0x69| 'i'
ADDRESS 0x0fa |0x62| 'b'
ADDRESS 0x0fb |0x2f| '/'

ADDRESS 0x0fc |0xde|
ADDRESS 0x0fd |0xad|
ADDRESS 0x0fe |0xc0|
ADDRESS 0x0ff |0xde|

ADDRESS 0x100 |0xef| <- BASE POINTER 
```
Somehow we corrupted the string because now there is no more NULL byte... Or maybe yes ?... Maybe all data that we "remove" don't really goes ? How does this "remove" works ?
## The stack theoretical model != Reality in memory
The stack is not growing or shrinking, it's not really extensible memory, actually `push` doesn't really adds now address, the memory is not really extended !  Actually what it does is that it just substracts the stack pointer by 4 bytes and copies the data to the address, so it's memory that we already have !  
`pop` doesn't remove data, actually it's not really possible to remove or delete memory because the memory has fixed number or data where we can store bytes, actually pop looks for the value at the top of the stack sets it to the register we supplied and then just increases the stack pointer by 4 so the data is not part of the stack anymore but still exists on the memory
## Stack allocations
We can allocate memory on the stack by doing `sub <stack pointer register>, <size>`, where size is the size of the data we want to allocate, so we don't necesserily have to `push`  
We can now "remove" this data or just removing it from the stack by doing `add <stack pointer register>, <size of allocated data>`
## Calls, Return pointers and stack frames
As you may know in C, when you declare variables in a function, you can't use it in other functions, that's because of something called a stack frame  
Let's create a simple program in C :
```c
#include <stdio.h>
#include <string.h>

void function()
{
	int data1 = 0xdeadbeef;
	int data2 = 0xdeadc0de;
	unsigned char c = 0xff;
}

int main(void)
{
	function();
}
```
We compile it and we can use GDB to debug it  
Once we are in gdb, we can simply disassemble the program :
```
set disassembly-flavor intel
disass main
```
```asm
Dump of assembler code for function main:
   0x0040147b <+0>:     push   ebp
   0x0040147c <+1>:     mov    ebp,esp
   0x0040147e <+3>:     and    esp,0xfffffff0
   0x00401481 <+6>:     call   0x4019d0 <__main>
   0x00401486 <+11>:    call   0x401460 <function>
   0x0040148b <+16>:    mov    eax,0x0
   0x00401490 <+21>:    leave
   0x00401491 <+22>:    ret
   0x00401492 <+23>:    nop
   0x00401493 <+24>:    nop
   0x00401494 <+25>:    xchg   ax,ax
   0x00401496 <+27>:    xchg   ax,ax
   0x00401498 <+29>:    xchg   ax,ax
   0x0040149a <+31>:    xchg   ax,ax
   0x0040149c <+33>:    xchg   ax,ax
   0x0040149e <+35>:    xchg   ax,ax
End of assembler dump.
```
For information i compiled it on windows, but same idea on any system, as you can see, there's a `call` to `function`, so it will jump there but not only, call is an instruction that takes an address, it will first push the address of the instruction after the call so here it's `0x0040148b` and jumps to the address we called, so function, why did it push this `0x0040148b` ?  
You know how functions work in C, we call them and then when they end, we return to the code after the call to them, it's exactly the same purpose here, because if you disassemble the function `function` :
```
disass function
```
```
Dump of assembler code for function function:
   0x00401460 <+0>:     push   ebp
   0x00401461 <+1>:     mov    ebp,esp
   0x00401463 <+3>:     sub    esp,0x10
   0x00401466 <+6>:     mov    DWORD PTR [ebp-0x4],0xdeadbeef
   0x0040146d <+13>:    mov    DWORD PTR [ebp-0x8],0xdeadc0de
   0x00401474 <+20>:    mov    BYTE PTR [ebp-0x9],0xff
   0x00401478 <+24>:    nop
   0x00401479 <+25>:    leave
   0x0040147a <+26>:    ret
End of assembler dump.
```
Yes there is another `push` that pushes ebp, why ? We'll see that just after that, hint : Stack frame  
You can see the two final instructions, which are : `leave` and `ret`, imagine there were nothing but `ret`, `ret` is an instruction that looks for the address (4 bytes in 32 bits and 8 bytes in 64 bits) at the top of the stack pops it and jumps there, so it's exactly like a :
```
pop <instruction pointer>
```
So what is the value in the top of the stack ? Well it's this `0x0040148b` address in main after the call to `function`, so it will simply jump, return there, so it continues the program after to call to this function, that's simply it !  
Now there are other things, `push ebp ; mov ebp, esp ; sub esp, 0x10` and some `mov`s followed by `leave`  
Remember in a function, all variables we declare are like part of the function, so we want to reserve as many data our variables takes in memory and then at the end we want to "remove" (in quotation marks) this data from the stack, that's exactly what is done here :
```
push ebp
```
So the stack looks like :
```
<ebp save> (4 bytes) : The save of EBP register just before the rest of the function is executed
0x0040148b (4 bytes) : The return pointer after the call in main
...
```
Then we set `ebp` to `esp`, so somehow we save `esp` value at this moment in `ebp`  
Then we want to allocate space for our variables, so `sub esp, 0x10` is called (`0x10`=`16`), so we allocate 16 bytes, which is enough space for our variables because gathered, their size is `4+4+1` so `9` bytes  
Our stack looks like this :
```
ADDR ebp-16 | <- STACK POINTER
ADDR ebp-15 |
ADDR ebp-14 |
ADDR ebp-13 |
ADDR ebp-12 |
ADDR ebp-11 |
ADDR ebp-10 |
ADDR ebp-9  | &c
ADDR ebp-8  | &data2
ADDR ebp-7  |
ADDR ebp-6  |
ADDR ebp-5  |
ADDR ebp-4  | &data1
ADDR ebp-3  |
ADDR ebp-2  |
ADDR ebp-1  |

<ebp save> (4 bytes) <- BASE POINTER
0x0040148b (4 bytes) : The return pointer after the call in main
```
So then as you can see `data1` address is `ebp-4`, `data2` address is `ebp-8` and `c` address is `ebp-9`  
So : `mov DWORD PTR [ebp-0x4],0xdeadbeef` so we set the value at the address `ebp-4` which is `data1` to `0xdeadbeef`  
`mov DWORD PTR [ebp-0x8],0xdeadc0de` : so we set the value at the address `ebp-8` which is `data2` to `0xdeadc0de`  
and then `mov BYTE PTR [ebp-0x9],0xff` : so we set the value at the address `ebp-9` which is `c` to `0xc`  
That's how our variables are useed, now the stack looks like this :
```
ADDR ebp-16 | <- STACK POINTER
ADDR ebp-15 |
ADDR ebp-14 |
ADDR ebp-13 |
ADDR ebp-12 |
ADDR ebp-11 |
ADDR ebp-10 |

ADDR ebp-9  |0xff| &c

ADDR ebp-8  |0xde| &data2
ADDR ebp-7  |0xad|
ADDR ebp-6  |0xc0|
ADDR ebp-5  |0xde|

ADDR ebp-4  |0xde| &data1
ADDR ebp-3  |0xad|
ADDR ebp-2  |0xbe|
ADDR ebp-1  |0xef|

<ebp save> (4 bytes) <- BASE POINTER
0x0040148b (4 bytes) : The return pointer after the call in main
...
```
There are still from `ebp-10` and `ebp-16` values that we don't really care why they are allocated but ok  
Then we have a `nop` it's just an instruction that does nothing  
Then we have a `leave`, the `leave` instruction will remove the stack frame so our stack looks like this :
```
STACK POINTER -> <ebp save> (4 bytes) <- BASE POINTER
0x0040148b (4 bytes) : The return pointer after the call in main
...
```
Then this instructions does a `pop ebp`, so we restore the `ebp` value that we saved on the stack before that the function does things with stack frame  
So the stack looks like this :
```
0x0040148b (4 bytes) <- STACK POINTER
...
```
Now comes the final instruction of the function, `ret`, which just does a `pop eip`, so we return/jump to the address which is pointed by the value at the top of the stack, so this value is `0x0040148b` so we return, jump to it  
So then our program continues :
```asm
Dump of assembler code for function main:
   0x0040147b <+0>:     push   ebp
   0x0040147c <+1>:     mov    ebp,esp
   0x0040147e <+3>:     and    esp,0xfffffff0
   0x00401481 <+6>:     call   0x4019d0 <__main>
   0x00401486 <+11>:    call   0x401460 <function>
   0x0040148b <+16>:    mov    eax,0x0 <----------------------- HERE
   0x00401490 <+21>:    leave
   0x00401491 <+22>:    ret
   0x00401492 <+23>:    nop
   0x00401493 <+24>:    nop
   0x00401494 <+25>:    xchg   ax,ax
   0x00401496 <+27>:    xchg   ax,ax
   0x00401498 <+29>:    xchg   ax,ax
   0x0040149a <+31>:    xchg   ax,ax
   0x0040149c <+33>:    xchg   ax,ax
   0x0040149e <+35>:    xchg   ax,ax
End of assembler dump.
```
