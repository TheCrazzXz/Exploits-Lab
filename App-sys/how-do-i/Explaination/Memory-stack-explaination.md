# EXPLAINATION
## MEMORY (stack) :
The memory is the place where all variables go, it can stock a lot of data, each variable has an address in the memory

The memory has a region which is the stack, the first variable will be placed at the very bottom of the stack, it will have the lowest address
		
Each time a variable is added to the stack of the memory, it is added over the upper element, and because of that, it's extensible
		
Example : 
```c
int var1 = 50
int var2 = 41
int var3 = 34
```
Stack in memory representation :
```
[-------------------]
Address	  | Value
---------------------
x+8       | 34 //var3
x+4       | 41 //var2
x+0       | 50 //var1
[-------------------]
```
You can see each time you add a variable the new address is the toppest one incremented by 4, why 4 ? Because an `int` size is 4 bytes  
At each allocation, it pushes the stack by `x` bytes when `x` is the size of the type which is allocated
- An integer (`int`) or unsigned integer reserves `4` bytes so it will increment the address by `4`, it is a 32 bits integer
- A `long int` is 4 bytes in 32 bits and 8 bytes in 64 bits
- A character reserves `1` byte (because ASCII is from `0` to `255` so one byte (8 bits)) so it will increment the address the address by `1`
- A structure will allocate the size of structure, including all the sizes of all the variables in it
When you create an array, you reserve multiple memory places (addresses)
Example : 
```c
char arr[] = "PWND"; // char arr[] = {"P", "W", "N", "D"}
```
			
Stack in memory representation :
```
[-------------------]
Address	  | Value
---------------------
x+3      | 'D' //arr[3]
x+2       | 'N' //arr[2]
x+1       | 'W' //arr[1]
x+0       | 'P' //arr[0]
[-------------------]
```
Note that it increments the address by the size of the element, so since a `char` is 1 byte, it will increment the address by 1
Other example :
```c
char *data = (char*) malloc(sizeof(4 * sizeof(char)));
unsigned long num = 12;
unsigned int num2 = 2
```
Here we've allocated :
- A pointer, that we've affected to a malloc, the size of the malloc allocation (here `4 * 1`) doesn't change anything, for this example we will assume that it's the address it is pointing to is `0x 00 00 00 00 AC 4D 8F 0D` in little endian, so the way it is stored in memory, it's `0x 0D 8F 4D AC 00 00 00 00`
- An `unsigned long` variable, which is 12 (`0x 00 00 00 00 00 00 00 0C`, notice there are 8 bytes) in little endian, it's `0x 0C 00 00 00 00 00 00 00`
- And an `unsigned int` variable, which is 2 (`0x 00 00 00 02`, notice there are 4 bytes) in little endian, it's `0x 02 00 00 00 00 00 00 00`
Assuming the program is a 64 bits program, Then there's the stack :
```
[-------------------]
Address	    | Value
---------------------
- unsigned int num2 (0x 00 00 00 02 -> 0x 02 00 00 00)
x+19        | 02
x+16 to x+18| 00
- unsigned long num (0x 00 00 00 00 00 00 00 0C -> 0x 0C 00 00 00 00 00 00 00)
x+9 to x+15 | 00
x+8         | 0C
- char* data (0x 00 00 00 00 AC 4D 8F 0D -> 0x 0D 8F 4D AC 00 00 00 00)
x+4 to x+7  | 00
x+3         | AC
x+2         | 4D
x+1         | 8F
x+0         | 0D
[-------------------]
```
