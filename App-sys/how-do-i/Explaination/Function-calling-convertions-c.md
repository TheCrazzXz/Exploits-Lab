# Function calling convetions in C
In C, there's a difference between calling a function on 32 bits and on 64 bits, more specificly for the arguments of the function (in ELF files)
# On ELF x86 (32 bits)
On a 32 bits program, parameters are simply passed in the stack, pushed in reverse order  
For example :
```c
#include <stdio.h>

void test(char* arg1, int arg2, int arg3, int arg4)
{
	
}
int main(void)
{
	char buf[64];
	test(buf, 1, 2, 3);
}
```
Here we call `test` with arguments : `char* arg1`:`buf`, `int arg2`:`1`, `int arg3`:`2`, `int arg4`:`3`  
When the function will be called, it will first push (so add a new value onto the stack) `3` for `arg4`, then push `2` for `arg3`, push `1` for `arg2`, and push the `address of buffer` (`buf`) for `arg1`  
So basically it will do this :
```nasm
push 0x1 # arg4
push 0x2 # arg3
push 0x3 # arg2
push <address of the buffer> # arg1
call test
```
# On ELF x86_64 (64 bits)
Let's change the source code a bit for this one :
```c
#include <stdio.h>

#include <stdio.h>
#include <limits.h>
void test(char* arg1, int arg2, int arg3, unsigned long long arg4, int arg5, long long arg6)
{

}
int main(void)
{
	char buf[64];
	test(buf, 1, 2, ULLONG_MAX, 4, 5);
}
```
So in 64 bits, arguments are passed in CPU registers with this order :  
```
arg1 : RDI
arg2 : RSI
arg3 : RDX
arg4 : RCX
arg5 : R8
arg6 : R9
Note : It's not the same for syscalls
```
I guess they did that because it's then faster than passing by the memory  
So for our call, it sould be this :
```nasm
mov rdi, <buffer address> # arg1
mov rsi, 0x2 # arg2
mov rdx, 0x3 # arg3
mov rcx, 0xffffffffffffffff # arg4 (ULLONG_MAX)
mov r8, 0x4 # arg5
mov r9, 0x5 # arg6
call test
```
When i disassembled the program, it gived me this :
```nasm
0x000000000000114e <+12>:	mov    r9d,0x5
0x0000000000001154 <+18>:	mov    r8d,0x4
0x000000000000115a <+24>:	mov    rcx,0xffffffffffffffff
0x0000000000001161 <+31>:	mov    edx,0x2
0x0000000000001166 <+36>:	mov    esi,0x1
0x000000000000116b <+41>:	mov    rdi,rax
0x000000000000116e <+44>:	call   0x1125 <test>
```
So it's not exactly the same, actualy, some of the arguments are passend in 32 bits registers, why ? That's because if the value is not a 64 bits value, such as 2, 3 and 5, it makes no sense to pass it as a 64 bits register  
So for `ULLONG_MAX` which is a 64 bits value, it passed in a 64 bits register  
# End
Thanks for reading
