# Format string vulnerability

This one is a **format string vulnerability**, it's a **memory leak vulnerability**, let me explain you how it works
## How does `printf()` works 
`printf()` (for print format) takes infinite arguments, but the first argument is the **format**, like how do you wanna show your variables, to indicate the format of a variable to print,
you have to use a flag (`%s` (string), `%d` (decimal), `%x`, hexadecimal...)
Okay so when you use `printf()`, you usualy do like this : 
```c
printf("Hello, %s, you are %d years old", user_name, user_age);
```
Considering that `user_age` = `19` and `user_name` = `"Patrick"` It will give us :
```
Hello Patrick, you are 19 years old
```
Let's have another example :
```c
printf("%d, %d, %d, %d", var1, var2, var3, var4);
```
## Exploitation
Okay but what happens if we don't give the arguments after the format string ?
```c
printf("%d, %d, %d, %d");
```
We will get some values, and these values, are values from memory, 
- But what are those values ? And how can this be exploited ?
- Well, you're just going to have values from the stack...
- BUT IAM FREAKIN' ASKING YOU WHAT VALUES ARE YOU TALKING ABOUT !!

Oh yeah, first in the stack, you have the backup of `EIP` register (why ? That's because when you call a function, when it finishes and has to return `ret` so it will set `EIP` to this value which is stored in the stack) and also `EBP`, and then you have also other variables which are typical for the C language and... You have your `declared variables` and their content !
Each time you will add a `flag` (`%x`, `%d`...), it is going to increment the address to show, but with ASLR protections (especially on linux) the address are randomizes, so the variables are harder to identify, but that's okay
So let's say you have this :
```c
/*
  Arguments : <message>
*/
int main(int argc, char** argv)
{
  char findme[] = "Pokemon"; //Secret variable
  printf(argv[1]);
}
```
Okay so, this will print the argument we pass in command line
```cmd
> gcc <program_src>.c -o <program>.exe
> <program>.exe "Hello !"
Hello !
```
Okay now let's add some flags...
```cmd
> <program>.exe "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x"
(we get some memory values)
```
And at a moment, you should find ascii values for each characters of findme (here it should be between 10 and 15 flags)
But, just to help, the `%x` flag is bad to find array values, you should use `%lx` so :
```cmd
> <program>.exe "%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx%lx"
(you sould see ascii values of "Pokemon")
```
And yeah, depending on architecture of the program the size of each block (byte word (4 bytes)) will be bigger, so you will be able to find the values more easily, oh and also, in the memory, the values are stored in big endian, it means that it's reversed, example :
```
50 6f 6b 65 6d 6f 6e ("Pokemon")
Will be, in memory :
6e 6f 6d 65 6b 6f 50 ("nomekoP" ("Pokemon" reversed))
```
That's it ! Nice exploit ? Isn't it ?
