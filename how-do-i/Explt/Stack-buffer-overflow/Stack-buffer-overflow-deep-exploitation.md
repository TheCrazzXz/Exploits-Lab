# STACK BUFFER OVERFLOW DEEP EXPLOITATION
## STACK BUFFER OVERFLOW TO OVERWRITE REGISTERS BACKUP
When the assembly instruction `CALL <adress>` is used, it will save 2 registers on the stack, `EBP` and `EIP` (or `RBP` and `RIP` in 64 bits), for now, we don't care about EBP, it's just the stack pointer  
But `EIP` is the instruction pointer, meaning that this register points to the next instruction adress to execute, if we change this instruction pointer to an adress we want, it will jump to it and execute the code it's holding and if the adress not exists, we're gonna have a segmentation fault  
Then with the call, if the function we call has a `ret` instruction, it will set EIP to the topper element in the stack, which is the `EIP` backup
Let's say we have this code :
```c
...
void vuln() //It has to be on another function, NOT MAIN() !!!
{
  char buffer[<BUFFER SIZE>]; //buffer to overflow
  ... // Code that can overflow the buffer ( exemple : gets(buffer); )
}
int main()
{
  vuln(); //Main calls vuln() 
}
```
So here if in `vuln()` we change the `EIP` backup and set it to whatever adress in the memory, it will jump to it and all should be good 
The disassembled code here should be like :
```nasm
<vuln adress>:
  ...
  ret //Pops the adress to EIP
<main adress>:
  ...
  call <vuln adress> //Pushes the stack with the current EIP content
```
