# EXPLOITS
## Stack Buffer overflow
Let's say that you have two arrays
Example :
```c
char arr1[] = "Jack";
char arr2[] = "John";
```
			
Memory representation :
```
[-------------------]
Address	  | Value
---------------------
x+28      | 'N' //arr2[3]
x+24      | 'H' //arr2[2]
x+20	  | 'O' //arr2[1]
x+16      | 'J' //arr2[0]
			
x+12      | 'K' //arr1[3]
x+8       | 'C' //arr1[2]
x+4       | 'A' //arr1[1]
x+0       | 'J' //arr1[0]
[-------------------]
```
So you have 8 memory spaces in the memory, 4 for each array
So the first array `arr1` has addresses from x+0 to x+12
and the second (`arr2`) has addresses from x+16 to x+28
		
Let's try something, we're agreed to say that `array` has max size of 4 characters, but what will happen if we change de 5th element of the array :
```c
char arr1[] = "Jack";
char arr2[] = "John";
			
arr2[5] = 'X' //Overflowing the buffer by setting an element of the index of its max size + 1
```
		
If we see the content of the arrays before and after `arr2[5] = 'X'` :
Before overflow :
```
`arr1` : Array : ['J', 'a', 'c', 'k']
`arr2` : Array : ['J', 'o', 'h', 'n']
```
After overflow :
```
`arr1` : Array : [**'X'**, 'a', 'c', 'k']
`arr2` : Array : ['J', 'o', 'h', 'n']
```
				
As you can see, we overwrote the `arr1[0]` accessing `arr2[5]` (not arr2[4] because there is null terminator string) because it tried to access the address of the stack which is over the `arr[4]` which is the address of the first element of `arr1` (`arr1[0]`)
		
